
// line 1 "zparse.rl"
package dns

// Parse RRs
// With the thankful help of gdnsd and the Go examples for Ragel.
// 

import (
    "os"
    "io"
    "net"
    "strconv"
)

const _RDATAMAX = 7
const _IOBUF = 65365

// Save up tokens, after we've seen the entire rdata
// we can use this.
type token struct {
    T []string      // text
    N []int         // number
    ti int          // text counter
    ni int          // number counter
}

func newToken() *token {
    to := new(token)
    to.T = make([]string, _RDATAMAX)
    to.N = make([]int, _RDATAMAX)
    to.ni, to.ti = 0, 0
    return to
}

// Only push functions are provided. Reading is done, by directly
// accessing the members (T and N). See types.rl.
func (to *token) pushInt(s string) {
    i, err := strconv.Atoi(s)
    if err != nil {
        panic("Failure to parse to int: " + s)
    }
    to.N[to.ni] = i
    to.ni++
    if to.ni > _RDATAMAX {
        panic("Too much rdata (int)")
    }
}

func (to *token) pushString(s string) {
    to.T[to.ti] = s
    to.ti++
    if to.ti > _RDATAMAX {
        panic("Too much rdata (string)")
    }
}

func (to *token) reset() {
    to.ni, to.ti = 0, 0
}


// line 64 "zparse.go"
var z_start int = 1719
var z_first_final int = 1719
var z_error int = 0

var z_en_main int = 1719


// line 63 "zparse.rl"


// SetString
// All the NewReader stuff is expensive...
// only works for short io.Readers as we put the whole thing
// in a string -- needs to be extended for large files (sliding window).
func Zparse(q io.Reader) (z *Zone, err os.Error) {
        buf := make([]byte, _IOBUF) 
        n, err := q.Read(buf)
        if err != nil {
            return nil, err
        }
        buf = buf[:n]
        z = new(Zone)

        data := string(buf)
//        cs, p, pe, eof := 0, 0, len(data), len(data)
        cs, p, pe := 0, 0, len(data)
        brace := false
        lines := 0
        mark := 0
        hdr := new(RR_Header)
        tok := newToken()
        var rr RR

        
// line 99 "zparse.go"
	cs = z_start

// line 102 "zparse.go"
	{
	if p == pe { goto _test_eof }
	switch cs {
	case -666: // i am a hack D:
	fallthrough
case 1719:
	switch data[p] {
		case 9: goto st1
		case 10: goto tr72
		case 32: goto st1
		case 40: goto tr3
		case 41: goto tr4
		case 59: goto st11
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st0:
cs = 0;
	goto _out;
tr3:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1
tr4:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1
tr614:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr616:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr617:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr620:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr622:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr623:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr657:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr659:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr660:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr663:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr665:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr666:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr686:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr688:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr689:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr705:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr707:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr708:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr711:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr713:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr714:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr734:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr736:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr737:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr1342:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr1344:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr1345:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr1356:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr1358:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr1359:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr1819:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr1821:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr1822:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr1825:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr1827:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr1828:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr1848:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr1850:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr1851:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr2222:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr2224:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr2225:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr3967:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr3969:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr3970:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr3973:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr3975:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr3976:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr3996:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr3998:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
tr3999:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1
st1:
	p++
	if p == pe { goto _test_eof1 }
	fallthrough
case 1:
// line 1040 "zparse.go"
	switch data[p] {
		case 9: goto st1
		case 10: goto tr2
		case 32: goto st1
		case 40: goto tr3
		case 41: goto tr4
		case 59: goto tr6
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr5 }
	goto st0
tr2:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1720
tr72:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1720
tr615:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
tr621:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
tr658:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
tr664:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
tr687:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
tr706:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
tr712:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
tr735:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
tr1343:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
tr1357:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
tr1820:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
tr1826:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
tr1849:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
tr2223:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
tr3968:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
tr3974:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
tr3997:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1720
st1720:
	p++
	if p == pe { goto _test_eof1720 }
	fallthrough
case 1720:
// line 1393 "zparse.go"
	switch data[p] {
		case 9: goto st1
		case 10: goto tr2
		case 32: goto st1
		case 40: goto tr3
		case 41: goto tr4
		case 59: goto tr6
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5337
	}
	goto st0
st2:
	p++
	if p == pe { goto _test_eof2 }
	fallthrough
case 2:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr24:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st3
tr25:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st3
tr16:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
	goto st3
tr17:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
	goto st3
tr18:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st3
tr19:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st3
tr23:
// line 101 "zparse.rl"
	{ lines++ }
	goto st3
tr520:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
	goto st3
tr521:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
	goto st3
tr522:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
	goto st3
tr523:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
	goto st3
tr561:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
	goto st3
tr562:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
	goto st3
tr563:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
	goto st3
tr564:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
	goto st3
st3:
	p++
	if p == pe { goto _test_eof3 }
	fallthrough
case 3:
// line 1560 "zparse.go"
	switch data[p] {
		case 9: goto st3
		case 10: goto tr23
		case 32: goto st3
		case 40: goto tr24
		case 41: goto tr25
		case 59: goto st139
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr5 }
	goto st0
tr5:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st4
st4:
	p++
	if p == pe { goto _test_eof4 }
	fallthrough
case 4:
// line 1600 "zparse.go"
	switch data[p] {
		case 9: goto tr27
		case 10: goto tr28
		case 32: goto tr27
		case 40: goto tr29
		case 41: goto tr30
		case 59: goto tr32
	}
	if 48 <= data[p] && data[p] <= 57 { goto st4 }
	goto st0
tr35:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st5
tr36:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st5
tr34:
// line 101 "zparse.rl"
	{ lines++ }
	goto st5
tr27:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
	goto st5
tr28:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st5
tr29:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st5
tr30:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st5
st5:
	p++
	if p == pe { goto _test_eof5 }
	fallthrough
case 5:
// line 1650 "zparse.go"
	switch data[p] {
		case 9: goto st5
		case 10: goto tr34
		case 32: goto st5
		case 40: goto tr35
		case 41: goto tr36
		case 59: goto st6
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	goto st0
tr32:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
	goto st6
st6:
	p++
	if p == pe { goto _test_eof6 }
	fallthrough
case 6:
// line 1687 "zparse.go"
	if data[p] == 10 { goto tr34 }
	goto st6
tr38:
// line 89 "zparse.rl"
	{ mark = p }
	goto st7
st7:
	p++
	if p == pe { goto _test_eof7 }
	fallthrough
case 7:
// line 1699 "zparse.go"
	switch data[p] {
		case 9: goto tr47
		case 10: goto tr48
		case 32: goto tr47
		case 40: goto tr49
		case 41: goto tr50
		case 59: goto tr51
		case 65: goto st14
		case 78: goto st20
		case 97: goto st14
		case 110: goto st20
	}
	goto st0
tr56:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st8
tr57:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st8
tr55:
// line 101 "zparse.rl"
	{ lines++ }
	goto st8
tr47:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st8
tr48:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
	goto st8
tr49:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st8
tr50:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st8
st8:
	p++
	if p == pe { goto _test_eof8 }
	fallthrough
case 8:
// line 1788 "zparse.go"
	switch data[p] {
		case 9: goto st8
		case 10: goto tr55
		case 32: goto st8
		case 40: goto tr56
		case 41: goto tr57
		case 43: goto tr58
		case 59: goto st13
		case 61: goto tr58
		case 92: goto tr58
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr58 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr58 }
	} else {
		goto tr58
	}
	goto st0
tr58:
// line 89 "zparse.rl"
	{ mark = p }
	goto st9
st9:
	p++
	if p == pe { goto _test_eof9 }
	fallthrough
case 9:
// line 1817 "zparse.go"
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 92: goto st9
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
tr68:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st10
tr69:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st10
tr60:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st10
tr62:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st10
tr63:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st10
tr88:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st10
tr90:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st10
tr91:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st10
tr123:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st10
tr125:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st10
tr126:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st10
tr182:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st10
tr184:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st10
tr185:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st10
tr235:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st10
tr237:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st10
tr238:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st10
tr265:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st10
tr267:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st10
tr268:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st10
tr283:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st10
tr285:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st10
tr286:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st10
tr400:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st10
tr402:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st10
tr403:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st10
tr491:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st10
tr493:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st10
tr494:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st10
tr1635:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st10
tr1637:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st10
tr1638:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st10
tr1654:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st10
tr1656:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st10
tr1657:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st10
tr3639:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st10
tr3641:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st10
tr3642:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st10
tr4072:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st10
tr4074:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st10
tr4075:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st10
st10:
	p++
	if p == pe { goto _test_eof10 }
	fallthrough
case 10:
// line 2601 "zparse.go"
	switch data[p] {
		case 9: goto st10
		case 10: goto tr67
		case 32: goto st10
		case 40: goto tr68
		case 41: goto tr69
		case 59: goto tr70
	}
	goto st0
tr67:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1721
tr74:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1721
tr61:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1721
tr89:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1721
tr124:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1721
tr183:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1721
tr236:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1721
tr266:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1721
tr284:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1721
tr401:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1721
tr492:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1721
tr1636:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1721
tr1655:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1721
tr3640:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1721
tr4073:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1721
st1721:
	p++
	if p == pe { goto _test_eof1721 }
	fallthrough
case 1721:
// line 2885 "zparse.go"
	switch data[p] {
		case 9: goto st1
		case 10: goto tr2
		case 32: goto st1
		case 40: goto tr3
		case 41: goto tr4
		case 59: goto tr6
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr6:
// line 89 "zparse.rl"
	{ mark = p }
	goto st11
tr619:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
tr625:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
tr662:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
tr668:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
tr690:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
tr710:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
tr716:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
tr738:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
tr1347:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
tr1361:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
tr1824:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
tr1830:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
tr1852:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
tr2226:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
tr3972:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
tr3978:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
tr4000:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st11
st11:
	p++
	if p == pe { goto _test_eof11 }
	fallthrough
case 11:
// line 3192 "zparse.go"
	if data[p] == 10 { goto tr72 }
	goto st11
tr70:
// line 89 "zparse.rl"
	{ mark = p }
	goto st12
tr65:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st12
tr93:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st12
tr128:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st12
tr187:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st12
tr240:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st12
tr270:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st12
tr288:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st12
tr405:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st12
tr496:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st12
tr1640:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st12
tr1659:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st12
tr3644:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st12
tr4077:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st12
st12:
	p++
	if p == pe { goto _test_eof12 }
	fallthrough
case 12:
// line 3437 "zparse.go"
	if data[p] == 10 { goto tr74 }
	goto st12
tr51:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st13
st13:
	p++
	if p == pe { goto _test_eof13 }
	fallthrough
case 13:
// line 3458 "zparse.go"
	if data[p] == 10 { goto tr55 }
	goto st13
st14:
	p++
	if p == pe { goto _test_eof14 }
	fallthrough
case 14:
	switch data[p] {
		case 65: goto st15
		case 97: goto st15
	}
	goto st0
st15:
	p++
	if p == pe { goto _test_eof15 }
	fallthrough
case 15:
	switch data[p] {
		case 65: goto st16
		case 97: goto st16
	}
	goto st0
st16:
	p++
	if p == pe { goto _test_eof16 }
	fallthrough
case 16:
	switch data[p] {
		case 9: goto tr77
		case 10: goto tr78
		case 32: goto tr77
		case 40: goto tr79
		case 41: goto tr80
		case 59: goto tr81
	}
	goto st0
tr84:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st17
tr85:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st17
tr83:
// line 101 "zparse.rl"
	{ lines++ }
	goto st17
tr77:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st17
tr78:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
	goto st17
tr79:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st17
tr80:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st17
st17:
	p++
	if p == pe { goto _test_eof17 }
	fallthrough
case 17:
// line 3570 "zparse.go"
	switch data[p] {
		case 9: goto st17
		case 10: goto tr83
		case 32: goto st17
		case 40: goto tr84
		case 41: goto tr85
		case 43: goto tr86
		case 59: goto st19
		case 61: goto tr86
		case 92: goto tr86
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr86 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr86 }
	} else {
		goto tr86
	}
	goto st0
tr86:
// line 89 "zparse.rl"
	{ mark = p }
	goto st18
st18:
	p++
	if p == pe { goto _test_eof18 }
	fallthrough
case 18:
// line 3599 "zparse.go"
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 92: goto st18
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
tr81:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st19
st19:
	p++
	if p == pe { goto _test_eof19 }
	fallthrough
case 19:
// line 3637 "zparse.go"
	if data[p] == 10 { goto tr83 }
	goto st19
st20:
	p++
	if p == pe { goto _test_eof20 }
	fallthrough
case 20:
	switch data[p] {
		case 89: goto st21
		case 121: goto st21
	}
	goto st0
st21:
	p++
	if p == pe { goto _test_eof21 }
	fallthrough
case 21:
	switch data[p] {
		case 9: goto tr95
		case 10: goto tr96
		case 32: goto tr95
		case 40: goto tr97
		case 41: goto tr98
		case 59: goto tr99
	}
	goto st0
tr102:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st22
tr103:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st22
tr101:
// line 101 "zparse.rl"
	{ lines++ }
	goto st22
tr512:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
	goto st22
tr513:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st22
tr514:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st22
tr515:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st22
tr95:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
	goto st22
tr96:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
	goto st22
tr97:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st22
tr98:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st22
st22:
	p++
	if p == pe { goto _test_eof22 }
	fallthrough
case 22:
// line 3725 "zparse.go"
	switch data[p] {
		case 9: goto st22
		case 10: goto tr101
		case 32: goto st22
		case 40: goto tr102
		case 41: goto tr103
		case 59: goto st23
		case 65: goto tr105
		case 67: goto tr106
		case 68: goto tr40
		case 77: goto tr43
		case 78: goto tr107
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr105
		case 99: goto tr106
		case 100: goto tr40
		case 109: goto tr43
		case 110: goto tr107
		case 114: goto tr45
		case 115: goto tr46
	}
	goto st0
tr517:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
	goto st23
tr99:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
	goto st23
st23:
	p++
	if p == pe { goto _test_eof23 }
	fallthrough
case 23:
// line 3762 "zparse.go"
	if data[p] == 10 { goto tr101 }
	goto st23
tr105:
// line 89 "zparse.rl"
	{ mark = p }
	goto st24
st24:
	p++
	if p == pe { goto _test_eof24 }
	fallthrough
case 24:
// line 3774 "zparse.go"
	switch data[p] {
		case 9: goto tr47
		case 10: goto tr48
		case 32: goto tr47
		case 40: goto tr49
		case 41: goto tr50
		case 59: goto tr51
		case 65: goto st14
		case 97: goto st14
	}
	goto st0
tr106:
// line 89 "zparse.rl"
	{ mark = p }
	goto st25
st25:
	p++
	if p == pe { goto _test_eof25 }
	fallthrough
case 25:
// line 3795 "zparse.go"
	switch data[p] {
		case 78: goto st26
		case 110: goto st26
	}
	goto st0
st26:
	p++
	if p == pe { goto _test_eof26 }
	fallthrough
case 26:
	switch data[p] {
		case 65: goto st27
		case 97: goto st27
	}
	goto st0
st27:
	p++
	if p == pe { goto _test_eof27 }
	fallthrough
case 27:
	switch data[p] {
		case 77: goto st28
		case 109: goto st28
	}
	goto st0
st28:
	p++
	if p == pe { goto _test_eof28 }
	fallthrough
case 28:
	switch data[p] {
		case 69: goto st29
		case 101: goto st29
	}
	goto st0
st29:
	p++
	if p == pe { goto _test_eof29 }
	fallthrough
case 29:
	switch data[p] {
		case 9: goto tr112
		case 10: goto tr113
		case 32: goto tr112
		case 40: goto tr114
		case 41: goto tr115
		case 59: goto tr116
	}
	goto st0
tr119:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st30
tr120:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st30
tr118:
// line 101 "zparse.rl"
	{ lines++ }
	goto st30
tr112:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st30
tr113:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
	goto st30
tr114:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st30
tr115:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st30
st30:
	p++
	if p == pe { goto _test_eof30 }
	fallthrough
case 30:
// line 3920 "zparse.go"
	switch data[p] {
		case 9: goto st30
		case 10: goto tr118
		case 32: goto st30
		case 40: goto tr119
		case 41: goto tr120
		case 43: goto tr121
		case 59: goto st32
		case 61: goto tr121
		case 92: goto tr121
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr121 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr121 }
	} else {
		goto tr121
	}
	goto st0
tr121:
// line 89 "zparse.rl"
	{ mark = p }
	goto st31
st31:
	p++
	if p == pe { goto _test_eof31 }
	fallthrough
case 31:
// line 3949 "zparse.go"
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 92: goto st31
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
tr116:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st32
st32:
	p++
	if p == pe { goto _test_eof32 }
	fallthrough
case 32:
// line 3987 "zparse.go"
	if data[p] == 10 { goto tr118 }
	goto st32
tr9:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st33
tr40:
// line 89 "zparse.rl"
	{ mark = p }
	goto st33
st33:
	p++
	if p == pe { goto _test_eof33 }
	fallthrough
case 33:
// line 4005 "zparse.go"
	switch data[p] {
		case 78: goto st34
		case 83: goto st51
		case 110: goto st34
		case 115: goto st51
	}
	goto st0
st34:
	p++
	if p == pe { goto _test_eof34 }
	fallthrough
case 34:
	switch data[p] {
		case 83: goto st35
		case 115: goto st35
	}
	goto st0
st35:
	p++
	if p == pe { goto _test_eof35 }
	fallthrough
case 35:
	switch data[p] {
		case 75: goto st36
		case 107: goto st36
	}
	goto st0
st36:
	p++
	if p == pe { goto _test_eof36 }
	fallthrough
case 36:
	switch data[p] {
		case 69: goto st37
		case 101: goto st37
	}
	goto st0
st37:
	p++
	if p == pe { goto _test_eof37 }
	fallthrough
case 37:
	switch data[p] {
		case 89: goto st38
		case 121: goto st38
	}
	goto st0
st38:
	p++
	if p == pe { goto _test_eof38 }
	fallthrough
case 38:
	switch data[p] {
		case 9: goto tr135
		case 10: goto tr136
		case 32: goto tr135
		case 40: goto tr137
		case 41: goto tr138
		case 59: goto tr139
	}
	goto st0
tr142:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st39
tr143:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st39
tr141:
// line 101 "zparse.rl"
	{ lines++ }
	goto st39
tr135:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st39
tr136:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
	goto st39
tr137:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st39
tr138:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st39
st39:
	p++
	if p == pe { goto _test_eof39 }
	fallthrough
case 39:
// line 4142 "zparse.go"
	switch data[p] {
		case 9: goto st39
		case 10: goto tr141
		case 32: goto st39
		case 40: goto tr142
		case 41: goto tr143
		case 59: goto st50
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr144 }
	goto st0
tr144:
// line 89 "zparse.rl"
	{ mark = p }
	goto st40
st40:
	p++
	if p == pe { goto _test_eof40 }
	fallthrough
case 40:
// line 4162 "zparse.go"
	switch data[p] {
		case 9: goto tr146
		case 10: goto tr147
		case 32: goto tr146
		case 40: goto tr148
		case 41: goto tr149
		case 59: goto tr151
	}
	if 48 <= data[p] && data[p] <= 57 { goto st40 }
	goto st0
tr154:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st41
tr155:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st41
tr153:
// line 101 "zparse.rl"
	{ lines++ }
	goto st41
tr146:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st41
tr147:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st41
tr148:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st41
tr149:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st41
st41:
	p++
	if p == pe { goto _test_eof41 }
	fallthrough
case 41:
// line 4212 "zparse.go"
	switch data[p] {
		case 9: goto st41
		case 10: goto tr153
		case 32: goto st41
		case 40: goto tr154
		case 41: goto tr155
		case 59: goto st49
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr156 }
	goto st0
tr156:
// line 89 "zparse.rl"
	{ mark = p }
	goto st42
st42:
	p++
	if p == pe { goto _test_eof42 }
	fallthrough
case 42:
// line 4232 "zparse.go"
	switch data[p] {
		case 9: goto tr158
		case 10: goto tr159
		case 32: goto tr158
		case 40: goto tr160
		case 41: goto tr161
		case 59: goto tr163
	}
	if 48 <= data[p] && data[p] <= 57 { goto st42 }
	goto st0
tr166:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st43
tr167:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st43
tr165:
// line 101 "zparse.rl"
	{ lines++ }
	goto st43
tr158:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st43
tr159:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st43
tr160:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st43
tr161:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st43
st43:
	p++
	if p == pe { goto _test_eof43 }
	fallthrough
case 43:
// line 4282 "zparse.go"
	switch data[p] {
		case 9: goto st43
		case 10: goto tr165
		case 32: goto st43
		case 40: goto tr166
		case 41: goto tr167
		case 59: goto st48
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr168 }
	goto st0
tr168:
// line 89 "zparse.rl"
	{ mark = p }
	goto st44
st44:
	p++
	if p == pe { goto _test_eof44 }
	fallthrough
case 44:
// line 4302 "zparse.go"
	switch data[p] {
		case 9: goto tr170
		case 10: goto tr171
		case 32: goto tr170
		case 40: goto tr172
		case 41: goto tr173
		case 59: goto tr175
	}
	if 48 <= data[p] && data[p] <= 57 { goto st44 }
	goto st0
tr178:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st45
tr179:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st45
tr177:
// line 101 "zparse.rl"
	{ lines++ }
	goto st45
tr170:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st45
tr171:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st45
tr172:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st45
tr173:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st45
st45:
	p++
	if p == pe { goto _test_eof45 }
	fallthrough
case 45:
// line 4352 "zparse.go"
	switch data[p] {
		case 9: goto st45
		case 10: goto tr177
		case 32: goto st45
		case 40: goto tr178
		case 41: goto tr179
		case 43: goto tr180
		case 59: goto st47
		case 61: goto tr180
		case 92: goto tr180
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr180 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr180 }
	} else {
		goto tr180
	}
	goto st0
tr180:
// line 89 "zparse.rl"
	{ mark = p }
	goto st46
st46:
	p++
	if p == pe { goto _test_eof46 }
	fallthrough
case 46:
// line 4381 "zparse.go"
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 92: goto st46
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
tr175:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st47
st47:
	p++
	if p == pe { goto _test_eof47 }
	fallthrough
case 47:
// line 4410 "zparse.go"
	if data[p] == 10 { goto tr177 }
	goto st47
tr163:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st48
st48:
	p++
	if p == pe { goto _test_eof48 }
	fallthrough
case 48:
// line 4422 "zparse.go"
	if data[p] == 10 { goto tr165 }
	goto st48
tr151:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st49
st49:
	p++
	if p == pe { goto _test_eof49 }
	fallthrough
case 49:
// line 4434 "zparse.go"
	if data[p] == 10 { goto tr153 }
	goto st49
tr139:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st50
st50:
	p++
	if p == pe { goto _test_eof50 }
	fallthrough
case 50:
// line 4455 "zparse.go"
	if data[p] == 10 { goto tr141 }
	goto st50
st51:
	p++
	if p == pe { goto _test_eof51 }
	fallthrough
case 51:
	switch data[p] {
		case 9: goto tr188
		case 10: goto tr189
		case 32: goto tr188
		case 40: goto tr190
		case 41: goto tr191
		case 59: goto tr192
	}
	goto st0
tr195:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st52
tr196:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st52
tr194:
// line 101 "zparse.rl"
	{ lines++ }
	goto st52
tr188:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st52
tr189:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
	goto st52
tr190:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st52
tr191:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st52
st52:
	p++
	if p == pe { goto _test_eof52 }
	fallthrough
case 52:
// line 4547 "zparse.go"
	switch data[p] {
		case 9: goto st52
		case 10: goto tr194
		case 32: goto st52
		case 40: goto tr195
		case 41: goto tr196
		case 59: goto st63
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr197 }
	goto st0
tr197:
// line 89 "zparse.rl"
	{ mark = p }
	goto st53
st53:
	p++
	if p == pe { goto _test_eof53 }
	fallthrough
case 53:
// line 4567 "zparse.go"
	switch data[p] {
		case 9: goto tr199
		case 10: goto tr200
		case 32: goto tr199
		case 40: goto tr201
		case 41: goto tr202
		case 59: goto tr204
	}
	if 48 <= data[p] && data[p] <= 57 { goto st53 }
	goto st0
tr207:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st54
tr208:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st54
tr206:
// line 101 "zparse.rl"
	{ lines++ }
	goto st54
tr199:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st54
tr200:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st54
tr201:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st54
tr202:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st54
st54:
	p++
	if p == pe { goto _test_eof54 }
	fallthrough
case 54:
// line 4617 "zparse.go"
	switch data[p] {
		case 9: goto st54
		case 10: goto tr206
		case 32: goto st54
		case 40: goto tr207
		case 41: goto tr208
		case 59: goto st62
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr209 }
	goto st0
tr209:
// line 89 "zparse.rl"
	{ mark = p }
	goto st55
st55:
	p++
	if p == pe { goto _test_eof55 }
	fallthrough
case 55:
// line 4637 "zparse.go"
	switch data[p] {
		case 9: goto tr211
		case 10: goto tr212
		case 32: goto tr211
		case 40: goto tr213
		case 41: goto tr214
		case 59: goto tr216
	}
	if 48 <= data[p] && data[p] <= 57 { goto st55 }
	goto st0
tr219:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st56
tr220:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st56
tr218:
// line 101 "zparse.rl"
	{ lines++ }
	goto st56
tr211:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st56
tr212:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st56
tr213:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st56
tr214:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st56
st56:
	p++
	if p == pe { goto _test_eof56 }
	fallthrough
case 56:
// line 4687 "zparse.go"
	switch data[p] {
		case 9: goto st56
		case 10: goto tr218
		case 32: goto st56
		case 40: goto tr219
		case 41: goto tr220
		case 59: goto st61
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr221 }
	goto st0
tr221:
// line 89 "zparse.rl"
	{ mark = p }
	goto st57
st57:
	p++
	if p == pe { goto _test_eof57 }
	fallthrough
case 57:
// line 4707 "zparse.go"
	switch data[p] {
		case 9: goto tr223
		case 10: goto tr224
		case 32: goto tr223
		case 40: goto tr225
		case 41: goto tr226
		case 59: goto tr228
	}
	if 48 <= data[p] && data[p] <= 57 { goto st57 }
	goto st0
tr231:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st58
tr232:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st58
tr230:
// line 101 "zparse.rl"
	{ lines++ }
	goto st58
tr223:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st58
tr224:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st58
tr225:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st58
tr226:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st58
st58:
	p++
	if p == pe { goto _test_eof58 }
	fallthrough
case 58:
// line 4757 "zparse.go"
	switch data[p] {
		case 9: goto st58
		case 10: goto tr230
		case 32: goto st58
		case 40: goto tr231
		case 41: goto tr232
		case 43: goto tr233
		case 59: goto st60
		case 61: goto tr233
		case 92: goto tr233
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr233 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr233 }
	} else {
		goto tr233
	}
	goto st0
tr233:
// line 89 "zparse.rl"
	{ mark = p }
	goto st59
st59:
	p++
	if p == pe { goto _test_eof59 }
	fallthrough
case 59:
// line 4786 "zparse.go"
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 92: goto st59
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
tr228:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st60
st60:
	p++
	if p == pe { goto _test_eof60 }
	fallthrough
case 60:
// line 4815 "zparse.go"
	if data[p] == 10 { goto tr230 }
	goto st60
tr216:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st61
st61:
	p++
	if p == pe { goto _test_eof61 }
	fallthrough
case 61:
// line 4827 "zparse.go"
	if data[p] == 10 { goto tr218 }
	goto st61
tr204:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st62
st62:
	p++
	if p == pe { goto _test_eof62 }
	fallthrough
case 62:
// line 4839 "zparse.go"
	if data[p] == 10 { goto tr206 }
	goto st62
tr192:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st63
st63:
	p++
	if p == pe { goto _test_eof63 }
	fallthrough
case 63:
// line 4860 "zparse.go"
	if data[p] == 10 { goto tr194 }
	goto st63
tr12:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st64
tr43:
// line 89 "zparse.rl"
	{ mark = p }
	goto st64
st64:
	p++
	if p == pe { goto _test_eof64 }
	fallthrough
case 64:
// line 4878 "zparse.go"
	switch data[p] {
		case 88: goto st65
		case 120: goto st65
	}
	goto st0
st65:
	p++
	if p == pe { goto _test_eof65 }
	fallthrough
case 65:
	switch data[p] {
		case 9: goto tr242
		case 10: goto tr243
		case 32: goto tr242
		case 40: goto tr244
		case 41: goto tr245
		case 59: goto tr246
	}
	goto st0
tr249:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st66
tr250:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st66
tr248:
// line 101 "zparse.rl"
	{ lines++ }
	goto st66
tr242:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st66
tr243:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
	goto st66
tr244:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st66
tr245:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st66
st66:
	p++
	if p == pe { goto _test_eof66 }
	fallthrough
case 66:
// line 4973 "zparse.go"
	switch data[p] {
		case 9: goto st66
		case 10: goto tr248
		case 32: goto st66
		case 40: goto tr249
		case 41: goto tr250
		case 59: goto st71
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr251 }
	goto st0
tr251:
// line 89 "zparse.rl"
	{ mark = p }
	goto st67
st67:
	p++
	if p == pe { goto _test_eof67 }
	fallthrough
case 67:
// line 4993 "zparse.go"
	switch data[p] {
		case 9: goto tr253
		case 10: goto tr254
		case 32: goto tr253
		case 40: goto tr255
		case 41: goto tr256
		case 59: goto tr258
	}
	if 48 <= data[p] && data[p] <= 57 { goto st67 }
	goto st0
tr261:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st68
tr262:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st68
tr260:
// line 101 "zparse.rl"
	{ lines++ }
	goto st68
tr253:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st68
tr254:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st68
tr255:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st68
tr256:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st68
st68:
	p++
	if p == pe { goto _test_eof68 }
	fallthrough
case 68:
// line 5043 "zparse.go"
	switch data[p] {
		case 9: goto st68
		case 10: goto tr260
		case 32: goto st68
		case 40: goto tr261
		case 41: goto tr262
		case 43: goto tr263
		case 59: goto st70
		case 61: goto tr263
		case 92: goto tr263
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr263 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr263 }
	} else {
		goto tr263
	}
	goto st0
tr263:
// line 89 "zparse.rl"
	{ mark = p }
	goto st69
st69:
	p++
	if p == pe { goto _test_eof69 }
	fallthrough
case 69:
// line 5072 "zparse.go"
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 92: goto st69
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr258:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st70
st70:
	p++
	if p == pe { goto _test_eof70 }
	fallthrough
case 70:
// line 5101 "zparse.go"
	if data[p] == 10 { goto tr260 }
	goto st70
tr246:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st71
st71:
	p++
	if p == pe { goto _test_eof71 }
	fallthrough
case 71:
// line 5122 "zparse.go"
	if data[p] == 10 { goto tr248 }
	goto st71
tr107:
// line 89 "zparse.rl"
	{ mark = p }
	goto st72
st72:
	p++
	if p == pe { goto _test_eof72 }
	fallthrough
case 72:
// line 5134 "zparse.go"
	switch data[p] {
		case 83: goto st73
		case 115: goto st73
	}
	goto st0
st73:
	p++
	if p == pe { goto _test_eof73 }
	fallthrough
case 73:
	switch data[p] {
		case 9: goto tr272
		case 10: goto tr273
		case 32: goto tr272
		case 40: goto tr274
		case 41: goto tr275
		case 59: goto tr276
	}
	goto st0
tr279:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st74
tr280:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st74
tr278:
// line 101 "zparse.rl"
	{ lines++ }
	goto st74
tr272:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st74
tr273:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
	goto st74
tr274:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st74
tr275:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st74
st74:
	p++
	if p == pe { goto _test_eof74 }
	fallthrough
case 74:
// line 5229 "zparse.go"
	switch data[p] {
		case 9: goto st74
		case 10: goto tr278
		case 32: goto st74
		case 40: goto tr279
		case 41: goto tr280
		case 43: goto tr281
		case 59: goto st76
		case 61: goto tr281
		case 92: goto tr281
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr281 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr281 }
	} else {
		goto tr281
	}
	goto st0
tr281:
// line 89 "zparse.rl"
	{ mark = p }
	goto st75
st75:
	p++
	if p == pe { goto _test_eof75 }
	fallthrough
case 75:
// line 5258 "zparse.go"
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 92: goto st75
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
tr276:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st76
st76:
	p++
	if p == pe { goto _test_eof76 }
	fallthrough
case 76:
// line 5296 "zparse.go"
	if data[p] == 10 { goto tr278 }
	goto st76
tr14:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st77
tr45:
// line 89 "zparse.rl"
	{ mark = p }
	goto st77
st77:
	p++
	if p == pe { goto _test_eof77 }
	fallthrough
case 77:
// line 5314 "zparse.go"
	switch data[p] {
		case 82: goto st78
		case 114: goto st78
	}
	goto st0
st78:
	p++
	if p == pe { goto _test_eof78 }
	fallthrough
case 78:
	switch data[p] {
		case 83: goto st79
		case 115: goto st79
	}
	goto st0
st79:
	p++
	if p == pe { goto _test_eof79 }
	fallthrough
case 79:
	switch data[p] {
		case 73: goto st80
		case 105: goto st80
	}
	goto st0
st80:
	p++
	if p == pe { goto _test_eof80 }
	fallthrough
case 80:
	switch data[p] {
		case 71: goto st81
		case 103: goto st81
	}
	goto st0
st81:
	p++
	if p == pe { goto _test_eof81 }
	fallthrough
case 81:
	switch data[p] {
		case 9: goto tr293
		case 10: goto tr294
		case 32: goto tr293
		case 40: goto tr295
		case 41: goto tr296
		case 59: goto tr297
	}
	goto st0
tr300:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st82
tr301:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st82
tr299:
// line 101 "zparse.rl"
	{ lines++ }
	goto st82
tr293:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st82
tr294:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
	goto st82
tr295:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st82
tr296:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st82
st82:
	p++
	if p == pe { goto _test_eof82 }
	fallthrough
case 82:
// line 5439 "zparse.go"
	switch data[p] {
		case 9: goto st82
		case 10: goto tr299
		case 32: goto st82
		case 40: goto tr300
		case 41: goto tr301
		case 59: goto st108
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr302 }
	goto st0
tr302:
// line 89 "zparse.rl"
	{ mark = p }
	goto st83
st83:
	p++
	if p == pe { goto _test_eof83 }
	fallthrough
case 83:
// line 5459 "zparse.go"
	switch data[p] {
		case 9: goto tr304
		case 10: goto tr305
		case 32: goto tr304
		case 40: goto tr306
		case 41: goto tr307
		case 59: goto tr309
	}
	if 48 <= data[p] && data[p] <= 57 { goto st83 }
	goto st0
tr312:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st84
tr313:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st84
tr311:
// line 101 "zparse.rl"
	{ lines++ }
	goto st84
tr304:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st84
tr305:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st84
tr306:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st84
tr307:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st84
st84:
	p++
	if p == pe { goto _test_eof84 }
	fallthrough
case 84:
// line 5509 "zparse.go"
	switch data[p] {
		case 9: goto st84
		case 10: goto tr311
		case 32: goto st84
		case 40: goto tr312
		case 41: goto tr313
		case 59: goto st107
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr314 }
	goto st0
tr314:
// line 89 "zparse.rl"
	{ mark = p }
	goto st85
st85:
	p++
	if p == pe { goto _test_eof85 }
	fallthrough
case 85:
// line 5529 "zparse.go"
	switch data[p] {
		case 9: goto tr316
		case 10: goto tr317
		case 32: goto tr316
		case 40: goto tr318
		case 41: goto tr319
		case 59: goto tr321
	}
	if 48 <= data[p] && data[p] <= 57 { goto st85 }
	goto st0
tr324:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st86
tr325:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st86
tr323:
// line 101 "zparse.rl"
	{ lines++ }
	goto st86
tr316:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st86
tr317:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st86
tr318:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st86
tr319:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st86
st86:
	p++
	if p == pe { goto _test_eof86 }
	fallthrough
case 86:
// line 5579 "zparse.go"
	switch data[p] {
		case 9: goto st86
		case 10: goto tr323
		case 32: goto st86
		case 40: goto tr324
		case 41: goto tr325
		case 59: goto st106
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr326 }
	goto st0
tr326:
// line 89 "zparse.rl"
	{ mark = p }
	goto st87
st87:
	p++
	if p == pe { goto _test_eof87 }
	fallthrough
case 87:
// line 5599 "zparse.go"
	switch data[p] {
		case 9: goto tr328
		case 10: goto tr329
		case 32: goto tr328
		case 40: goto tr330
		case 41: goto tr331
		case 59: goto tr333
	}
	if 48 <= data[p] && data[p] <= 57 { goto st87 }
	goto st0
tr336:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st88
tr337:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st88
tr335:
// line 101 "zparse.rl"
	{ lines++ }
	goto st88
tr328:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st88
tr329:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st88
tr330:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st88
tr331:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st88
st88:
	p++
	if p == pe { goto _test_eof88 }
	fallthrough
case 88:
// line 5649 "zparse.go"
	switch data[p] {
		case 9: goto st88
		case 10: goto tr335
		case 32: goto st88
		case 40: goto tr336
		case 41: goto tr337
		case 59: goto st105
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr338 }
	goto st0
tr338:
// line 89 "zparse.rl"
	{ mark = p }
	goto st89
st89:
	p++
	if p == pe { goto _test_eof89 }
	fallthrough
case 89:
// line 5669 "zparse.go"
	switch data[p] {
		case 9: goto tr340
		case 10: goto tr341
		case 32: goto tr340
		case 40: goto tr342
		case 41: goto tr343
		case 59: goto tr345
	}
	if 48 <= data[p] && data[p] <= 57 { goto st89 }
	goto st0
tr348:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st90
tr349:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st90
tr347:
// line 101 "zparse.rl"
	{ lines++ }
	goto st90
tr340:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st90
tr341:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st90
tr342:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st90
tr343:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st90
st90:
	p++
	if p == pe { goto _test_eof90 }
	fallthrough
case 90:
// line 5719 "zparse.go"
	switch data[p] {
		case 9: goto st90
		case 10: goto tr347
		case 32: goto st90
		case 40: goto tr348
		case 41: goto tr349
		case 59: goto st104
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr350 }
	goto st0
tr350:
// line 89 "zparse.rl"
	{ mark = p }
	goto st91
st91:
	p++
	if p == pe { goto _test_eof91 }
	fallthrough
case 91:
// line 5739 "zparse.go"
	switch data[p] {
		case 9: goto tr352
		case 10: goto tr353
		case 32: goto tr352
		case 40: goto tr354
		case 41: goto tr355
		case 59: goto tr357
	}
	if 48 <= data[p] && data[p] <= 57 { goto st91 }
	goto st0
tr360:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st92
tr361:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st92
tr359:
// line 101 "zparse.rl"
	{ lines++ }
	goto st92
tr352:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st92
tr353:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st92
tr354:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st92
tr355:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st92
st92:
	p++
	if p == pe { goto _test_eof92 }
	fallthrough
case 92:
// line 5789 "zparse.go"
	switch data[p] {
		case 9: goto st92
		case 10: goto tr359
		case 32: goto st92
		case 40: goto tr360
		case 41: goto tr361
		case 59: goto st103
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr362 }
	goto st0
tr362:
// line 89 "zparse.rl"
	{ mark = p }
	goto st93
st93:
	p++
	if p == pe { goto _test_eof93 }
	fallthrough
case 93:
// line 5809 "zparse.go"
	switch data[p] {
		case 9: goto tr364
		case 10: goto tr365
		case 32: goto tr364
		case 40: goto tr366
		case 41: goto tr367
		case 59: goto tr369
	}
	if 48 <= data[p] && data[p] <= 57 { goto st93 }
	goto st0
tr372:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st94
tr373:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st94
tr371:
// line 101 "zparse.rl"
	{ lines++ }
	goto st94
tr364:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st94
tr365:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st94
tr366:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st94
tr367:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st94
st94:
	p++
	if p == pe { goto _test_eof94 }
	fallthrough
case 94:
// line 5859 "zparse.go"
	switch data[p] {
		case 9: goto st94
		case 10: goto tr371
		case 32: goto st94
		case 40: goto tr372
		case 41: goto tr373
		case 59: goto st102
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr374 }
	goto st0
tr374:
// line 89 "zparse.rl"
	{ mark = p }
	goto st95
st95:
	p++
	if p == pe { goto _test_eof95 }
	fallthrough
case 95:
// line 5879 "zparse.go"
	switch data[p] {
		case 9: goto tr376
		case 10: goto tr377
		case 32: goto tr376
		case 40: goto tr378
		case 41: goto tr379
		case 59: goto tr381
	}
	if 48 <= data[p] && data[p] <= 57 { goto st95 }
	goto st0
tr384:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st96
tr385:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st96
tr383:
// line 101 "zparse.rl"
	{ lines++ }
	goto st96
tr376:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st96
tr377:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st96
tr378:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st96
tr379:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st96
st96:
	p++
	if p == pe { goto _test_eof96 }
	fallthrough
case 96:
// line 5929 "zparse.go"
	switch data[p] {
		case 9: goto st96
		case 10: goto tr383
		case 32: goto st96
		case 40: goto tr384
		case 41: goto tr385
		case 43: goto tr386
		case 59: goto st101
		case 61: goto tr386
		case 92: goto tr386
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr386 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr386 }
	} else {
		goto tr386
	}
	goto st0
tr386:
// line 89 "zparse.rl"
	{ mark = p }
	goto st97
st97:
	p++
	if p == pe { goto _test_eof97 }
	fallthrough
case 97:
// line 5958 "zparse.go"
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 92: goto st97
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr396:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st98
tr397:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st98
tr395:
// line 101 "zparse.rl"
	{ lines++ }
	goto st98
tr388:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st98
tr389:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st98
tr390:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st98
tr391:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st98
st98:
	p++
	if p == pe { goto _test_eof98 }
	fallthrough
case 98:
// line 6017 "zparse.go"
	switch data[p] {
		case 9: goto st98
		case 10: goto tr395
		case 32: goto st98
		case 40: goto tr396
		case 41: goto tr397
		case 43: goto tr398
		case 59: goto st100
		case 61: goto tr398
		case 92: goto tr398
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr398 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr398 }
	} else {
		goto tr398
	}
	goto st0
tr398:
// line 89 "zparse.rl"
	{ mark = p }
	goto st99
st99:
	p++
	if p == pe { goto _test_eof99 }
	fallthrough
case 99:
// line 6046 "zparse.go"
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 92: goto st99
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
tr393:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st100
st100:
	p++
	if p == pe { goto _test_eof100 }
	fallthrough
case 100:
// line 6075 "zparse.go"
	if data[p] == 10 { goto tr395 }
	goto st100
tr381:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st101
st101:
	p++
	if p == pe { goto _test_eof101 }
	fallthrough
case 101:
// line 6087 "zparse.go"
	if data[p] == 10 { goto tr383 }
	goto st101
tr369:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st102
st102:
	p++
	if p == pe { goto _test_eof102 }
	fallthrough
case 102:
// line 6099 "zparse.go"
	if data[p] == 10 { goto tr371 }
	goto st102
tr357:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st103
st103:
	p++
	if p == pe { goto _test_eof103 }
	fallthrough
case 103:
// line 6111 "zparse.go"
	if data[p] == 10 { goto tr359 }
	goto st103
tr345:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st104
st104:
	p++
	if p == pe { goto _test_eof104 }
	fallthrough
case 104:
// line 6123 "zparse.go"
	if data[p] == 10 { goto tr347 }
	goto st104
tr333:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st105
st105:
	p++
	if p == pe { goto _test_eof105 }
	fallthrough
case 105:
// line 6135 "zparse.go"
	if data[p] == 10 { goto tr335 }
	goto st105
tr321:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st106
st106:
	p++
	if p == pe { goto _test_eof106 }
	fallthrough
case 106:
// line 6147 "zparse.go"
	if data[p] == 10 { goto tr323 }
	goto st106
tr309:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st107
st107:
	p++
	if p == pe { goto _test_eof107 }
	fallthrough
case 107:
// line 6159 "zparse.go"
	if data[p] == 10 { goto tr311 }
	goto st107
tr297:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st108
st108:
	p++
	if p == pe { goto _test_eof108 }
	fallthrough
case 108:
// line 6180 "zparse.go"
	if data[p] == 10 { goto tr299 }
	goto st108
tr15:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st109
tr46:
// line 89 "zparse.rl"
	{ mark = p }
	goto st109
st109:
	p++
	if p == pe { goto _test_eof109 }
	fallthrough
case 109:
// line 6198 "zparse.go"
	switch data[p] {
		case 79: goto st110
		case 111: goto st110
	}
	goto st0
st110:
	p++
	if p == pe { goto _test_eof110 }
	fallthrough
case 110:
	switch data[p] {
		case 65: goto st111
		case 97: goto st111
	}
	goto st0
st111:
	p++
	if p == pe { goto _test_eof111 }
	fallthrough
case 111:
	switch data[p] {
		case 9: goto tr408
		case 10: goto tr409
		case 32: goto tr408
		case 40: goto tr410
		case 41: goto tr411
		case 59: goto tr412
	}
	goto st0
tr415:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st112
tr416:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st112
tr414:
// line 101 "zparse.rl"
	{ lines++ }
	goto st112
tr408:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st112
tr409:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
	goto st112
tr410:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st112
tr411:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st112
st112:
	p++
	if p == pe { goto _test_eof112 }
	fallthrough
case 112:
// line 6303 "zparse.go"
	switch data[p] {
		case 9: goto st112
		case 10: goto tr414
		case 32: goto st112
		case 40: goto tr415
		case 41: goto tr416
		case 43: goto tr417
		case 59: goto st132
		case 61: goto tr417
		case 92: goto tr417
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr417 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr417 }
	} else {
		goto tr417
	}
	goto st0
tr417:
// line 89 "zparse.rl"
	{ mark = p }
	goto st113
st113:
	p++
	if p == pe { goto _test_eof113 }
	fallthrough
case 113:
// line 6332 "zparse.go"
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 92: goto st113
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
tr427:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st114
tr428:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st114
tr426:
// line 101 "zparse.rl"
	{ lines++ }
	goto st114
tr419:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st114
tr420:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st114
tr421:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st114
tr422:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st114
st114:
	p++
	if p == pe { goto _test_eof114 }
	fallthrough
case 114:
// line 6391 "zparse.go"
	switch data[p] {
		case 9: goto st114
		case 10: goto tr426
		case 32: goto st114
		case 40: goto tr427
		case 41: goto tr428
		case 43: goto tr429
		case 59: goto st131
		case 61: goto tr429
		case 92: goto tr429
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr429 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr429 }
	} else {
		goto tr429
	}
	goto st0
tr429:
// line 89 "zparse.rl"
	{ mark = p }
	goto st115
st115:
	p++
	if p == pe { goto _test_eof115 }
	fallthrough
case 115:
// line 6420 "zparse.go"
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr439:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st116
tr440:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st116
tr438:
// line 101 "zparse.rl"
	{ lines++ }
	goto st116
tr431:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st116
tr432:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st116
tr433:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st116
tr434:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st116
st116:
	p++
	if p == pe { goto _test_eof116 }
	fallthrough
case 116:
// line 6479 "zparse.go"
	switch data[p] {
		case 9: goto st116
		case 10: goto tr438
		case 32: goto st116
		case 40: goto tr439
		case 41: goto tr440
		case 59: goto st130
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr441 }
	goto st0
tr441:
// line 89 "zparse.rl"
	{ mark = p }
	goto st117
st117:
	p++
	if p == pe { goto _test_eof117 }
	fallthrough
case 117:
// line 6499 "zparse.go"
	switch data[p] {
		case 9: goto tr443
		case 10: goto tr444
		case 32: goto tr443
		case 40: goto tr445
		case 41: goto tr446
		case 59: goto tr448
	}
	if 48 <= data[p] && data[p] <= 57 { goto st117 }
	goto st0
tr451:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st118
tr452:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st118
tr450:
// line 101 "zparse.rl"
	{ lines++ }
	goto st118
tr443:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st118
tr444:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st118
tr445:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st118
tr446:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st118
st118:
	p++
	if p == pe { goto _test_eof118 }
	fallthrough
case 118:
// line 6549 "zparse.go"
	switch data[p] {
		case 9: goto st118
		case 10: goto tr450
		case 32: goto st118
		case 40: goto tr451
		case 41: goto tr452
		case 59: goto st129
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr453 }
	goto st0
tr453:
// line 89 "zparse.rl"
	{ mark = p }
	goto st119
st119:
	p++
	if p == pe { goto _test_eof119 }
	fallthrough
case 119:
// line 6569 "zparse.go"
	switch data[p] {
		case 9: goto tr455
		case 10: goto tr456
		case 32: goto tr455
		case 40: goto tr457
		case 41: goto tr458
		case 59: goto tr460
	}
	if 48 <= data[p] && data[p] <= 57 { goto st119 }
	goto st0
tr463:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st120
tr464:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st120
tr462:
// line 101 "zparse.rl"
	{ lines++ }
	goto st120
tr455:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st120
tr456:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st120
tr457:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st120
tr458:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st120
st120:
	p++
	if p == pe { goto _test_eof120 }
	fallthrough
case 120:
// line 6619 "zparse.go"
	switch data[p] {
		case 9: goto st120
		case 10: goto tr462
		case 32: goto st120
		case 40: goto tr463
		case 41: goto tr464
		case 59: goto st128
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr465 }
	goto st0
tr465:
// line 89 "zparse.rl"
	{ mark = p }
	goto st121
st121:
	p++
	if p == pe { goto _test_eof121 }
	fallthrough
case 121:
// line 6639 "zparse.go"
	switch data[p] {
		case 9: goto tr467
		case 10: goto tr468
		case 32: goto tr467
		case 40: goto tr469
		case 41: goto tr470
		case 59: goto tr472
	}
	if 48 <= data[p] && data[p] <= 57 { goto st121 }
	goto st0
tr475:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st122
tr476:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st122
tr474:
// line 101 "zparse.rl"
	{ lines++ }
	goto st122
tr467:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st122
tr468:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st122
tr469:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st122
tr470:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st122
st122:
	p++
	if p == pe { goto _test_eof122 }
	fallthrough
case 122:
// line 6689 "zparse.go"
	switch data[p] {
		case 9: goto st122
		case 10: goto tr474
		case 32: goto st122
		case 40: goto tr475
		case 41: goto tr476
		case 59: goto st127
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr477 }
	goto st0
tr477:
// line 89 "zparse.rl"
	{ mark = p }
	goto st123
st123:
	p++
	if p == pe { goto _test_eof123 }
	fallthrough
case 123:
// line 6709 "zparse.go"
	switch data[p] {
		case 9: goto tr479
		case 10: goto tr480
		case 32: goto tr479
		case 40: goto tr481
		case 41: goto tr482
		case 59: goto tr484
	}
	if 48 <= data[p] && data[p] <= 57 { goto st123 }
	goto st0
tr487:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st124
tr488:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st124
tr486:
// line 101 "zparse.rl"
	{ lines++ }
	goto st124
tr479:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st124
tr480:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st124
tr481:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st124
tr482:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st124
st124:
	p++
	if p == pe { goto _test_eof124 }
	fallthrough
case 124:
// line 6759 "zparse.go"
	switch data[p] {
		case 9: goto st124
		case 10: goto tr486
		case 32: goto st124
		case 40: goto tr487
		case 41: goto tr488
		case 59: goto st126
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr489 }
	goto st0
tr489:
// line 89 "zparse.rl"
	{ mark = p }
	goto st125
st125:
	p++
	if p == pe { goto _test_eof125 }
	fallthrough
case 125:
// line 6779 "zparse.go"
	switch data[p] {
		case 9: goto tr491
		case 10: goto tr492
		case 32: goto tr491
		case 40: goto tr493
		case 41: goto tr494
		case 59: goto tr496
	}
	if 48 <= data[p] && data[p] <= 57 { goto st125 }
	goto st0
tr484:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st126
st126:
	p++
	if p == pe { goto _test_eof126 }
	fallthrough
case 126:
// line 6799 "zparse.go"
	if data[p] == 10 { goto tr486 }
	goto st126
tr472:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st127
st127:
	p++
	if p == pe { goto _test_eof127 }
	fallthrough
case 127:
// line 6811 "zparse.go"
	if data[p] == 10 { goto tr474 }
	goto st127
tr460:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st128
st128:
	p++
	if p == pe { goto _test_eof128 }
	fallthrough
case 128:
// line 6823 "zparse.go"
	if data[p] == 10 { goto tr462 }
	goto st128
tr448:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st129
st129:
	p++
	if p == pe { goto _test_eof129 }
	fallthrough
case 129:
// line 6835 "zparse.go"
	if data[p] == 10 { goto tr450 }
	goto st129
tr436:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st130
st130:
	p++
	if p == pe { goto _test_eof130 }
	fallthrough
case 130:
// line 6847 "zparse.go"
	if data[p] == 10 { goto tr438 }
	goto st130
tr424:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st131
st131:
	p++
	if p == pe { goto _test_eof131 }
	fallthrough
case 131:
// line 6859 "zparse.go"
	if data[p] == 10 { goto tr426 }
	goto st131
tr412:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st132
st132:
	p++
	if p == pe { goto _test_eof132 }
	fallthrough
case 132:
// line 6880 "zparse.go"
	if data[p] == 10 { goto tr414 }
	goto st132
tr39:
// line 89 "zparse.rl"
	{ mark = p }
	goto st133
st133:
	p++
	if p == pe { goto _test_eof133 }
	fallthrough
case 133:
// line 6892 "zparse.go"
	switch data[p] {
		case 72: goto st21
		case 78: goto st26
		case 83: goto st21
		case 104: goto st21
		case 110: goto st26
		case 115: goto st21
	}
	goto st0
tr41:
// line 89 "zparse.rl"
	{ mark = p }
	goto st134
st134:
	p++
	if p == pe { goto _test_eof134 }
	fallthrough
case 134:
// line 6911 "zparse.go"
	switch data[p] {
		case 83: goto st21
		case 115: goto st21
	}
	goto st0
tr42:
// line 89 "zparse.rl"
	{ mark = p }
	goto st135
st135:
	p++
	if p == pe { goto _test_eof135 }
	fallthrough
case 135:
// line 6926 "zparse.go"
	switch data[p] {
		case 78: goto st21
		case 110: goto st21
	}
	goto st0
tr44:
// line 89 "zparse.rl"
	{ mark = p }
	goto st136
st136:
	p++
	if p == pe { goto _test_eof136 }
	fallthrough
case 136:
// line 6941 "zparse.go"
	switch data[p] {
		case 79: goto st137
		case 83: goto st73
		case 111: goto st137
		case 115: goto st73
	}
	goto st0
st137:
	p++
	if p == pe { goto _test_eof137 }
	fallthrough
case 137:
	switch data[p] {
		case 78: goto st138
		case 110: goto st138
	}
	goto st0
st138:
	p++
	if p == pe { goto _test_eof138 }
	fallthrough
case 138:
	switch data[p] {
		case 69: goto st21
		case 101: goto st21
	}
	goto st0
tr21:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
	goto st139
tr525:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
	goto st139
tr565:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
	goto st139
st139:
	p++
	if p == pe { goto _test_eof139 }
	fallthrough
case 139:
// line 6990 "zparse.go"
	if data[p] == 10 { goto tr23 }
	goto st139
tr7:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st140
st140:
	p++
	if p == pe { goto _test_eof140 }
	fallthrough
case 140:
// line 7004 "zparse.go"
	switch data[p] {
		case 9: goto tr47
		case 10: goto tr48
		case 32: goto tr47
		case 40: goto tr49
		case 41: goto tr50
		case 59: goto tr51
		case 65: goto st14
		case 78: goto st141
		case 97: goto st14
		case 110: goto st141
	}
	goto st0
st141:
	p++
	if p == pe { goto _test_eof141 }
	fallthrough
case 141:
	switch data[p] {
		case 89: goto st142
		case 121: goto st142
	}
	goto st0
st142:
	p++
	if p == pe { goto _test_eof142 }
	fallthrough
case 142:
	switch data[p] {
		case 9: goto tr501
		case 10: goto tr502
		case 32: goto tr501
		case 40: goto tr503
		case 41: goto tr504
		case 59: goto tr505
	}
	goto st0
tr508:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st143
tr509:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st143
tr507:
// line 101 "zparse.rl"
	{ lines++ }
	goto st143
tr501:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
	goto st143
tr502:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
	goto st143
tr503:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st143
tr504:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st143
st143:
	p++
	if p == pe { goto _test_eof143 }
	fallthrough
case 143:
// line 7081 "zparse.go"
	switch data[p] {
		case 9: goto st143
		case 10: goto tr507
		case 32: goto st143
		case 40: goto tr508
		case 41: goto tr509
		case 59: goto st145
		case 65: goto tr105
		case 67: goto tr106
		case 68: goto tr40
		case 77: goto tr43
		case 78: goto tr107
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr105
		case 99: goto tr106
		case 100: goto tr40
		case 109: goto tr43
		case 110: goto tr107
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr510 }
	goto st0
tr510:
// line 89 "zparse.rl"
	{ mark = p }
	goto st144
st144:
	p++
	if p == pe { goto _test_eof144 }
	fallthrough
case 144:
// line 7115 "zparse.go"
	switch data[p] {
		case 9: goto tr512
		case 10: goto tr513
		case 32: goto tr512
		case 40: goto tr514
		case 41: goto tr515
		case 59: goto tr517
	}
	if 48 <= data[p] && data[p] <= 57 { goto st144 }
	goto st0
tr505:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
	goto st145
st145:
	p++
	if p == pe { goto _test_eof145 }
	fallthrough
case 145:
// line 7135 "zparse.go"
	if data[p] == 10 { goto tr507 }
	goto st145
tr8:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st146
st146:
	p++
	if p == pe { goto _test_eof146 }
	fallthrough
case 146:
// line 7149 "zparse.go"
	switch data[p] {
		case 72: goto st142
		case 78: goto st26
		case 83: goto st142
		case 104: goto st142
		case 110: goto st26
		case 115: goto st142
	}
	goto st0
tr10:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st147
st147:
	p++
	if p == pe { goto _test_eof147 }
	fallthrough
case 147:
// line 7170 "zparse.go"
	switch data[p] {
		case 83: goto st142
		case 115: goto st142
	}
	goto st0
tr11:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st148
st148:
	p++
	if p == pe { goto _test_eof148 }
	fallthrough
case 148:
// line 7187 "zparse.go"
	switch data[p] {
		case 78: goto st142
		case 110: goto st142
	}
	goto st0
tr13:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st149
st149:
	p++
	if p == pe { goto _test_eof149 }
	fallthrough
case 149:
// line 7204 "zparse.go"
	switch data[p] {
		case 79: goto st150
		case 83: goto st73
		case 111: goto st150
		case 115: goto st73
	}
	goto st0
st150:
	p++
	if p == pe { goto _test_eof150 }
	fallthrough
case 150:
	switch data[p] {
		case 78: goto st151
		case 110: goto st151
	}
	goto st0
st151:
	p++
	if p == pe { goto _test_eof151 }
	fallthrough
case 151:
	switch data[p] {
		case 69: goto st142
		case 101: goto st142
	}
	goto st0
tr5337:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st152
tr5393:
// line 89 "zparse.rl"
	{ mark = p }
	goto st152
st152:
	p++
	if p == pe { goto _test_eof152 }
	fallthrough
case 152:
// line 7247 "zparse.go"
	switch data[p] {
		case 9: goto tr520
		case 10: goto tr521
		case 32: goto tr520
		case 40: goto tr522
		case 41: goto tr523
		case 59: goto tr525
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st152
	}
	goto st0
tr5338:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st153
tr5347:
// line 89 "zparse.rl"
	{ mark = p }
	goto st153
st153:
	p++
	if p == pe { goto _test_eof153 }
	fallthrough
case 153:
// line 7285 "zparse.go"
	switch data[p] {
		case 9: goto tr526
		case 10: goto tr527
		case 32: goto tr526
		case 40: goto tr528
		case 41: goto tr529
		case 59: goto tr530
		case 65: goto st258
		case 78: goto st1718
		case 92: goto st2
		case 95: goto st2
		case 97: goto st258
		case 110: goto st1718
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr535:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st154
tr536:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st154
tr534:
// line 101 "zparse.rl"
	{ lines++ }
	goto st154
tr526:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st154
tr527:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st154
tr528:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st154
tr529:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st154
st154:
	p++
	if p == pe { goto _test_eof154 }
	fallthrough
case 154:
// line 7395 "zparse.go"
	switch data[p] {
		case 9: goto st154
		case 10: goto tr534
		case 32: goto st154
		case 40: goto tr535
		case 41: goto tr536
		case 43: goto tr58
		case 58: goto tr58
		case 59: goto st257
		case 61: goto tr58
		case 65: goto tr539
		case 67: goto tr540
		case 68: goto tr541
		case 72: goto tr542
		case 73: goto tr543
		case 77: goto tr544
		case 78: goto tr545
		case 82: goto tr546
		case 83: goto tr547
		case 92: goto tr58
		case 97: goto tr539
		case 99: goto tr540
		case 100: goto tr541
		case 104: goto tr542
		case 105: goto tr543
		case 109: goto tr544
		case 110: goto tr545
		case 114: goto tr546
		case 115: goto tr547
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr58 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr58 }
		} else if data[p] >= 66 {
			goto tr58
		}
	} else {
		goto tr537
	}
	goto st0
tr537:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st155
st155:
	p++
	if p == pe { goto _test_eof155 }
	fallthrough
case 155:
// line 7449 "zparse.go"
	switch data[p] {
		case 9: goto tr548
		case 10: goto tr549
		case 32: goto tr548
		case 40: goto tr550
		case 41: goto tr551
		case 43: goto st9
		case 58: goto st9
		case 59: goto tr553
		case 61: goto st9
		case 92: goto st9
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st9 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st9 }
		} else if data[p] >= 65 {
			goto st9
		}
	} else {
		goto st155
	}
	goto st0
tr556:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st156
tr557:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st156
tr548:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr550:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr551:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr589:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr591:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr592:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr917:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr919:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr920:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr969:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr971:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr972:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr1350:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr1352:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr1353:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr1755:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr1757:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
tr1758:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st156
st156:
	p++
	if p == pe { goto _test_eof156 }
	fallthrough
case 156:
// line 7784 "zparse.go"
	switch data[p] {
		case 9: goto st156
		case 10: goto tr555
		case 32: goto st156
		case 40: goto tr556
		case 41: goto tr557
		case 59: goto tr558
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	goto st0
tr555:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1722
tr596:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1722
tr549:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1722
tr590:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1722
tr918:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1722
tr970:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1722
tr1351:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1722
tr1756:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1722
st1722:
	p++
	if p == pe { goto _test_eof1722 }
	fallthrough
case 1722:
// line 7930 "zparse.go"
	switch data[p] {
		case 9: goto st1
		case 10: goto tr2
		case 32: goto st1
		case 40: goto tr3
		case 41: goto tr4
		case 59: goto tr6
		case 65: goto tr5347
		case 67: goto tr5348
		case 68: goto tr5349
		case 72: goto tr5350
		case 73: goto tr5351
		case 77: goto tr5352
		case 78: goto tr5353
		case 82: goto tr5354
		case 83: goto tr5355
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5347
		case 99: goto tr5348
		case 100: goto tr5349
		case 104: goto tr5350
		case 105: goto tr5351
		case 109: goto tr5352
		case 110: goto tr5353
		case 114: goto tr5354
		case 115: goto tr5355
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr5339:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st157
tr5348:
// line 89 "zparse.rl"
	{ mark = p }
	goto st157
st157:
	p++
	if p == pe { goto _test_eof157 }
	fallthrough
case 157:
// line 7986 "zparse.go"
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 72: goto st158
		case 78: goto st159
		case 83: goto st158
		case 92: goto st2
		case 95: goto st2
		case 104: goto st158
		case 110: goto st159
		case 115: goto st158
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st158:
	p++
	if p == pe { goto _test_eof158 }
	fallthrough
case 158:
	switch data[p] {
		case 9: goto tr561
		case 10: goto tr562
		case 32: goto tr561
		case 40: goto tr563
		case 41: goto tr564
		case 59: goto tr565
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st159:
	p++
	if p == pe { goto _test_eof159 }
	fallthrough
case 159:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 65: goto st160
		case 92: goto st2
		case 95: goto st2
		case 97: goto st160
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st160:
	p++
	if p == pe { goto _test_eof160 }
	fallthrough
case 160:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 77: goto st161
		case 92: goto st2
		case 95: goto st2
		case 109: goto st161
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st161:
	p++
	if p == pe { goto _test_eof161 }
	fallthrough
case 161:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 69: goto st162
		case 92: goto st2
		case 95: goto st2
		case 101: goto st162
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st162:
	p++
	if p == pe { goto _test_eof162 }
	fallthrough
case 162:
	switch data[p] {
		case 9: goto tr569
		case 10: goto tr570
		case 32: goto tr569
		case 40: goto tr571
		case 41: goto tr572
		case 59: goto tr573
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr576:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st163
tr577:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st163
tr575:
// line 101 "zparse.rl"
	{ lines++ }
	goto st163
tr569:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st163
tr570:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st163
tr571:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st163
tr572:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st163
st163:
	p++
	if p == pe { goto _test_eof163 }
	fallthrough
case 163:
// line 8239 "zparse.go"
	switch data[p] {
		case 9: goto st163
		case 10: goto tr575
		case 32: goto st163
		case 40: goto tr576
		case 41: goto tr577
		case 43: goto tr121
		case 58: goto tr121
		case 59: goto st166
		case 61: goto tr121
		case 65: goto tr580
		case 67: goto tr581
		case 68: goto tr582
		case 72: goto tr583
		case 73: goto tr584
		case 77: goto tr585
		case 78: goto tr586
		case 82: goto tr587
		case 83: goto tr588
		case 92: goto tr121
		case 97: goto tr580
		case 99: goto tr581
		case 100: goto tr582
		case 104: goto tr583
		case 105: goto tr584
		case 109: goto tr585
		case 110: goto tr586
		case 114: goto tr587
		case 115: goto tr588
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr121 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr121 }
		} else if data[p] >= 66 {
			goto tr121
		}
	} else {
		goto tr578
	}
	goto st0
tr578:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st164
st164:
	p++
	if p == pe { goto _test_eof164 }
	fallthrough
case 164:
// line 8293 "zparse.go"
	switch data[p] {
		case 9: goto tr589
		case 10: goto tr590
		case 32: goto tr589
		case 40: goto tr591
		case 41: goto tr592
		case 43: goto st31
		case 58: goto st31
		case 59: goto tr594
		case 61: goto st31
		case 92: goto st31
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st31 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st31 }
		} else if data[p] >= 65 {
			goto st31
		}
	} else {
		goto st164
	}
	goto st0
tr558:
// line 89 "zparse.rl"
	{ mark = p }
	goto st165
tr553:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st165
tr594:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st165
tr922:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st165
tr974:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st165
tr1355:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st165
tr1760:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st165
st165:
	p++
	if p == pe { goto _test_eof165 }
	fallthrough
case 165:
// line 8418 "zparse.go"
	if data[p] == 10 { goto tr596 }
	goto st165
tr573:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st166
st166:
	p++
	if p == pe { goto _test_eof166 }
	fallthrough
case 166:
// line 8441 "zparse.go"
	if data[p] == 10 { goto tr575 }
	goto st166
tr580:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st167
st167:
	p++
	if p == pe { goto _test_eof167 }
	fallthrough
case 167:
// line 8455 "zparse.go"
	switch data[p] {
		case 9: goto tr597
		case 10: goto tr598
		case 32: goto tr597
		case 40: goto tr599
		case 41: goto tr600
		case 43: goto st31
		case 59: goto tr601
		case 61: goto st31
		case 65: goto st1714
		case 78: goto st1717
		case 92: goto st31
		case 97: goto st1714
		case 110: goto st1717
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
tr606:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st168
tr607:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st168
tr597:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr599:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr600:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr871:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr873:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr874:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr923:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr925:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr926:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr975:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr977:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr978:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr1678:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr1680:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr1681:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr2294:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr2296:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr2297:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr3710:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr3712:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr3713:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr3854:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr3856:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
tr3857:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st168
st168:
	p++
	if p == pe { goto _test_eof168 }
	fallthrough
case 168:
// line 9121 "zparse.go"
	switch data[p] {
		case 9: goto st168
		case 10: goto tr605
		case 32: goto st168
		case 40: goto tr606
		case 41: goto tr607
		case 43: goto tr58
		case 59: goto tr608
		case 61: goto tr58
		case 92: goto tr58
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr58 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr58 }
	} else {
		goto tr58
	}
	goto st0
tr605:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1723
tr879:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1723
tr598:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1723
tr872:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1723
tr924:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1723
tr976:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1723
tr1679:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1723
tr2295:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1723
tr3711:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1723
tr3855:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1723
st1723:
	p++
	if p == pe { goto _test_eof1723 }
	fallthrough
case 1723:
// line 9371 "zparse.go"
	switch data[p] {
		case 9: goto st169
		case 10: goto tr610
		case 32: goto st169
		case 40: goto tr611
		case 41: goto tr612
		case 43: goto tr58
		case 47: goto tr58
		case 58: goto tr58
		case 59: goto tr613
		case 61: goto tr58
		case 92: goto tr5356
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto tr5356 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr5356 }
	} else {
		goto tr5356
	}
	goto st0
tr611:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st169
tr612:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st169
tr628:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st169
tr630:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st169
tr631:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st169
tr671:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st169
tr673:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st169
tr674:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st169
tr719:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st169
tr721:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st169
tr722:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st169
tr1833:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st169
tr1835:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st169
tr1836:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st169
tr3981:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st169
tr3983:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st169
tr3984:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st169
st169:
	p++
	if p == pe { goto _test_eof169 }
	fallthrough
case 169:
// line 9805 "zparse.go"
	switch data[p] {
		case 9: goto st169
		case 10: goto tr610
		case 32: goto st169
		case 40: goto tr611
		case 41: goto tr612
		case 43: goto tr58
		case 58: goto tr58
		case 59: goto tr613
		case 61: goto tr58
		case 65: goto tr539
		case 67: goto tr540
		case 68: goto tr541
		case 72: goto tr542
		case 73: goto tr543
		case 77: goto tr544
		case 78: goto tr545
		case 82: goto tr546
		case 83: goto tr547
		case 92: goto tr58
		case 97: goto tr539
		case 99: goto tr540
		case 100: goto tr541
		case 104: goto tr542
		case 105: goto tr543
		case 109: goto tr544
		case 110: goto tr545
		case 114: goto tr546
		case 115: goto tr547
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr58 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr58 }
		} else if data[p] >= 66 {
			goto tr58
		}
	} else {
		goto tr537
	}
	goto st0
tr610:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1724
tr627:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1724
tr629:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1724
tr672:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1724
tr720:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1724
tr1834:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1724
tr3982:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1724
st1724:
	p++
	if p == pe { goto _test_eof1724 }
	fallthrough
case 1724:
// line 9999 "zparse.go"
	switch data[p] {
		case 9: goto st169
		case 10: goto tr610
		case 32: goto st169
		case 40: goto tr611
		case 41: goto tr612
		case 43: goto tr58
		case 47: goto tr58
		case 58: goto tr58
		case 59: goto tr613
		case 61: goto tr58
		case 65: goto tr5358
		case 67: goto tr5359
		case 68: goto tr5360
		case 72: goto tr5361
		case 73: goto tr5362
		case 77: goto tr5363
		case 78: goto tr5364
		case 82: goto tr5365
		case 83: goto tr5366
		case 92: goto tr5356
		case 95: goto st2
		case 97: goto tr5358
		case 99: goto tr5359
		case 100: goto tr5360
		case 104: goto tr5361
		case 105: goto tr5362
		case 109: goto tr5363
		case 110: goto tr5364
		case 114: goto tr5365
		case 115: goto tr5366
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5356 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr5356 }
		} else if data[p] >= 66 {
			goto tr5356
		}
	} else {
		goto tr5357
	}
	goto st0
tr5356:
// line 89 "zparse.rl"
	{ mark = p }
	goto st170
st170:
	p++
	if p == pe { goto _test_eof170 }
	fallthrough
case 170:
// line 10053 "zparse.go"
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 92: goto st170
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
tr5357:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st171
st171:
	p++
	if p == pe { goto _test_eof171 }
	fallthrough
case 171:
// line 10087 "zparse.go"
	switch data[p] {
		case 9: goto tr620
		case 10: goto tr621
		case 32: goto tr620
		case 40: goto tr622
		case 41: goto tr623
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr625
		case 61: goto st9
		case 92: goto st170
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st170 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st170 }
		} else if data[p] >= 65 {
			goto st170
		}
	} else {
		goto st171
	}
	goto st0
tr613:
// line 89 "zparse.rl"
	{ mark = p }
	goto st172
tr632:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st172
tr675:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st172
tr723:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st172
tr1837:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st172
tr3985:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st172
st172:
	p++
	if p == pe { goto _test_eof172 }
	fallthrough
case 172:
// line 10249 "zparse.go"
	if data[p] == 10 { goto tr627 }
	goto st172
tr5358:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st173
st173:
	p++
	if p == pe { goto _test_eof173 }
	fallthrough
case 173:
// line 10263 "zparse.go"
	switch data[p] {
		case 9: goto tr628
		case 10: goto tr629
		case 32: goto tr628
		case 40: goto tr630
		case 41: goto tr631
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr632
		case 61: goto st9
		case 65: goto st174
		case 78: goto st1713
		case 92: goto st170
		case 95: goto st2
		case 97: goto st174
		case 110: goto st1713
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st174:
	p++
	if p == pe { goto _test_eof174 }
	fallthrough
case 174:
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 65: goto st175
		case 92: goto st170
		case 95: goto st2
		case 97: goto st175
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st175:
	p++
	if p == pe { goto _test_eof175 }
	fallthrough
case 175:
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 65: goto st176
		case 92: goto st170
		case 95: goto st2
		case 97: goto st176
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st176:
	p++
	if p == pe { goto _test_eof176 }
	fallthrough
case 176:
	switch data[p] {
		case 9: goto tr637
		case 10: goto tr638
		case 32: goto tr637
		case 40: goto tr639
		case 41: goto tr640
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr641
		case 61: goto st9
		case 92: goto st170
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
tr644:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st177
tr645:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st177
tr637:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st177
tr639:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st177
tr640:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st177
tr680:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st177
tr682:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st177
tr683:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st177
tr728:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st177
tr730:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st177
tr731:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st177
tr1842:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st177
tr1844:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st177
tr1845:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st177
tr3990:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st177
tr3992:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st177
tr3993:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st177
st177:
	p++
	if p == pe { goto _test_eof177 }
	fallthrough
case 177:
// line 10786 "zparse.go"
	switch data[p] {
		case 9: goto st177
		case 10: goto tr643
		case 32: goto st177
		case 40: goto tr644
		case 41: goto tr645
		case 43: goto tr86
		case 58: goto tr86
		case 59: goto tr647
		case 61: goto tr86
		case 65: goto tr648
		case 67: goto tr649
		case 68: goto tr650
		case 72: goto tr651
		case 73: goto tr652
		case 77: goto tr653
		case 78: goto tr654
		case 82: goto tr655
		case 83: goto tr656
		case 92: goto tr86
		case 97: goto tr648
		case 99: goto tr649
		case 100: goto tr650
		case 104: goto tr651
		case 105: goto tr652
		case 109: goto tr653
		case 110: goto tr654
		case 114: goto tr655
		case 115: goto tr656
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr86 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr86 }
		} else if data[p] >= 66 {
			goto tr86
		}
	} else {
		goto tr646
	}
	goto st0
tr643:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1725
tr670:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1725
tr638:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1725
tr681:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1725
tr729:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1725
tr1843:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1725
tr3991:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1725
st1725:
	p++
	if p == pe { goto _test_eof1725 }
	fallthrough
case 1725:
// line 10980 "zparse.go"
	switch data[p] {
		case 9: goto st177
		case 10: goto tr643
		case 32: goto st177
		case 40: goto tr644
		case 41: goto tr645
		case 43: goto tr86
		case 47: goto tr86
		case 58: goto tr86
		case 59: goto tr647
		case 61: goto tr86
		case 65: goto tr5369
		case 67: goto tr5370
		case 68: goto tr5371
		case 72: goto tr5372
		case 73: goto tr5373
		case 77: goto tr5374
		case 78: goto tr5375
		case 82: goto tr5376
		case 83: goto tr5377
		case 92: goto tr5367
		case 95: goto st2
		case 97: goto tr5369
		case 99: goto tr5370
		case 100: goto tr5371
		case 104: goto tr5372
		case 105: goto tr5373
		case 109: goto tr5374
		case 110: goto tr5375
		case 114: goto tr5376
		case 115: goto tr5377
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5367 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr5367 }
		} else if data[p] >= 66 {
			goto tr5367
		}
	} else {
		goto tr5368
	}
	goto st0
tr5367:
// line 89 "zparse.rl"
	{ mark = p }
	goto st178
st178:
	p++
	if p == pe { goto _test_eof178 }
	fallthrough
case 178:
// line 11034 "zparse.go"
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 92: goto st178
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
tr5368:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st179
st179:
	p++
	if p == pe { goto _test_eof179 }
	fallthrough
case 179:
// line 11068 "zparse.go"
	switch data[p] {
		case 9: goto tr663
		case 10: goto tr664
		case 32: goto tr663
		case 40: goto tr665
		case 41: goto tr666
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr668
		case 61: goto st18
		case 92: goto st178
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st178 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st178 }
		} else if data[p] >= 65 {
			goto st178
		}
	} else {
		goto st179
	}
	goto st0
tr647:
// line 89 "zparse.rl"
	{ mark = p }
	goto st180
tr641:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st180
tr684:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st180
tr732:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st180
tr1846:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st180
tr3994:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st180
st180:
	p++
	if p == pe { goto _test_eof180 }
	fallthrough
case 180:
// line 11230 "zparse.go"
	if data[p] == 10 { goto tr670 }
	goto st180
tr5369:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st181
st181:
	p++
	if p == pe { goto _test_eof181 }
	fallthrough
case 181:
// line 11244 "zparse.go"
	switch data[p] {
		case 9: goto tr671
		case 10: goto tr672
		case 32: goto tr671
		case 40: goto tr673
		case 41: goto tr674
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr675
		case 61: goto st18
		case 65: goto st182
		case 78: goto st185
		case 92: goto st178
		case 95: goto st2
		case 97: goto st182
		case 110: goto st185
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st182:
	p++
	if p == pe { goto _test_eof182 }
	fallthrough
case 182:
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 65: goto st183
		case 92: goto st178
		case 95: goto st2
		case 97: goto st183
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st183:
	p++
	if p == pe { goto _test_eof183 }
	fallthrough
case 183:
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 65: goto st184
		case 92: goto st178
		case 95: goto st2
		case 97: goto st184
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st184:
	p++
	if p == pe { goto _test_eof184 }
	fallthrough
case 184:
	switch data[p] {
		case 9: goto tr680
		case 10: goto tr681
		case 32: goto tr680
		case 40: goto tr682
		case 41: goto tr683
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr684
		case 61: goto st18
		case 92: goto st178
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st185:
	p++
	if p == pe { goto _test_eof185 }
	fallthrough
case 185:
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 89: goto st186
		case 92: goto st178
		case 95: goto st2
		case 121: goto st186
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st186:
	p++
	if p == pe { goto _test_eof186 }
	fallthrough
case 186:
	switch data[p] {
		case 9: goto tr686
		case 10: goto tr687
		case 32: goto tr686
		case 40: goto tr688
		case 41: goto tr689
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr690
		case 61: goto st18
		case 92: goto st178
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
tr5370:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st187
st187:
	p++
	if p == pe { goto _test_eof187 }
	fallthrough
case 187:
// line 11423 "zparse.go"
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 72: goto st186
		case 78: goto st188
		case 83: goto st186
		case 92: goto st178
		case 95: goto st2
		case 104: goto st186
		case 110: goto st188
		case 115: goto st186
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st188:
	p++
	if p == pe { goto _test_eof188 }
	fallthrough
case 188:
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 65: goto st189
		case 92: goto st178
		case 95: goto st2
		case 97: goto st189
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st189:
	p++
	if p == pe { goto _test_eof189 }
	fallthrough
case 189:
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 77: goto st190
		case 92: goto st178
		case 95: goto st2
		case 109: goto st190
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st190:
	p++
	if p == pe { goto _test_eof190 }
	fallthrough
case 190:
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 69: goto st191
		case 92: goto st178
		case 95: goto st2
		case 101: goto st191
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st191:
	p++
	if p == pe { goto _test_eof191 }
	fallthrough
case 191:
	switch data[p] {
		case 9: goto tr695
		case 10: goto tr696
		case 32: goto tr695
		case 40: goto tr697
		case 41: goto tr698
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr699
		case 61: goto st18
		case 92: goto st178
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
tr702:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st192
tr703:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st192
tr2230:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st192
tr2232:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st192
tr2233:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st192
tr695:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st192
tr697:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st192
tr698:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st192
tr743:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st192
tr745:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st192
tr746:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st192
tr1857:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st192
tr1859:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st192
tr1860:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st192
tr4005:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st192
tr4007:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st192
tr4008:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st192
st192:
	p++
	if p == pe { goto _test_eof192 }
	fallthrough
case 192:
// line 11977 "zparse.go"
	switch data[p] {
		case 9: goto st192
		case 10: goto tr701
		case 32: goto st192
		case 40: goto tr702
		case 41: goto tr703
		case 43: goto tr121
		case 58: goto tr121
		case 59: goto tr704
		case 61: goto tr121
		case 65: goto tr580
		case 67: goto tr581
		case 68: goto tr582
		case 72: goto tr583
		case 73: goto tr584
		case 77: goto tr585
		case 78: goto tr586
		case 82: goto tr587
		case 83: goto tr588
		case 92: goto tr121
		case 97: goto tr580
		case 99: goto tr581
		case 100: goto tr582
		case 104: goto tr583
		case 105: goto tr584
		case 109: goto tr585
		case 110: goto tr586
		case 114: goto tr587
		case 115: goto tr588
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr121 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr121 }
		} else if data[p] >= 66 {
			goto tr121
		}
	} else {
		goto tr578
	}
	goto st0
tr701:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1726
tr718:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1726
tr2231:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1726
tr696:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1726
tr744:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1726
tr1858:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1726
tr4006:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1726
st1726:
	p++
	if p == pe { goto _test_eof1726 }
	fallthrough
case 1726:
// line 12171 "zparse.go"
	switch data[p] {
		case 9: goto st192
		case 10: goto tr701
		case 32: goto st192
		case 40: goto tr702
		case 41: goto tr703
		case 43: goto tr121
		case 47: goto tr121
		case 58: goto tr121
		case 59: goto tr704
		case 61: goto tr121
		case 65: goto tr5380
		case 67: goto tr5381
		case 68: goto tr5382
		case 72: goto tr5383
		case 73: goto tr5384
		case 77: goto tr5385
		case 78: goto tr5386
		case 82: goto tr5387
		case 83: goto tr5388
		case 92: goto tr5378
		case 95: goto st2
		case 97: goto tr5380
		case 99: goto tr5381
		case 100: goto tr5382
		case 104: goto tr5383
		case 105: goto tr5384
		case 109: goto tr5385
		case 110: goto tr5386
		case 114: goto tr5387
		case 115: goto tr5388
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5378 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr5378 }
		} else if data[p] >= 66 {
			goto tr5378
		}
	} else {
		goto tr5379
	}
	goto st0
tr5378:
// line 89 "zparse.rl"
	{ mark = p }
	goto st193
st193:
	p++
	if p == pe { goto _test_eof193 }
	fallthrough
case 193:
// line 12225 "zparse.go"
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 92: goto st193
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
tr5379:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st194
st194:
	p++
	if p == pe { goto _test_eof194 }
	fallthrough
case 194:
// line 12259 "zparse.go"
	switch data[p] {
		case 9: goto tr711
		case 10: goto tr712
		case 32: goto tr711
		case 40: goto tr713
		case 41: goto tr714
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr716
		case 61: goto st31
		case 92: goto st193
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st193 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st193 }
		} else if data[p] >= 65 {
			goto st193
		}
	} else {
		goto st194
	}
	goto st0
tr704:
// line 89 "zparse.rl"
	{ mark = p }
	goto st195
tr2234:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st195
tr699:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st195
tr747:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st195
tr1861:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st195
tr4009:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st195
st195:
	p++
	if p == pe { goto _test_eof195 }
	fallthrough
case 195:
// line 12421 "zparse.go"
	if data[p] == 10 { goto tr718 }
	goto st195
tr5380:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st196
st196:
	p++
	if p == pe { goto _test_eof196 }
	fallthrough
case 196:
// line 12435 "zparse.go"
	switch data[p] {
		case 9: goto tr719
		case 10: goto tr720
		case 32: goto tr719
		case 40: goto tr721
		case 41: goto tr722
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr723
		case 61: goto st31
		case 65: goto st197
		case 78: goto st200
		case 92: goto st193
		case 95: goto st2
		case 97: goto st197
		case 110: goto st200
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st197:
	p++
	if p == pe { goto _test_eof197 }
	fallthrough
case 197:
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 65: goto st198
		case 92: goto st193
		case 95: goto st2
		case 97: goto st198
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st198:
	p++
	if p == pe { goto _test_eof198 }
	fallthrough
case 198:
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 65: goto st199
		case 92: goto st193
		case 95: goto st2
		case 97: goto st199
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st199:
	p++
	if p == pe { goto _test_eof199 }
	fallthrough
case 199:
	switch data[p] {
		case 9: goto tr728
		case 10: goto tr729
		case 32: goto tr728
		case 40: goto tr730
		case 41: goto tr731
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr732
		case 61: goto st31
		case 92: goto st193
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st200:
	p++
	if p == pe { goto _test_eof200 }
	fallthrough
case 200:
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 89: goto st201
		case 92: goto st193
		case 95: goto st2
		case 121: goto st201
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st201:
	p++
	if p == pe { goto _test_eof201 }
	fallthrough
case 201:
	switch data[p] {
		case 9: goto tr734
		case 10: goto tr735
		case 32: goto tr734
		case 40: goto tr736
		case 41: goto tr737
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr738
		case 61: goto st31
		case 92: goto st193
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
tr5381:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st202
st202:
	p++
	if p == pe { goto _test_eof202 }
	fallthrough
case 202:
// line 12614 "zparse.go"
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 72: goto st201
		case 78: goto st203
		case 83: goto st201
		case 92: goto st193
		case 95: goto st2
		case 104: goto st201
		case 110: goto st203
		case 115: goto st201
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st203:
	p++
	if p == pe { goto _test_eof203 }
	fallthrough
case 203:
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 65: goto st204
		case 92: goto st193
		case 95: goto st2
		case 97: goto st204
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st204:
	p++
	if p == pe { goto _test_eof204 }
	fallthrough
case 204:
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 77: goto st205
		case 92: goto st193
		case 95: goto st2
		case 109: goto st205
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st205:
	p++
	if p == pe { goto _test_eof205 }
	fallthrough
case 205:
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 69: goto st206
		case 92: goto st193
		case 95: goto st2
		case 101: goto st206
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st206:
	p++
	if p == pe { goto _test_eof206 }
	fallthrough
case 206:
	switch data[p] {
		case 9: goto tr743
		case 10: goto tr744
		case 32: goto tr743
		case 40: goto tr745
		case 41: goto tr746
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr747
		case 61: goto st31
		case 92: goto st193
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
tr5382:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st207
st207:
	p++
	if p == pe { goto _test_eof207 }
	fallthrough
case 207:
// line 12768 "zparse.go"
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 78: goto st208
		case 83: goto st1712
		case 92: goto st193
		case 95: goto st2
		case 110: goto st208
		case 115: goto st1712
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st208:
	p++
	if p == pe { goto _test_eof208 }
	fallthrough
case 208:
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 83: goto st209
		case 92: goto st193
		case 95: goto st2
		case 115: goto st209
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st209:
	p++
	if p == pe { goto _test_eof209 }
	fallthrough
case 209:
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 75: goto st210
		case 92: goto st193
		case 95: goto st2
		case 107: goto st210
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st210:
	p++
	if p == pe { goto _test_eof210 }
	fallthrough
case 210:
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 69: goto st211
		case 92: goto st193
		case 95: goto st2
		case 101: goto st211
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st211:
	p++
	if p == pe { goto _test_eof211 }
	fallthrough
case 211:
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 89: goto st212
		case 92: goto st193
		case 95: goto st2
		case 121: goto st212
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st212:
	p++
	if p == pe { goto _test_eof212 }
	fallthrough
case 212:
	switch data[p] {
		case 9: goto tr754
		case 10: goto tr755
		case 32: goto tr754
		case 40: goto tr756
		case 41: goto tr757
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr758
		case 61: goto st31
		case 92: goto st193
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
tr761:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st213
tr762:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st213
tr2241:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st213
tr2243:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st213
tr2244:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st213
tr2431:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st213
tr2433:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st213
tr2434:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st213
tr754:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st213
tr756:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st213
tr757:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st213
tr1868:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st213
tr1870:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st213
tr1871:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st213
tr4016:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st213
tr4018:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st213
tr4019:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st213
st213:
	p++
	if p == pe { goto _test_eof213 }
	fallthrough
case 213:
// line 13349 "zparse.go"
	switch data[p] {
		case 9: goto st213
		case 10: goto tr760
		case 32: goto st213
		case 40: goto tr761
		case 41: goto tr762
		case 59: goto tr764
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr763 }
	goto st0
tr760:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1727
tr789:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1727
tr2242:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1727
tr2432:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1727
tr755:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1727
tr1869:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1727
tr4017:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1727
st1727:
	p++
	if p == pe { goto _test_eof1727 }
	fallthrough
case 1727:
// line 13529 "zparse.go"
	switch data[p] {
		case 9: goto st213
		case 10: goto tr760
		case 32: goto st213
		case 40: goto tr761
		case 41: goto tr762
		case 59: goto tr764
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5389
	}
	goto st0
tr5389:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st214
st214:
	p++
	if p == pe { goto _test_eof214 }
	fallthrough
case 214:
// line 13581 "zparse.go"
	switch data[p] {
		case 9: goto tr765
		case 10: goto tr766
		case 32: goto tr765
		case 40: goto tr767
		case 41: goto tr768
		case 59: goto tr770
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st214
	}
	goto st0
tr773:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st215
tr774:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st215
tr772:
// line 101 "zparse.rl"
	{ lines++ }
	goto st215
tr765:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st215
tr766:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st215
tr767:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st215
tr768:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st215
tr1029:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st215
tr1030:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st215
tr1031:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st215
tr1032:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st215
st215:
	p++
	if p == pe { goto _test_eof215 }
	fallthrough
case 215:
// line 13689 "zparse.go"
	switch data[p] {
		case 9: goto st215
		case 10: goto tr772
		case 32: goto st215
		case 40: goto tr773
		case 41: goto tr774
		case 59: goto st219
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr775 }
	goto st0
tr775:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st216
st216:
	p++
	if p == pe { goto _test_eof216 }
	fallthrough
case 216:
// line 13729 "zparse.go"
	switch data[p] {
		case 9: goto tr777
		case 10: goto tr778
		case 32: goto tr777
		case 40: goto tr779
		case 41: goto tr780
		case 59: goto tr782
	}
	if 48 <= data[p] && data[p] <= 57 { goto st216 }
	goto st0
tr785:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st217
tr786:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st217
tr784:
// line 101 "zparse.rl"
	{ lines++ }
	goto st217
tr777:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st217
tr778:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st217
tr779:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st217
tr780:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st217
st217:
	p++
	if p == pe { goto _test_eof217 }
	fallthrough
case 217:
// line 13787 "zparse.go"
	switch data[p] {
		case 9: goto st217
		case 10: goto tr784
		case 32: goto st217
		case 40: goto tr785
		case 41: goto tr786
		case 59: goto st218
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr168 }
	goto st0
tr782:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st218
st218:
	p++
	if p == pe { goto _test_eof218 }
	fallthrough
case 218:
// line 13827 "zparse.go"
	if data[p] == 10 { goto tr784 }
	goto st218
tr770:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st219
tr1034:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st219
st219:
	p++
	if p == pe { goto _test_eof219 }
	fallthrough
case 219:
// line 13849 "zparse.go"
	if data[p] == 10 { goto tr772 }
	goto st219
tr764:
// line 89 "zparse.rl"
	{ mark = p }
	goto st220
tr2245:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st220
tr2435:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st220
tr758:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st220
tr1872:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st220
tr4020:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st220
st220:
	p++
	if p == pe { goto _test_eof220 }
	fallthrough
case 220:
// line 13987 "zparse.go"
	if data[p] == 10 { goto tr789 }
	goto st220
tr5340:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st221
tr5349:
// line 89 "zparse.rl"
	{ mark = p }
	goto st221
st221:
	p++
	if p == pe { goto _test_eof221 }
	fallthrough
case 221:
// line 14005 "zparse.go"
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 78: goto st222
		case 83: goto st232
		case 92: goto st2
		case 95: goto st2
		case 110: goto st222
		case 115: goto st232
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st222:
	p++
	if p == pe { goto _test_eof222 }
	fallthrough
case 222:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 83: goto st223
		case 92: goto st2
		case 95: goto st2
		case 115: goto st223
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st223:
	p++
	if p == pe { goto _test_eof223 }
	fallthrough
case 223:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 75: goto st224
		case 92: goto st2
		case 95: goto st2
		case 107: goto st224
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st224:
	p++
	if p == pe { goto _test_eof224 }
	fallthrough
case 224:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 69: goto st225
		case 92: goto st2
		case 95: goto st2
		case 101: goto st225
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st225:
	p++
	if p == pe { goto _test_eof225 }
	fallthrough
case 225:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 89: goto st226
		case 92: goto st2
		case 95: goto st2
		case 121: goto st226
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st226:
	p++
	if p == pe { goto _test_eof226 }
	fallthrough
case 226:
	switch data[p] {
		case 9: goto tr796
		case 10: goto tr797
		case 32: goto tr796
		case 40: goto tr798
		case 41: goto tr799
		case 59: goto tr800
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr803:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st227
tr804:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st227
tr802:
// line 101 "zparse.rl"
	{ lines++ }
	goto st227
tr796:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st227
tr797:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st227
tr798:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st227
tr799:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st227
st227:
	p++
	if p == pe { goto _test_eof227 }
	fallthrough
case 227:
// line 14258 "zparse.go"
	switch data[p] {
		case 9: goto st227
		case 10: goto tr802
		case 32: goto st227
		case 40: goto tr803
		case 41: goto tr804
		case 59: goto st231
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr763 }
	goto st0
tr763:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st228
st228:
	p++
	if p == pe { goto _test_eof228 }
	fallthrough
case 228:
// line 14298 "zparse.go"
	switch data[p] {
		case 9: goto tr806
		case 10: goto tr807
		case 32: goto tr806
		case 40: goto tr808
		case 41: goto tr809
		case 59: goto tr811
	}
	if 48 <= data[p] && data[p] <= 57 { goto st228 }
	goto st0
tr814:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st229
tr815:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st229
tr813:
// line 101 "zparse.rl"
	{ lines++ }
	goto st229
tr806:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st229
tr807:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st229
tr808:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st229
tr809:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st229
st229:
	p++
	if p == pe { goto _test_eof229 }
	fallthrough
case 229:
// line 14356 "zparse.go"
	switch data[p] {
		case 9: goto st229
		case 10: goto tr813
		case 32: goto st229
		case 40: goto tr814
		case 41: goto tr815
		case 59: goto st230
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr156 }
	goto st0
tr811:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st230
st230:
	p++
	if p == pe { goto _test_eof230 }
	fallthrough
case 230:
// line 14396 "zparse.go"
	if data[p] == 10 { goto tr813 }
	goto st230
tr800:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st231
st231:
	p++
	if p == pe { goto _test_eof231 }
	fallthrough
case 231:
// line 14419 "zparse.go"
	if data[p] == 10 { goto tr802 }
	goto st231
st232:
	p++
	if p == pe { goto _test_eof232 }
	fallthrough
case 232:
	switch data[p] {
		case 9: goto tr817
		case 10: goto tr818
		case 32: goto tr817
		case 40: goto tr819
		case 41: goto tr820
		case 59: goto tr821
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr824:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st233
tr825:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st233
tr823:
// line 101 "zparse.rl"
	{ lines++ }
	goto st233
tr817:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st233
tr818:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st233
tr819:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st233
tr820:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st233
st233:
	p++
	if p == pe { goto _test_eof233 }
	fallthrough
case 233:
// line 14532 "zparse.go"
	switch data[p] {
		case 9: goto st233
		case 10: goto tr823
		case 32: goto st233
		case 40: goto tr824
		case 41: goto tr825
		case 59: goto st237
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr826 }
	goto st0
tr826:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st234
st234:
	p++
	if p == pe { goto _test_eof234 }
	fallthrough
case 234:
// line 14572 "zparse.go"
	switch data[p] {
		case 9: goto tr828
		case 10: goto tr829
		case 32: goto tr828
		case 40: goto tr830
		case 41: goto tr831
		case 59: goto tr833
	}
	if 48 <= data[p] && data[p] <= 57 { goto st234 }
	goto st0
tr836:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st235
tr837:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st235
tr835:
// line 101 "zparse.rl"
	{ lines++ }
	goto st235
tr828:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st235
tr829:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st235
tr830:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st235
tr831:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st235
st235:
	p++
	if p == pe { goto _test_eof235 }
	fallthrough
case 235:
// line 14630 "zparse.go"
	switch data[p] {
		case 9: goto st235
		case 10: goto tr835
		case 32: goto st235
		case 40: goto tr836
		case 41: goto tr837
		case 59: goto st236
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr209 }
	goto st0
tr833:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st236
st236:
	p++
	if p == pe { goto _test_eof236 }
	fallthrough
case 236:
// line 14670 "zparse.go"
	if data[p] == 10 { goto tr835 }
	goto st236
tr821:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st237
st237:
	p++
	if p == pe { goto _test_eof237 }
	fallthrough
case 237:
// line 14693 "zparse.go"
	if data[p] == 10 { goto tr823 }
	goto st237
tr5341:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st238
tr5350:
// line 89 "zparse.rl"
	{ mark = p }
	goto st238
st238:
	p++
	if p == pe { goto _test_eof238 }
	fallthrough
case 238:
// line 14711 "zparse.go"
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 83: goto st158
		case 92: goto st2
		case 95: goto st2
		case 115: goto st158
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr5342:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st239
tr5351:
// line 89 "zparse.rl"
	{ mark = p }
	goto st239
st239:
	p++
	if p == pe { goto _test_eof239 }
	fallthrough
case 239:
// line 14751 "zparse.go"
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 78: goto st158
		case 92: goto st2
		case 95: goto st2
		case 110: goto st158
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr5343:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st240
tr5352:
// line 89 "zparse.rl"
	{ mark = p }
	goto st240
st240:
	p++
	if p == pe { goto _test_eof240 }
	fallthrough
case 240:
// line 14791 "zparse.go"
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 88: goto st241
		case 92: goto st2
		case 95: goto st2
		case 120: goto st241
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st241:
	p++
	if p == pe { goto _test_eof241 }
	fallthrough
case 241:
	switch data[p] {
		case 9: goto tr840
		case 10: goto tr841
		case 32: goto tr840
		case 40: goto tr842
		case 41: goto tr843
		case 59: goto tr844
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr847:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st242
tr848:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st242
tr846:
// line 101 "zparse.rl"
	{ lines++ }
	goto st242
tr840:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st242
tr841:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st242
tr842:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st242
tr843:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st242
st242:
	p++
	if p == pe { goto _test_eof242 }
	fallthrough
case 242:
// line 14926 "zparse.go"
	switch data[p] {
		case 9: goto st242
		case 10: goto tr846
		case 32: goto st242
		case 40: goto tr847
		case 41: goto tr848
		case 59: goto st1711
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr849 }
	goto st0
tr849:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st243
st243:
	p++
	if p == pe { goto _test_eof243 }
	fallthrough
case 243:
// line 14966 "zparse.go"
	switch data[p] {
		case 9: goto tr851
		case 10: goto tr852
		case 32: goto tr851
		case 40: goto tr853
		case 41: goto tr854
		case 59: goto tr856
	}
	if 48 <= data[p] && data[p] <= 57 { goto st243 }
	goto st0
tr859:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st244
tr860:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st244
tr858:
// line 101 "zparse.rl"
	{ lines++ }
	goto st244
tr851:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st244
tr852:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st244
tr853:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st244
tr854:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st244
st244:
	p++
	if p == pe { goto _test_eof244 }
	fallthrough
case 244:
// line 15024 "zparse.go"
	switch data[p] {
		case 9: goto st244
		case 10: goto tr858
		case 32: goto st244
		case 40: goto tr859
		case 41: goto tr860
		case 43: goto tr263
		case 59: goto st245
		case 61: goto tr263
		case 65: goto tr862
		case 67: goto tr863
		case 68: goto tr864
		case 72: goto tr865
		case 73: goto tr866
		case 77: goto tr867
		case 78: goto tr868
		case 82: goto tr869
		case 83: goto tr870
		case 92: goto tr263
		case 97: goto tr862
		case 99: goto tr863
		case 100: goto tr864
		case 104: goto tr865
		case 105: goto tr866
		case 109: goto tr867
		case 110: goto tr868
		case 114: goto tr869
		case 115: goto tr870
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto tr263 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto tr263 }
	} else {
		goto tr263
	}
	goto st0
tr856:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st245
st245:
	p++
	if p == pe { goto _test_eof245 }
	fallthrough
case 245:
// line 15073 "zparse.go"
	if data[p] == 10 { goto tr858 }
	goto st245
tr862:
// line 89 "zparse.rl"
	{ mark = p }
	goto st246
st246:
	p++
	if p == pe { goto _test_eof246 }
	fallthrough
case 246:
// line 15085 "zparse.go"
	switch data[p] {
		case 9: goto tr871
		case 10: goto tr872
		case 32: goto tr871
		case 40: goto tr873
		case 41: goto tr874
		case 43: goto st69
		case 59: goto tr875
		case 61: goto st69
		case 65: goto st248
		case 78: goto st253
		case 92: goto st69
		case 97: goto st248
		case 110: goto st253
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr608:
// line 89 "zparse.rl"
	{ mark = p }
	goto st247
tr601:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st247
tr875:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st247
tr927:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st247
tr979:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st247
tr1682:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st247
tr2298:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st247
tr3714:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st247
tr3858:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st247
st247:
	p++
	if p == pe { goto _test_eof247 }
	fallthrough
case 247:
// line 15317 "zparse.go"
	if data[p] == 10 { goto tr879 }
	goto st247
st248:
	p++
	if p == pe { goto _test_eof248 }
	fallthrough
case 248:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 65: goto st249
		case 92: goto st69
		case 97: goto st249
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st249:
	p++
	if p == pe { goto _test_eof249 }
	fallthrough
case 249:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 65: goto st250
		case 92: goto st69
		case 97: goto st250
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st250:
	p++
	if p == pe { goto _test_eof250 }
	fallthrough
case 250:
	switch data[p] {
		case 9: goto tr882
		case 10: goto tr883
		case 32: goto tr882
		case 40: goto tr884
		case 41: goto tr885
		case 43: goto st69
		case 59: goto tr886
		case 61: goto st69
		case 92: goto st69
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr889:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st251
tr890:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st251
tr5332:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr5334:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr5335:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr882:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr884:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr885:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr932:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr934:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr935:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr984:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr986:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr987:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr1686:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr1688:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr1689:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr2303:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr2305:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr2306:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr3719:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr3721:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr3722:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr3863:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr3865:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
tr3866:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st251
st251:
	p++
	if p == pe { goto _test_eof251 }
	fallthrough
case 251:
// line 16038 "zparse.go"
	switch data[p] {
		case 9: goto st251
		case 10: goto tr888
		case 32: goto st251
		case 40: goto tr889
		case 41: goto tr890
		case 43: goto tr86
		case 59: goto tr891
		case 61: goto tr86
		case 92: goto tr86
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr86 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr86 }
	} else {
		goto tr86
	}
	goto st0
tr888:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1728
tr893:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1728
tr5333:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1728
tr883:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1728
tr933:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1728
tr985:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1728
tr1687:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1728
tr2304:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1728
tr3720:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1728
tr3864:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1728
st1728:
	p++
	if p == pe { goto _test_eof1728 }
	fallthrough
case 1728:
// line 16288 "zparse.go"
	switch data[p] {
		case 9: goto st177
		case 10: goto tr643
		case 32: goto st177
		case 40: goto tr644
		case 41: goto tr645
		case 43: goto tr86
		case 47: goto tr86
		case 58: goto tr86
		case 59: goto tr647
		case 61: goto tr86
		case 92: goto tr5367
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto tr5367 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr5367 }
	} else {
		goto tr5367
	}
	goto st0
tr891:
// line 89 "zparse.rl"
	{ mark = p }
	goto st252
tr5336:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st252
tr886:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st252
tr936:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st252
tr988:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st252
tr1690:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st252
tr2307:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st252
tr3723:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st252
tr3867:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st252
st252:
	p++
	if p == pe { goto _test_eof252 }
	fallthrough
case 252:
// line 16519 "zparse.go"
	if data[p] == 10 { goto tr893 }
	goto st252
st253:
	p++
	if p == pe { goto _test_eof253 }
	fallthrough
case 253:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 89: goto st254
		case 92: goto st69
		case 121: goto st254
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st254:
	p++
	if p == pe { goto _test_eof254 }
	fallthrough
case 254:
	switch data[p] {
		case 9: goto tr895
		case 10: goto tr896
		case 32: goto tr895
		case 40: goto tr897
		case 41: goto tr898
		case 43: goto st69
		case 59: goto tr899
		case 61: goto st69
		case 92: goto st69
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr902:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st255
tr903:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st255
tr895:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st255
tr897:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st255
tr898:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st255
tr3574:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st255
tr3576:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st255
tr3577:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st255
tr3618:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st255
tr3620:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st255
tr3621:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st255
tr3725:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st255
tr3727:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st255
tr3728:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st255
tr3869:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st255
tr3871:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st255
tr3872:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st255
st255:
	p++
	if p == pe { goto _test_eof255 }
	fallthrough
case 255:
// line 16884 "zparse.go"
	switch data[p] {
		case 9: goto st255
		case 10: goto tr901
		case 32: goto st255
		case 40: goto tr902
		case 41: goto tr903
		case 59: goto tr904
		case 65: goto tr105
		case 67: goto tr106
		case 68: goto tr40
		case 77: goto tr43
		case 78: goto tr107
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr105
		case 99: goto tr106
		case 100: goto tr40
		case 109: goto tr43
		case 110: goto tr107
		case 114: goto tr45
		case 115: goto tr46
	}
	goto st0
tr901:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1729
tr3580:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1729
tr896:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1729
tr3575:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1729
tr3619:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1729
tr3726:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1729
tr3870:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1729
st1729:
	p++
	if p == pe { goto _test_eof1729 }
	fallthrough
case 1729:
// line 17026 "zparse.go"
	switch data[p] {
		case 9: goto st1
		case 10: goto tr2
		case 32: goto st1
		case 40: goto tr3
		case 41: goto tr4
		case 59: goto tr6
		case 65: goto tr5390
		case 67: goto tr5391
		case 68: goto tr5349
		case 77: goto tr5352
		case 78: goto tr5392
		case 82: goto tr5354
		case 83: goto tr5355
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5390
		case 99: goto tr5391
		case 100: goto tr5349
		case 109: goto tr5352
		case 110: goto tr5392
		case 114: goto tr5354
		case 115: goto tr5355
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr5390:
// line 89 "zparse.rl"
	{ mark = p }
	goto st256
st256:
	p++
	if p == pe { goto _test_eof256 }
	fallthrough
case 256:
// line 17072 "zparse.go"
	switch data[p] {
		case 9: goto tr526
		case 10: goto tr527
		case 32: goto tr526
		case 40: goto tr528
		case 41: goto tr529
		case 59: goto tr530
		case 65: goto st258
		case 92: goto st2
		case 95: goto st2
		case 97: goto st258
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr530:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st257
st257:
	p++
	if p == pe { goto _test_eof257 }
	fallthrough
case 257:
// line 17117 "zparse.go"
	if data[p] == 10 { goto tr534 }
	goto st257
st258:
	p++
	if p == pe { goto _test_eof258 }
	fallthrough
case 258:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 65: goto st259
		case 92: goto st2
		case 95: goto st2
		case 97: goto st259
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st259:
	p++
	if p == pe { goto _test_eof259 }
	fallthrough
case 259:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 65: goto st260
		case 92: goto st2
		case 95: goto st2
		case 97: goto st260
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st260:
	p++
	if p == pe { goto _test_eof260 }
	fallthrough
case 260:
	switch data[p] {
		case 9: goto tr907
		case 10: goto tr908
		case 32: goto tr907
		case 40: goto tr909
		case 41: goto tr910
		case 59: goto tr911
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr914:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st261
tr915:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st261
tr913:
// line 101 "zparse.rl"
	{ lines++ }
	goto st261
tr907:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st261
tr908:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st261
tr909:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st261
tr910:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st261
st261:
	p++
	if p == pe { goto _test_eof261 }
	fallthrough
case 261:
// line 17288 "zparse.go"
	switch data[p] {
		case 9: goto st261
		case 10: goto tr913
		case 32: goto st261
		case 40: goto tr914
		case 41: goto tr915
		case 43: goto tr86
		case 58: goto tr86
		case 59: goto st263
		case 61: goto tr86
		case 65: goto tr648
		case 67: goto tr649
		case 68: goto tr650
		case 72: goto tr651
		case 73: goto tr652
		case 77: goto tr653
		case 78: goto tr654
		case 82: goto tr655
		case 83: goto tr656
		case 92: goto tr86
		case 97: goto tr648
		case 99: goto tr649
		case 100: goto tr650
		case 104: goto tr651
		case 105: goto tr652
		case 109: goto tr653
		case 110: goto tr654
		case 114: goto tr655
		case 115: goto tr656
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr86 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr86 }
		} else if data[p] >= 66 {
			goto tr86
		}
	} else {
		goto tr646
	}
	goto st0
tr646:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st262
st262:
	p++
	if p == pe { goto _test_eof262 }
	fallthrough
case 262:
// line 17342 "zparse.go"
	switch data[p] {
		case 9: goto tr917
		case 10: goto tr918
		case 32: goto tr917
		case 40: goto tr919
		case 41: goto tr920
		case 43: goto st18
		case 58: goto st18
		case 59: goto tr922
		case 61: goto st18
		case 92: goto st18
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st18 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st18 }
		} else if data[p] >= 65 {
			goto st18
		}
	} else {
		goto st262
	}
	goto st0
tr911:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st263
st263:
	p++
	if p == pe { goto _test_eof263 }
	fallthrough
case 263:
// line 17387 "zparse.go"
	if data[p] == 10 { goto tr913 }
	goto st263
tr648:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st264
st264:
	p++
	if p == pe { goto _test_eof264 }
	fallthrough
case 264:
// line 17401 "zparse.go"
	switch data[p] {
		case 9: goto tr923
		case 10: goto tr924
		case 32: goto tr923
		case 40: goto tr925
		case 41: goto tr926
		case 43: goto st18
		case 59: goto tr927
		case 61: goto st18
		case 65: goto st265
		case 78: goto st268
		case 92: goto st18
		case 97: goto st265
		case 110: goto st268
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st265:
	p++
	if p == pe { goto _test_eof265 }
	fallthrough
case 265:
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 65: goto st266
		case 92: goto st18
		case 97: goto st266
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st266:
	p++
	if p == pe { goto _test_eof266 }
	fallthrough
case 266:
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 65: goto st267
		case 92: goto st18
		case 97: goto st267
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st267:
	p++
	if p == pe { goto _test_eof267 }
	fallthrough
case 267:
	switch data[p] {
		case 9: goto tr932
		case 10: goto tr933
		case 32: goto tr932
		case 40: goto tr934
		case 41: goto tr935
		case 43: goto st18
		case 59: goto tr936
		case 61: goto st18
		case 92: goto st18
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st268:
	p++
	if p == pe { goto _test_eof268 }
	fallthrough
case 268:
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 89: goto st269
		case 92: goto st18
		case 121: goto st269
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st269:
	p++
	if p == pe { goto _test_eof269 }
	fallthrough
case 269:
	switch data[p] {
		case 9: goto tr938
		case 10: goto tr939
		case 32: goto tr938
		case 40: goto tr940
		case 41: goto tr941
		case 43: goto st18
		case 59: goto tr942
		case 61: goto st18
		case 92: goto st18
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
tr945:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st270
tr946:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st270
tr1763:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st270
tr1765:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st270
tr1766:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st270
tr938:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st270
tr940:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st270
tr941:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st270
tr990:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st270
tr992:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st270
tr993:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st270
tr2309:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st270
tr2311:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st270
tr2312:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st270
tr2619:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st270
tr2621:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st270
tr2622:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st270
st270:
	p++
	if p == pe { goto _test_eof270 }
	fallthrough
case 270:
// line 17797 "zparse.go"
	switch data[p] {
		case 9: goto st270
		case 10: goto tr944
		case 32: goto st270
		case 40: goto tr945
		case 41: goto tr946
		case 59: goto tr947
		case 65: goto tr105
		case 67: goto tr106
		case 68: goto tr40
		case 77: goto tr43
		case 78: goto tr107
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr105
		case 99: goto tr106
		case 100: goto tr40
		case 109: goto tr43
		case 110: goto tr107
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr510 }
	goto st0
tr944:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1730
tr996:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1730
tr1764:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1730
tr939:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1730
tr991:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1730
tr2310:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1730
tr2620:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1730
st1730:
	p++
	if p == pe { goto _test_eof1730 }
	fallthrough
case 1730:
// line 17918 "zparse.go"
	switch data[p] {
		case 9: goto st1
		case 10: goto tr2
		case 32: goto st1
		case 40: goto tr3
		case 41: goto tr4
		case 59: goto tr6
		case 65: goto tr5390
		case 67: goto tr5391
		case 68: goto tr5349
		case 77: goto tr5352
		case 78: goto tr5392
		case 82: goto tr5354
		case 83: goto tr5355
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5390
		case 99: goto tr5391
		case 100: goto tr5349
		case 109: goto tr5352
		case 110: goto tr5392
		case 114: goto tr5354
		case 115: goto tr5355
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5393
	}
	goto st0
tr5391:
// line 89 "zparse.rl"
	{ mark = p }
	goto st271
st271:
	p++
	if p == pe { goto _test_eof271 }
	fallthrough
case 271:
// line 17964 "zparse.go"
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 78: goto st159
		case 92: goto st2
		case 95: goto st2
		case 110: goto st159
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr5392:
// line 89 "zparse.rl"
	{ mark = p }
	goto st272
st272:
	p++
	if p == pe { goto _test_eof272 }
	fallthrough
case 272:
// line 17998 "zparse.go"
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 83: goto st273
		case 92: goto st2
		case 95: goto st2
		case 115: goto st273
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st273:
	p++
	if p == pe { goto _test_eof273 }
	fallthrough
case 273:
	switch data[p] {
		case 9: goto tr949
		case 10: goto tr950
		case 32: goto tr949
		case 40: goto tr951
		case 41: goto tr952
		case 59: goto tr953
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr956:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st274
tr957:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st274
tr955:
// line 101 "zparse.rl"
	{ lines++ }
	goto st274
tr949:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st274
tr950:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st274
tr951:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st274
tr952:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st274
st274:
	p++
	if p == pe { goto _test_eof274 }
	fallthrough
case 274:
// line 18133 "zparse.go"
	switch data[p] {
		case 9: goto st274
		case 10: goto tr955
		case 32: goto st274
		case 40: goto tr956
		case 41: goto tr957
		case 43: goto tr281
		case 58: goto tr281
		case 59: goto st276
		case 61: goto tr281
		case 65: goto tr960
		case 67: goto tr961
		case 68: goto tr962
		case 72: goto tr963
		case 73: goto tr964
		case 77: goto tr965
		case 78: goto tr966
		case 82: goto tr967
		case 83: goto tr968
		case 92: goto tr281
		case 97: goto tr960
		case 99: goto tr961
		case 100: goto tr962
		case 104: goto tr963
		case 105: goto tr964
		case 109: goto tr965
		case 110: goto tr966
		case 114: goto tr967
		case 115: goto tr968
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr281 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr281 }
		} else if data[p] >= 66 {
			goto tr281
		}
	} else {
		goto tr958
	}
	goto st0
tr958:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st275
st275:
	p++
	if p == pe { goto _test_eof275 }
	fallthrough
case 275:
// line 18187 "zparse.go"
	switch data[p] {
		case 9: goto tr969
		case 10: goto tr970
		case 32: goto tr969
		case 40: goto tr971
		case 41: goto tr972
		case 43: goto st75
		case 58: goto st75
		case 59: goto tr974
		case 61: goto st75
		case 92: goto st75
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st75 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st75 }
		} else if data[p] >= 65 {
			goto st75
		}
	} else {
		goto st275
	}
	goto st0
tr953:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st276
st276:
	p++
	if p == pe { goto _test_eof276 }
	fallthrough
case 276:
// line 18232 "zparse.go"
	if data[p] == 10 { goto tr955 }
	goto st276
tr960:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st277
st277:
	p++
	if p == pe { goto _test_eof277 }
	fallthrough
case 277:
// line 18246 "zparse.go"
	switch data[p] {
		case 9: goto tr975
		case 10: goto tr976
		case 32: goto tr975
		case 40: goto tr977
		case 41: goto tr978
		case 43: goto st75
		case 59: goto tr979
		case 61: goto st75
		case 65: goto st278
		case 78: goto st281
		case 92: goto st75
		case 97: goto st278
		case 110: goto st281
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st278:
	p++
	if p == pe { goto _test_eof278 }
	fallthrough
case 278:
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 65: goto st279
		case 92: goto st75
		case 97: goto st279
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st279:
	p++
	if p == pe { goto _test_eof279 }
	fallthrough
case 279:
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 65: goto st280
		case 92: goto st75
		case 97: goto st280
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st280:
	p++
	if p == pe { goto _test_eof280 }
	fallthrough
case 280:
	switch data[p] {
		case 9: goto tr984
		case 10: goto tr985
		case 32: goto tr984
		case 40: goto tr986
		case 41: goto tr987
		case 43: goto st75
		case 59: goto tr988
		case 61: goto st75
		case 92: goto st75
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st281:
	p++
	if p == pe { goto _test_eof281 }
	fallthrough
case 281:
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 89: goto st282
		case 92: goto st75
		case 121: goto st282
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st282:
	p++
	if p == pe { goto _test_eof282 }
	fallthrough
case 282:
	switch data[p] {
		case 9: goto tr990
		case 10: goto tr991
		case 32: goto tr990
		case 40: goto tr992
		case 41: goto tr993
		case 43: goto st75
		case 59: goto tr994
		case 61: goto st75
		case 92: goto st75
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
tr947:
// line 89 "zparse.rl"
	{ mark = p }
	goto st283
tr1767:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st283
tr942:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st283
tr994:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st283
tr2313:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st283
tr2623:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st283
st283:
	p++
	if p == pe { goto _test_eof283 }
	fallthrough
case 283:
// line 18476 "zparse.go"
	if data[p] == 10 { goto tr996 }
	goto st283
tr961:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st284
st284:
	p++
	if p == pe { goto _test_eof284 }
	fallthrough
case 284:
// line 18490 "zparse.go"
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 72: goto st282
		case 78: goto st285
		case 83: goto st282
		case 92: goto st75
		case 104: goto st282
		case 110: goto st285
		case 115: goto st282
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st285:
	p++
	if p == pe { goto _test_eof285 }
	fallthrough
case 285:
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 65: goto st286
		case 92: goto st75
		case 97: goto st286
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st286:
	p++
	if p == pe { goto _test_eof286 }
	fallthrough
case 286:
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 77: goto st287
		case 92: goto st75
		case 109: goto st287
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st287:
	p++
	if p == pe { goto _test_eof287 }
	fallthrough
case 287:
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 69: goto st288
		case 92: goto st75
		case 101: goto st288
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st288:
	p++
	if p == pe { goto _test_eof288 }
	fallthrough
case 288:
	switch data[p] {
		case 9: goto tr1001
		case 10: goto tr1002
		case 32: goto tr1001
		case 40: goto tr1003
		case 41: goto tr1004
		case 43: goto st75
		case 59: goto tr1005
		case 61: goto st75
		case 92: goto st75
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
tr1008:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st289
tr1009:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st289
tr2627:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr2629:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr2630:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr1772:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr1774:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr1775:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr1001:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr1003:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr1004:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr1695:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr1697:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr1698:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr2318:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr2320:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr2321:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr2481:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr2483:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr2484:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr3734:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr3736:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr3737:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr3878:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr3880:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
tr3881:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st289
st289:
	p++
	if p == pe { goto _test_eof289 }
	fallthrough
case 289:
// line 19260 "zparse.go"
	switch data[p] {
		case 9: goto st289
		case 10: goto tr1007
		case 32: goto st289
		case 40: goto tr1008
		case 41: goto tr1009
		case 43: goto tr121
		case 59: goto tr1010
		case 61: goto tr121
		case 92: goto tr121
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr121 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr121 }
	} else {
		goto tr121
	}
	goto st0
tr1007:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1731
tr1012:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1731
tr2628:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1731
tr1773:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1731
tr1002:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1731
tr1696:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1731
tr2319:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1731
tr2482:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1731
tr3735:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1731
tr3879:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1731
st1731:
	p++
	if p == pe { goto _test_eof1731 }
	fallthrough
case 1731:
// line 19510 "zparse.go"
	switch data[p] {
		case 9: goto st192
		case 10: goto tr701
		case 32: goto st192
		case 40: goto tr702
		case 41: goto tr703
		case 43: goto tr121
		case 47: goto tr121
		case 58: goto tr121
		case 59: goto tr704
		case 61: goto tr121
		case 92: goto tr5378
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto tr5378 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr5378 }
	} else {
		goto tr5378
	}
	goto st0
tr1010:
// line 89 "zparse.rl"
	{ mark = p }
	goto st290
tr2631:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st290
tr1776:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st290
tr1005:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st290
tr1699:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st290
tr2322:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st290
tr2485:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st290
tr3738:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st290
tr3882:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st290
st290:
	p++
	if p == pe { goto _test_eof290 }
	fallthrough
case 290:
// line 19741 "zparse.go"
	if data[p] == 10 { goto tr1012 }
	goto st290
tr962:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st291
st291:
	p++
	if p == pe { goto _test_eof291 }
	fallthrough
case 291:
// line 19755 "zparse.go"
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 78: goto st292
		case 83: goto st300
		case 92: goto st75
		case 110: goto st292
		case 115: goto st300
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st292:
	p++
	if p == pe { goto _test_eof292 }
	fallthrough
case 292:
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 83: goto st293
		case 92: goto st75
		case 115: goto st293
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st293:
	p++
	if p == pe { goto _test_eof293 }
	fallthrough
case 293:
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 75: goto st294
		case 92: goto st75
		case 107: goto st294
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st294:
	p++
	if p == pe { goto _test_eof294 }
	fallthrough
case 294:
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 69: goto st295
		case 92: goto st75
		case 101: goto st295
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st295:
	p++
	if p == pe { goto _test_eof295 }
	fallthrough
case 295:
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 89: goto st296
		case 92: goto st75
		case 121: goto st296
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st296:
	p++
	if p == pe { goto _test_eof296 }
	fallthrough
case 296:
	switch data[p] {
		case 9: goto tr1019
		case 10: goto tr1020
		case 32: goto tr1019
		case 40: goto tr1021
		case 41: goto tr1022
		case 43: goto st75
		case 59: goto tr1023
		case 61: goto st75
		case 92: goto st75
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
tr1026:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st297
tr1027:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st297
tr1019:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr1021:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr1022:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr1706:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr1708:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr1709:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr1783:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr1785:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr1786:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr2329:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr2331:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr2332:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr2492:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr2494:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr2495:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr2638:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr2640:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr2641:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr3745:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr3747:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr3748:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr3889:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr3891:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
tr3892:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st297
st297:
	p++
	if p == pe { goto _test_eof297 }
	fallthrough
case 297:
// line 20549 "zparse.go"
	switch data[p] {
		case 9: goto st297
		case 10: goto tr1025
		case 32: goto st297
		case 40: goto tr1026
		case 41: goto tr1027
		case 59: goto tr1028
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr144 }
	goto st0
tr1025:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1732
tr1036:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1732
tr1020:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1732
tr1707:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1732
tr1784:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1732
tr2330:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1732
tr2493:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1732
tr2639:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1732
tr3746:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1732
tr3890:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1732
st1732:
	p++
	if p == pe { goto _test_eof1732 }
	fallthrough
case 1732:
// line 20790 "zparse.go"
	switch data[p] {
		case 9: goto st213
		case 10: goto tr760
		case 32: goto st213
		case 40: goto tr761
		case 41: goto tr762
		case 59: goto tr764
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5394
	}
	goto st0
tr5394:
// line 89 "zparse.rl"
	{ mark = p }
	goto st298
st298:
	p++
	if p == pe { goto _test_eof298 }
	fallthrough
case 298:
// line 20822 "zparse.go"
	switch data[p] {
		case 9: goto tr1029
		case 10: goto tr1030
		case 32: goto tr1029
		case 40: goto tr1031
		case 41: goto tr1032
		case 59: goto tr1034
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st298
	}
	goto st0
tr1028:
// line 89 "zparse.rl"
	{ mark = p }
	goto st299
tr1023:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st299
tr1710:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st299
tr1787:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st299
tr2333:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st299
tr2496:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st299
tr2642:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st299
tr3749:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st299
tr3893:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st299
st299:
	p++
	if p == pe { goto _test_eof299 }
	fallthrough
case 299:
// line 21053 "zparse.go"
	if data[p] == 10 { goto tr1036 }
	goto st299
st300:
	p++
	if p == pe { goto _test_eof300 }
	fallthrough
case 300:
	switch data[p] {
		case 9: goto tr1037
		case 10: goto tr1038
		case 32: goto tr1037
		case 40: goto tr1039
		case 41: goto tr1040
		case 43: goto st75
		case 59: goto tr1041
		case 61: goto st75
		case 92: goto st75
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
tr1044:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st301
tr1045:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st301
tr1037:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr1039:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr1040:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr1711:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr1713:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr1714:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr1788:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr1790:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr1791:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr2334:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr2336:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr2337:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr2497:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr2499:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr2500:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr2643:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr2645:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr2646:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr3750:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr3752:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr3753:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr3894:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr3896:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
tr3897:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st301
st301:
	p++
	if p == pe { goto _test_eof301 }
	fallthrough
case 301:
// line 21722 "zparse.go"
	switch data[p] {
		case 9: goto st301
		case 10: goto tr1043
		case 32: goto st301
		case 40: goto tr1044
		case 41: goto tr1045
		case 59: goto tr1046
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr197 }
	goto st0
tr1043:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1733
tr1717:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1733
tr1038:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1733
tr1712:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1733
tr1789:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1733
tr2335:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1733
tr2498:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1733
tr2644:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1733
tr3751:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1733
tr3895:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1733
st1733:
	p++
	if p == pe { goto _test_eof1733 }
	fallthrough
case 1733:
// line 21963 "zparse.go"
	switch data[p] {
		case 9: goto st302
		case 10: goto tr1048
		case 32: goto st302
		case 40: goto tr1049
		case 41: goto tr1050
		case 59: goto tr1051
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5395
	}
	goto st0
tr1049:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st302
tr1050:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st302
tr2246:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st302
tr2248:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st302
tr2249:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st302
tr2436:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st302
tr2438:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st302
tr2439:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st302
tr5325:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st302
tr5327:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st302
tr5328:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st302
tr1873:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st302
tr1875:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st302
tr1876:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st302
tr4021:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st302
tr4023:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st302
tr4024:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st302
st302:
	p++
	if p == pe { goto _test_eof302 }
	fallthrough
case 302:
// line 22397 "zparse.go"
	switch data[p] {
		case 9: goto st302
		case 10: goto tr1048
		case 32: goto st302
		case 40: goto tr1049
		case 41: goto tr1050
		case 59: goto tr1051
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr826 }
	goto st0
tr1048:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1734
tr1076:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1734
tr2247:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1734
tr2437:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1734
tr5326:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1734
tr1874:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1734
tr4022:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1734
st1734:
	p++
	if p == pe { goto _test_eof1734 }
	fallthrough
case 1734:
// line 22577 "zparse.go"
	switch data[p] {
		case 9: goto st302
		case 10: goto tr1048
		case 32: goto st302
		case 40: goto tr1049
		case 41: goto tr1050
		case 59: goto tr1051
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5396
	}
	goto st0
tr5396:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st303
st303:
	p++
	if p == pe { goto _test_eof303 }
	fallthrough
case 303:
// line 22629 "zparse.go"
	switch data[p] {
		case 9: goto tr1052
		case 10: goto tr1053
		case 32: goto tr1052
		case 40: goto tr1054
		case 41: goto tr1055
		case 59: goto tr1057
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st303
	}
	goto st0
tr1060:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st304
tr1061:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st304
tr1059:
// line 101 "zparse.rl"
	{ lines++ }
	goto st304
tr1052:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st304
tr1053:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st304
tr1054:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st304
tr1055:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st304
tr5319:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st304
tr5320:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st304
tr5321:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st304
tr5322:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st304
st304:
	p++
	if p == pe { goto _test_eof304 }
	fallthrough
case 304:
// line 22737 "zparse.go"
	switch data[p] {
		case 9: goto st304
		case 10: goto tr1059
		case 32: goto st304
		case 40: goto tr1060
		case 41: goto tr1061
		case 59: goto st308
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1062 }
	goto st0
tr1062:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st305
st305:
	p++
	if p == pe { goto _test_eof305 }
	fallthrough
case 305:
// line 22777 "zparse.go"
	switch data[p] {
		case 9: goto tr1064
		case 10: goto tr1065
		case 32: goto tr1064
		case 40: goto tr1066
		case 41: goto tr1067
		case 59: goto tr1069
	}
	if 48 <= data[p] && data[p] <= 57 { goto st305 }
	goto st0
tr1072:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st306
tr1073:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st306
tr1071:
// line 101 "zparse.rl"
	{ lines++ }
	goto st306
tr1064:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st306
tr1065:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st306
tr1066:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st306
tr1067:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st306
st306:
	p++
	if p == pe { goto _test_eof306 }
	fallthrough
case 306:
// line 22835 "zparse.go"
	switch data[p] {
		case 9: goto st306
		case 10: goto tr1071
		case 32: goto st306
		case 40: goto tr1072
		case 41: goto tr1073
		case 59: goto st307
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr221 }
	goto st0
tr1069:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st307
st307:
	p++
	if p == pe { goto _test_eof307 }
	fallthrough
case 307:
// line 22875 "zparse.go"
	if data[p] == 10 { goto tr1071 }
	goto st307
tr1057:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st308
tr5324:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st308
st308:
	p++
	if p == pe { goto _test_eof308 }
	fallthrough
case 308:
// line 22897 "zparse.go"
	if data[p] == 10 { goto tr1059 }
	goto st308
tr1051:
// line 89 "zparse.rl"
	{ mark = p }
	goto st309
tr2250:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st309
tr2440:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st309
tr5329:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st309
tr1877:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st309
tr4025:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st309
st309:
	p++
	if p == pe { goto _test_eof309 }
	fallthrough
case 309:
// line 23035 "zparse.go"
	if data[p] == 10 { goto tr1076 }
	goto st309
tr5344:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st310
tr5353:
// line 89 "zparse.rl"
	{ mark = p }
	goto st310
st310:
	p++
	if p == pe { goto _test_eof310 }
	fallthrough
case 310:
// line 23053 "zparse.go"
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 79: goto st311
		case 83: goto st273
		case 92: goto st2
		case 95: goto st2
		case 111: goto st311
		case 115: goto st273
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st311:
	p++
	if p == pe { goto _test_eof311 }
	fallthrough
case 311:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 78: goto st312
		case 92: goto st2
		case 95: goto st2
		case 110: goto st312
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st312:
	p++
	if p == pe { goto _test_eof312 }
	fallthrough
case 312:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 69: goto st158
		case 92: goto st2
		case 95: goto st2
		case 101: goto st158
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr5345:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st313
tr5354:
// line 89 "zparse.rl"
	{ mark = p }
	goto st313
st313:
	p++
	if p == pe { goto _test_eof313 }
	fallthrough
case 313:
// line 23153 "zparse.go"
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 82: goto st314
		case 92: goto st2
		case 95: goto st2
		case 114: goto st314
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st314:
	p++
	if p == pe { goto _test_eof314 }
	fallthrough
case 314:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 83: goto st315
		case 92: goto st2
		case 95: goto st2
		case 115: goto st315
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st315:
	p++
	if p == pe { goto _test_eof315 }
	fallthrough
case 315:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 73: goto st316
		case 92: goto st2
		case 95: goto st2
		case 105: goto st316
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st316:
	p++
	if p == pe { goto _test_eof316 }
	fallthrough
case 316:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 71: goto st317
		case 92: goto st2
		case 95: goto st2
		case 103: goto st317
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st317:
	p++
	if p == pe { goto _test_eof317 }
	fallthrough
case 317:
	switch data[p] {
		case 9: goto tr1083
		case 10: goto tr1084
		case 32: goto tr1083
		case 40: goto tr1085
		case 41: goto tr1086
		case 59: goto tr1087
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr1090:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st318
tr1091:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st318
tr1089:
// line 101 "zparse.rl"
	{ lines++ }
	goto st318
tr1083:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st318
tr1084:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st318
tr1085:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st318
tr1086:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st318
st318:
	p++
	if p == pe { goto _test_eof318 }
	fallthrough
case 318:
// line 23375 "zparse.go"
	switch data[p] {
		case 9: goto st318
		case 10: goto tr1089
		case 32: goto st318
		case 40: goto tr1090
		case 41: goto tr1091
		case 59: goto st322
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1092 }
	goto st0
tr1092:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st319
st319:
	p++
	if p == pe { goto _test_eof319 }
	fallthrough
case 319:
// line 23415 "zparse.go"
	switch data[p] {
		case 9: goto tr1094
		case 10: goto tr1095
		case 32: goto tr1094
		case 40: goto tr1096
		case 41: goto tr1097
		case 59: goto tr1099
	}
	if 48 <= data[p] && data[p] <= 57 { goto st319 }
	goto st0
tr1102:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st320
tr1103:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st320
tr1101:
// line 101 "zparse.rl"
	{ lines++ }
	goto st320
tr1094:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st320
tr1095:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st320
tr1096:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st320
tr1097:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st320
st320:
	p++
	if p == pe { goto _test_eof320 }
	fallthrough
case 320:
// line 23473 "zparse.go"
	switch data[p] {
		case 9: goto st320
		case 10: goto tr1101
		case 32: goto st320
		case 40: goto tr1102
		case 41: goto tr1103
		case 59: goto st321
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr314 }
	goto st0
tr1099:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st321
st321:
	p++
	if p == pe { goto _test_eof321 }
	fallthrough
case 321:
// line 23513 "zparse.go"
	if data[p] == 10 { goto tr1101 }
	goto st321
tr1087:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st322
st322:
	p++
	if p == pe { goto _test_eof322 }
	fallthrough
case 322:
// line 23536 "zparse.go"
	if data[p] == 10 { goto tr1089 }
	goto st322
tr5346:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st323
tr5355:
// line 89 "zparse.rl"
	{ mark = p }
	goto st323
st323:
	p++
	if p == pe { goto _test_eof323 }
	fallthrough
case 323:
// line 23554 "zparse.go"
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 79: goto st324
		case 92: goto st2
		case 95: goto st2
		case 111: goto st324
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st324:
	p++
	if p == pe { goto _test_eof324 }
	fallthrough
case 324:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 65: goto st325
		case 92: goto st2
		case 95: goto st2
		case 97: goto st325
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
st325:
	p++
	if p == pe { goto _test_eof325 }
	fallthrough
case 325:
	switch data[p] {
		case 9: goto tr1107
		case 10: goto tr1108
		case 32: goto tr1107
		case 40: goto tr1109
		case 41: goto tr1110
		case 59: goto tr1111
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
tr1114:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st326
tr1115:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st326
tr1113:
// line 101 "zparse.rl"
	{ lines++ }
	goto st326
tr1107:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st326
tr1108:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st326
tr1109:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st326
tr1110:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st326
st326:
	p++
	if p == pe { goto _test_eof326 }
	fallthrough
case 326:
// line 23718 "zparse.go"
	switch data[p] {
		case 9: goto st326
		case 10: goto tr1113
		case 32: goto st326
		case 40: goto tr1114
		case 41: goto tr1115
		case 43: goto tr417
		case 58: goto tr417
		case 59: goto st1709
		case 61: goto tr417
		case 65: goto tr1118
		case 67: goto tr1119
		case 68: goto tr1120
		case 72: goto tr1121
		case 73: goto tr1122
		case 77: goto tr1123
		case 78: goto tr1124
		case 82: goto tr1125
		case 83: goto tr1126
		case 92: goto tr417
		case 97: goto tr1118
		case 99: goto tr1119
		case 100: goto tr1120
		case 104: goto tr1121
		case 105: goto tr1122
		case 109: goto tr1123
		case 110: goto tr1124
		case 114: goto tr1125
		case 115: goto tr1126
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr417 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr417 }
		} else if data[p] >= 66 {
			goto tr417
		}
	} else {
		goto tr1116
	}
	goto st0
tr1116:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st327
st327:
	p++
	if p == pe { goto _test_eof327 }
	fallthrough
case 327:
// line 23772 "zparse.go"
	switch data[p] {
		case 9: goto tr1127
		case 10: goto tr1128
		case 32: goto tr1127
		case 40: goto tr1129
		case 41: goto tr1130
		case 43: goto st113
		case 58: goto st113
		case 59: goto tr1132
		case 61: goto st113
		case 92: goto st113
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st113 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st113 }
		} else if data[p] >= 65 {
			goto st113
		}
	} else {
		goto st327
	}
	goto st0
tr1135:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st328
tr1136:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st328
tr1134:
// line 101 "zparse.rl"
	{ lines++ }
	goto st328
tr1127:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st328
tr1128:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st328
tr1129:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st328
tr1130:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st328
st328:
	p++
	if p == pe { goto _test_eof328 }
	fallthrough
case 328:
// line 23844 "zparse.go"
	switch data[p] {
		case 9: goto st328
		case 10: goto tr1134
		case 32: goto st328
		case 40: goto tr1135
		case 41: goto tr1136
		case 43: goto tr429
		case 59: goto st329
		case 61: goto tr429
		case 65: goto tr1138
		case 67: goto tr1139
		case 68: goto tr1140
		case 72: goto tr1141
		case 73: goto tr1142
		case 77: goto tr1143
		case 78: goto tr1144
		case 82: goto tr1145
		case 83: goto tr1146
		case 92: goto tr429
		case 97: goto tr1138
		case 99: goto tr1139
		case 100: goto tr1140
		case 104: goto tr1141
		case 105: goto tr1142
		case 109: goto tr1143
		case 110: goto tr1144
		case 114: goto tr1145
		case 115: goto tr1146
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto tr429 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto tr429 }
	} else {
		goto tr429
	}
	goto st0
tr1132:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st329
st329:
	p++
	if p == pe { goto _test_eof329 }
	fallthrough
case 329:
// line 23893 "zparse.go"
	if data[p] == 10 { goto tr1134 }
	goto st329
tr1138:
// line 89 "zparse.rl"
	{ mark = p }
	goto st330
st330:
	p++
	if p == pe { goto _test_eof330 }
	fallthrough
case 330:
// line 23905 "zparse.go"
	switch data[p] {
		case 9: goto tr1147
		case 10: goto tr1148
		case 32: goto tr1147
		case 40: goto tr1149
		case 41: goto tr1150
		case 43: goto st115
		case 59: goto tr1151
		case 61: goto st115
		case 65: goto st348
		case 78: goto st354
		case 92: goto st115
		case 97: goto st348
		case 110: goto st354
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1156:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st331
tr1157:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st331
tr1155:
// line 101 "zparse.rl"
	{ lines++ }
	goto st331
tr1147:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st331
tr1148:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st331
tr1149:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st331
tr1150:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st331
st331:
	p++
	if p == pe { goto _test_eof331 }
	fallthrough
case 331:
// line 24012 "zparse.go"
	switch data[p] {
		case 9: goto st331
		case 10: goto tr1155
		case 32: goto st331
		case 40: goto tr1156
		case 41: goto tr1157
		case 43: goto tr58
		case 58: goto tr58
		case 59: goto st347
		case 61: goto tr58
		case 92: goto tr58
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr58 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr58 }
		} else if data[p] >= 65 {
			goto tr58
		}
	} else {
		goto tr1158
	}
	goto st0
tr1158:
// line 89 "zparse.rl"
	{ mark = p }
	goto st332
st332:
	p++
	if p == pe { goto _test_eof332 }
	fallthrough
case 332:
// line 24046 "zparse.go"
	switch data[p] {
		case 9: goto tr1160
		case 10: goto tr1161
		case 32: goto tr1160
		case 40: goto tr1162
		case 41: goto tr1163
		case 43: goto st9
		case 58: goto st9
		case 59: goto tr1165
		case 61: goto st9
		case 92: goto st9
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st9 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st9 }
		} else if data[p] >= 65 {
			goto st9
		}
	} else {
		goto st332
	}
	goto st0
tr1168:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st333
tr1169:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st333
tr1160:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st333
tr1162:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st333
tr1163:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st333
tr1234:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st333
tr1236:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st333
tr1237:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st333
tr1266:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st333
tr1268:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st333
tr1269:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st333
tr3327:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st333
tr3329:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st333
tr3330:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st333
tr1504:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st333
tr1506:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st333
tr1507:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st333
st333:
	p++
	if p == pe { goto _test_eof333 }
	fallthrough
case 333:
// line 24317 "zparse.go"
	switch data[p] {
		case 9: goto st333
		case 10: goto tr1167
		case 32: goto st333
		case 40: goto tr1168
		case 41: goto tr1169
		case 59: goto tr1170
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr453 }
	goto st0
tr1167:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1735
tr1220:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1735
tr1161:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1735
tr1235:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1735
tr1267:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1735
tr3328:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1735
tr1505:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1735
st1735:
	p++
	if p == pe { goto _test_eof1735 }
	fallthrough
case 1735:
// line 24424 "zparse.go"
	switch data[p] {
		case 9: goto st334
		case 10: goto tr1172
		case 32: goto st334
		case 40: goto tr1173
		case 41: goto tr1174
		case 59: goto tr1176
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5397
	}
	goto st0
tr1173:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st334
tr1174:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st334
tr2212:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2214:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2215:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2391:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2393:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2394:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2417:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2419:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2420:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2532:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2534:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2535:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2573:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2575:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2576:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2678:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2680:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2681:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2912:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2914:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2915:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2956:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2958:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
tr2959:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st334
st334:
	p++
	if p == pe { goto _test_eof334 }
	fallthrough
case 334:
// line 24900 "zparse.go"
	switch data[p] {
		case 9: goto st334
		case 10: goto tr1172
		case 32: goto st334
		case 40: goto tr1173
		case 41: goto tr1174
		case 59: goto tr1176
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1175 }
	goto st0
tr1172:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1736
tr1201:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1736
tr2213:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1736
tr2392:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1736
tr2418:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1736
tr2533:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1736
tr2574:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1736
tr2679:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1736
tr2913:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1736
tr2957:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1736
st1736:
	p++
	if p == pe { goto _test_eof1736 }
	fallthrough
case 1736:
// line 25096 "zparse.go"
	switch data[p] {
		case 9: goto st334
		case 10: goto tr1172
		case 32: goto st334
		case 40: goto tr1173
		case 41: goto tr1174
		case 59: goto tr1176
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5398
	}
	goto st0
tr5398:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st335
st335:
	p++
	if p == pe { goto _test_eof335 }
	fallthrough
case 335:
// line 25148 "zparse.go"
	switch data[p] {
		case 9: goto tr1177
		case 10: goto tr1178
		case 32: goto tr1177
		case 40: goto tr1179
		case 41: goto tr1180
		case 59: goto tr1182
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st335
	}
	goto st0
tr1185:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st336
tr1186:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st336
tr1184:
// line 101 "zparse.rl"
	{ lines++ }
	goto st336
tr1177:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st336
tr1178:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st336
tr1179:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st336
tr1180:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st336
tr1213:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st336
tr1214:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st336
tr1215:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st336
tr1216:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st336
st336:
	p++
	if p == pe { goto _test_eof336 }
	fallthrough
case 336:
// line 25256 "zparse.go"
	switch data[p] {
		case 9: goto st336
		case 10: goto tr1184
		case 32: goto st336
		case 40: goto tr1185
		case 41: goto tr1186
		case 59: goto st340
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1187 }
	goto st0
tr1187:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st337
st337:
	p++
	if p == pe { goto _test_eof337 }
	fallthrough
case 337:
// line 25296 "zparse.go"
	switch data[p] {
		case 9: goto tr1189
		case 10: goto tr1190
		case 32: goto tr1189
		case 40: goto tr1191
		case 41: goto tr1192
		case 59: goto tr1194
	}
	if 48 <= data[p] && data[p] <= 57 { goto st337 }
	goto st0
tr1197:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st338
tr1198:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st338
tr1196:
// line 101 "zparse.rl"
	{ lines++ }
	goto st338
tr1189:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st338
tr1190:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st338
tr1191:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st338
tr1192:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st338
st338:
	p++
	if p == pe { goto _test_eof338 }
	fallthrough
case 338:
// line 25354 "zparse.go"
	switch data[p] {
		case 9: goto st338
		case 10: goto tr1196
		case 32: goto st338
		case 40: goto tr1197
		case 41: goto tr1198
		case 59: goto st339
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr477 }
	goto st0
tr1194:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st339
st339:
	p++
	if p == pe { goto _test_eof339 }
	fallthrough
case 339:
// line 25394 "zparse.go"
	if data[p] == 10 { goto tr1196 }
	goto st339
tr1182:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st340
tr1218:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st340
st340:
	p++
	if p == pe { goto _test_eof340 }
	fallthrough
case 340:
// line 25416 "zparse.go"
	if data[p] == 10 { goto tr1184 }
	goto st340
tr1176:
// line 89 "zparse.rl"
	{ mark = p }
	goto st341
tr2217:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st341
tr2396:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st341
tr2422:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st341
tr2537:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st341
tr2578:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st341
tr2683:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st341
tr2917:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st341
tr2961:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st341
st341:
	p++
	if p == pe { goto _test_eof341 }
	fallthrough
case 341:
// line 25564 "zparse.go"
	if data[p] == 10 { goto tr1201 }
	goto st341
tr1175:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st342
st342:
	p++
	if p == pe { goto _test_eof342 }
	fallthrough
case 342:
// line 25578 "zparse.go"
	switch data[p] {
		case 9: goto tr1202
		case 10: goto tr1203
		case 32: goto tr1202
		case 40: goto tr1204
		case 41: goto tr1205
		case 59: goto tr1207
	}
	if 48 <= data[p] && data[p] <= 57 { goto st342 }
	goto st0
tr1210:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st343
tr1211:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st343
tr1209:
// line 101 "zparse.rl"
	{ lines++ }
	goto st343
tr1202:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st343
tr1203:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st343
tr1204:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st343
tr1205:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st343
st343:
	p++
	if p == pe { goto _test_eof343 }
	fallthrough
case 343:
// line 25636 "zparse.go"
	switch data[p] {
		case 9: goto st343
		case 10: goto tr1209
		case 32: goto st343
		case 40: goto tr1210
		case 41: goto tr1211
		case 59: goto st344
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr465 }
	goto st0
tr1207:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st344
st344:
	p++
	if p == pe { goto _test_eof344 }
	fallthrough
case 344:
// line 25676 "zparse.go"
	if data[p] == 10 { goto tr1209 }
	goto st344
tr5397:
// line 89 "zparse.rl"
	{ mark = p }
	goto st345
st345:
	p++
	if p == pe { goto _test_eof345 }
	fallthrough
case 345:
// line 25688 "zparse.go"
	switch data[p] {
		case 9: goto tr1213
		case 10: goto tr1214
		case 32: goto tr1213
		case 40: goto tr1215
		case 41: goto tr1216
		case 59: goto tr1218
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st345
	}
	goto st0
tr1170:
// line 89 "zparse.rl"
	{ mark = p }
	goto st346
tr1165:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st346
tr1239:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st346
tr1271:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st346
tr3332:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st346
tr1509:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st346
st346:
	p++
	if p == pe { goto _test_eof346 }
	fallthrough
case 346:
// line 25791 "zparse.go"
	if data[p] == 10 { goto tr1220 }
	goto st346
tr1151:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st347
st347:
	p++
	if p == pe { goto _test_eof347 }
	fallthrough
case 347:
// line 25814 "zparse.go"
	if data[p] == 10 { goto tr1155 }
	goto st347
st348:
	p++
	if p == pe { goto _test_eof348 }
	fallthrough
case 348:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 65: goto st349
		case 92: goto st115
		case 97: goto st349
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st349:
	p++
	if p == pe { goto _test_eof349 }
	fallthrough
case 349:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 65: goto st350
		case 92: goto st115
		case 97: goto st350
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st350:
	p++
	if p == pe { goto _test_eof350 }
	fallthrough
case 350:
	switch data[p] {
		case 9: goto tr1223
		case 10: goto tr1224
		case 32: goto tr1223
		case 40: goto tr1225
		case 41: goto tr1226
		case 43: goto st115
		case 59: goto tr1227
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1230:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st351
tr1231:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st351
tr1229:
// line 101 "zparse.rl"
	{ lines++ }
	goto st351
tr1223:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st351
tr1224:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st351
tr1225:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st351
tr1226:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st351
st351:
	p++
	if p == pe { goto _test_eof351 }
	fallthrough
case 351:
// line 25976 "zparse.go"
	switch data[p] {
		case 9: goto st351
		case 10: goto tr1229
		case 32: goto st351
		case 40: goto tr1230
		case 41: goto tr1231
		case 43: goto tr86
		case 58: goto tr86
		case 59: goto st353
		case 61: goto tr86
		case 92: goto tr86
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr86 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr86 }
		} else if data[p] >= 65 {
			goto tr86
		}
	} else {
		goto tr1232
	}
	goto st0
tr1232:
// line 89 "zparse.rl"
	{ mark = p }
	goto st352
st352:
	p++
	if p == pe { goto _test_eof352 }
	fallthrough
case 352:
// line 26010 "zparse.go"
	switch data[p] {
		case 9: goto tr1234
		case 10: goto tr1235
		case 32: goto tr1234
		case 40: goto tr1236
		case 41: goto tr1237
		case 43: goto st18
		case 58: goto st18
		case 59: goto tr1239
		case 61: goto st18
		case 92: goto st18
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st18 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st18 }
		} else if data[p] >= 65 {
			goto st18
		}
	} else {
		goto st352
	}
	goto st0
tr1227:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st353
st353:
	p++
	if p == pe { goto _test_eof353 }
	fallthrough
case 353:
// line 26055 "zparse.go"
	if data[p] == 10 { goto tr1229 }
	goto st353
st354:
	p++
	if p == pe { goto _test_eof354 }
	fallthrough
case 354:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 89: goto st355
		case 92: goto st115
		case 121: goto st355
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st355:
	p++
	if p == pe { goto _test_eof355 }
	fallthrough
case 355:
	switch data[p] {
		case 9: goto tr1241
		case 10: goto tr1242
		case 32: goto tr1241
		case 40: goto tr1243
		case 41: goto tr1244
		case 43: goto st115
		case 59: goto tr1245
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1248:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st356
tr1249:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st356
tr1247:
// line 101 "zparse.rl"
	{ lines++ }
	goto st356
tr4367:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st356
tr4368:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st356
tr4369:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st356
tr4370:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st356
tr1241:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st356
tr1242:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st356
tr1243:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st356
tr1244:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st356
st356:
	p++
	if p == pe { goto _test_eof356 }
	fallthrough
case 356:
// line 26185 "zparse.go"
	switch data[p] {
		case 9: goto st356
		case 10: goto tr1247
		case 32: goto st356
		case 40: goto tr1248
		case 41: goto tr1249
		case 59: goto st357
		case 65: goto tr105
		case 67: goto tr106
		case 68: goto tr40
		case 77: goto tr43
		case 78: goto tr107
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr105
		case 99: goto tr106
		case 100: goto tr40
		case 109: goto tr43
		case 110: goto tr107
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr441 }
	goto st0
tr4372:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st357
tr1245:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st357
st357:
	p++
	if p == pe { goto _test_eof357 }
	fallthrough
case 357:
// line 26227 "zparse.go"
	if data[p] == 10 { goto tr1247 }
	goto st357
tr1139:
// line 89 "zparse.rl"
	{ mark = p }
	goto st358
st358:
	p++
	if p == pe { goto _test_eof358 }
	fallthrough
case 358:
// line 26239 "zparse.go"
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 72: goto st355
		case 78: goto st359
		case 83: goto st355
		case 92: goto st115
		case 104: goto st355
		case 110: goto st359
		case 115: goto st355
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st359:
	p++
	if p == pe { goto _test_eof359 }
	fallthrough
case 359:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 65: goto st360
		case 92: goto st115
		case 97: goto st360
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st360:
	p++
	if p == pe { goto _test_eof360 }
	fallthrough
case 360:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 77: goto st361
		case 92: goto st115
		case 109: goto st361
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st361:
	p++
	if p == pe { goto _test_eof361 }
	fallthrough
case 361:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 69: goto st362
		case 92: goto st115
		case 101: goto st362
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st362:
	p++
	if p == pe { goto _test_eof362 }
	fallthrough
case 362:
	switch data[p] {
		case 9: goto tr1255
		case 10: goto tr1256
		case 32: goto tr1255
		case 40: goto tr1257
		case 41: goto tr1258
		case 43: goto st115
		case 59: goto tr1259
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1262:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st363
tr1263:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st363
tr1261:
// line 101 "zparse.rl"
	{ lines++ }
	goto st363
tr1255:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st363
tr1256:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st363
tr1257:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st363
tr1258:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st363
st363:
	p++
	if p == pe { goto _test_eof363 }
	fallthrough
case 363:
// line 26450 "zparse.go"
	switch data[p] {
		case 9: goto st363
		case 10: goto tr1261
		case 32: goto st363
		case 40: goto tr1262
		case 41: goto tr1263
		case 43: goto tr121
		case 58: goto tr121
		case 59: goto st365
		case 61: goto tr121
		case 92: goto tr121
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr121 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr121 }
		} else if data[p] >= 65 {
			goto tr121
		}
	} else {
		goto tr1264
	}
	goto st0
tr1264:
// line 89 "zparse.rl"
	{ mark = p }
	goto st364
st364:
	p++
	if p == pe { goto _test_eof364 }
	fallthrough
case 364:
// line 26484 "zparse.go"
	switch data[p] {
		case 9: goto tr1266
		case 10: goto tr1267
		case 32: goto tr1266
		case 40: goto tr1268
		case 41: goto tr1269
		case 43: goto st31
		case 58: goto st31
		case 59: goto tr1271
		case 61: goto st31
		case 92: goto st31
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st31 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st31 }
		} else if data[p] >= 65 {
			goto st31
		}
	} else {
		goto st364
	}
	goto st0
tr1259:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st365
st365:
	p++
	if p == pe { goto _test_eof365 }
	fallthrough
case 365:
// line 26529 "zparse.go"
	if data[p] == 10 { goto tr1261 }
	goto st365
tr1959:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st366
tr1140:
// line 89 "zparse.rl"
	{ mark = p }
	goto st366
st366:
	p++
	if p == pe { goto _test_eof366 }
	fallthrough
case 366:
// line 26547 "zparse.go"
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 78: goto st367
		case 83: goto st391
		case 92: goto st115
		case 110: goto st367
		case 115: goto st391
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st367:
	p++
	if p == pe { goto _test_eof367 }
	fallthrough
case 367:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 83: goto st368
		case 92: goto st115
		case 115: goto st368
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st368:
	p++
	if p == pe { goto _test_eof368 }
	fallthrough
case 368:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 75: goto st369
		case 92: goto st115
		case 107: goto st369
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st369:
	p++
	if p == pe { goto _test_eof369 }
	fallthrough
case 369:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 69: goto st370
		case 92: goto st115
		case 101: goto st370
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st370:
	p++
	if p == pe { goto _test_eof370 }
	fallthrough
case 370:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 89: goto st371
		case 92: goto st115
		case 121: goto st371
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st371:
	p++
	if p == pe { goto _test_eof371 }
	fallthrough
case 371:
	switch data[p] {
		case 9: goto tr1278
		case 10: goto tr1279
		case 32: goto tr1278
		case 40: goto tr1280
		case 41: goto tr1281
		case 43: goto st115
		case 59: goto tr1282
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1285:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st372
tr1286:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st372
tr1284:
// line 101 "zparse.rl"
	{ lines++ }
	goto st372
tr1278:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st372
tr1279:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st372
tr1280:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st372
tr1281:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st372
st372:
	p++
	if p == pe { goto _test_eof372 }
	fallthrough
case 372:
// line 26782 "zparse.go"
	switch data[p] {
		case 9: goto st372
		case 10: goto tr1284
		case 32: goto st372
		case 40: goto tr1285
		case 41: goto tr1286
		case 59: goto st390
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1287 }
	goto st0
tr1287:
// line 89 "zparse.rl"
	{ mark = p }
	goto st373
st373:
	p++
	if p == pe { goto _test_eof373 }
	fallthrough
case 373:
// line 26802 "zparse.go"
	switch data[p] {
		case 9: goto tr1289
		case 10: goto tr1290
		case 32: goto tr1289
		case 40: goto tr1291
		case 41: goto tr1292
		case 59: goto tr1294
	}
	if 48 <= data[p] && data[p] <= 57 { goto st373 }
	goto st0
tr1297:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st374
tr1298:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st374
tr1296:
// line 101 "zparse.rl"
	{ lines++ }
	goto st374
tr1289:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st374
tr1290:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st374
tr1291:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st374
tr1292:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st374
st374:
	p++
	if p == pe { goto _test_eof374 }
	fallthrough
case 374:
// line 26852 "zparse.go"
	switch data[p] {
		case 9: goto st374
		case 10: goto tr1296
		case 32: goto st374
		case 40: goto tr1297
		case 41: goto tr1298
		case 59: goto st389
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1299 }
	goto st0
tr1299:
// line 89 "zparse.rl"
	{ mark = p }
	goto st375
st375:
	p++
	if p == pe { goto _test_eof375 }
	fallthrough
case 375:
// line 26872 "zparse.go"
	switch data[p] {
		case 9: goto tr1301
		case 10: goto tr1302
		case 32: goto tr1301
		case 40: goto tr1303
		case 41: goto tr1304
		case 59: goto tr1306
	}
	if 48 <= data[p] && data[p] <= 57 { goto st375 }
	goto st0
tr1309:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st376
tr1310:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st376
tr1308:
// line 101 "zparse.rl"
	{ lines++ }
	goto st376
tr1301:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st376
tr1302:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st376
tr1303:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st376
tr1304:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st376
st376:
	p++
	if p == pe { goto _test_eof376 }
	fallthrough
case 376:
// line 26922 "zparse.go"
	switch data[p] {
		case 9: goto st376
		case 10: goto tr1308
		case 32: goto st376
		case 40: goto tr1309
		case 41: goto tr1310
		case 59: goto st388
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1311 }
	goto st0
tr1311:
// line 89 "zparse.rl"
	{ mark = p }
	goto st377
st377:
	p++
	if p == pe { goto _test_eof377 }
	fallthrough
case 377:
// line 26942 "zparse.go"
	switch data[p] {
		case 9: goto tr1313
		case 10: goto tr1314
		case 32: goto tr1313
		case 40: goto tr1315
		case 41: goto tr1316
		case 59: goto tr1318
	}
	if 48 <= data[p] && data[p] <= 57 { goto st377 }
	goto st0
tr1321:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st378
tr1322:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st378
tr1320:
// line 101 "zparse.rl"
	{ lines++ }
	goto st378
tr1313:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st378
tr1314:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st378
tr1315:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st378
tr1316:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st378
st378:
	p++
	if p == pe { goto _test_eof378 }
	fallthrough
case 378:
// line 26992 "zparse.go"
	switch data[p] {
		case 9: goto st378
		case 10: goto tr1320
		case 32: goto st378
		case 40: goto tr1321
		case 41: goto tr1322
		case 43: goto tr180
		case 58: goto tr180
		case 59: goto st387
		case 61: goto tr180
		case 92: goto tr180
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr180 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr180 }
		} else if data[p] >= 65 {
			goto tr180
		}
	} else {
		goto tr1323
	}
	goto st0
tr1323:
// line 89 "zparse.rl"
	{ mark = p }
	goto st379
st379:
	p++
	if p == pe { goto _test_eof379 }
	fallthrough
case 379:
// line 27026 "zparse.go"
	switch data[p] {
		case 9: goto tr1325
		case 10: goto tr1326
		case 32: goto tr1325
		case 40: goto tr1327
		case 41: goto tr1328
		case 43: goto st46
		case 58: goto st46
		case 59: goto tr1330
		case 61: goto st46
		case 92: goto st46
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st46 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st46 }
		} else if data[p] >= 65 {
			goto st46
		}
	} else {
		goto st379
	}
	goto st0
tr1333:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st380
tr1334:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st380
tr4572:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st380
tr1325:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st380
tr1327:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st380
tr1328:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st380
tr1411:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st380
tr1413:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st380
tr1414:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st380
tr4574:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st380
tr4575:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st380
st380:
	p++
	if p == pe { goto _test_eof380 }
	fallthrough
case 380:
// line 27232 "zparse.go"
	switch data[p] {
		case 9: goto st380
		case 10: goto tr1332
		case 32: goto st380
		case 40: goto tr1333
		case 41: goto tr1334
		case 59: goto tr1335
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr489 }
	goto st0
tr1332:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1737
tr1363:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1737
tr1326:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1737
tr1412:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1737
tr4573:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1737
st1737:
	p++
	if p == pe { goto _test_eof1737 }
	fallthrough
case 1737:
// line 27316 "zparse.go"
	switch data[p] {
		case 9: goto st381
		case 10: goto tr1337
		case 32: goto st381
		case 40: goto tr1338
		case 41: goto tr1339
		case 59: goto tr1341
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5399
	}
	goto st0
tr1338:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st381
tr1339:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st381
tr4830:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st381
tr4832:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st381
tr4833:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st381
tr4851:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st381
tr4853:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st381
tr4854:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st381
st381:
	p++
	if p == pe { goto _test_eof381 }
	fallthrough
case 381:
// line 27486 "zparse.go"
	switch data[p] {
		case 9: goto st381
		case 10: goto tr1337
		case 32: goto st381
		case 40: goto tr1338
		case 41: goto tr1339
		case 59: goto tr1341
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1340 }
	goto st0
tr1337:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1738
tr1349:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1738
tr4831:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1738
tr4852:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1738
st1738:
	p++
	if p == pe { goto _test_eof1738 }
	fallthrough
case 1738:
// line 27576 "zparse.go"
	switch data[p] {
		case 9: goto st381
		case 10: goto tr1337
		case 32: goto st381
		case 40: goto tr1338
		case 41: goto tr1339
		case 59: goto tr1341
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5400
	}
	goto st0
tr5400:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st382
st382:
	p++
	if p == pe { goto _test_eof382 }
	fallthrough
case 382:
// line 27628 "zparse.go"
	switch data[p] {
		case 9: goto tr1342
		case 10: goto tr1343
		case 32: goto tr1342
		case 40: goto tr1344
		case 41: goto tr1345
		case 59: goto tr1347
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st382
	}
	goto st0
tr1341:
// line 89 "zparse.rl"
	{ mark = p }
	goto st383
tr4835:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st383
tr4856:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st383
st383:
	p++
	if p == pe { goto _test_eof383 }
	fallthrough
case 383:
// line 27702 "zparse.go"
	if data[p] == 10 { goto tr1349 }
	goto st383
tr1340:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st384
st384:
	p++
	if p == pe { goto _test_eof384 }
	fallthrough
case 384:
// line 27716 "zparse.go"
	switch data[p] {
		case 9: goto tr1350
		case 10: goto tr1351
		case 32: goto tr1350
		case 40: goto tr1352
		case 41: goto tr1353
		case 59: goto tr1355
	}
	if 48 <= data[p] && data[p] <= 57 { goto st384 }
	goto st0
tr5399:
// line 89 "zparse.rl"
	{ mark = p }
	goto st385
st385:
	p++
	if p == pe { goto _test_eof385 }
	fallthrough
case 385:
// line 27736 "zparse.go"
	switch data[p] {
		case 9: goto tr1356
		case 10: goto tr1357
		case 32: goto tr1356
		case 40: goto tr1358
		case 41: goto tr1359
		case 59: goto tr1361
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st385
	}
	goto st0
tr1335:
// line 89 "zparse.rl"
	{ mark = p }
	goto st386
tr4577:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st386
tr1330:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st386
tr1416:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st386
st386:
	p++
	if p == pe { goto _test_eof386 }
	fallthrough
case 386:
// line 27820 "zparse.go"
	if data[p] == 10 { goto tr1363 }
	goto st386
tr1318:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st387
st387:
	p++
	if p == pe { goto _test_eof387 }
	fallthrough
case 387:
// line 27832 "zparse.go"
	if data[p] == 10 { goto tr1320 }
	goto st387
tr1306:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st388
st388:
	p++
	if p == pe { goto _test_eof388 }
	fallthrough
case 388:
// line 27844 "zparse.go"
	if data[p] == 10 { goto tr1308 }
	goto st388
tr1294:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st389
st389:
	p++
	if p == pe { goto _test_eof389 }
	fallthrough
case 389:
// line 27856 "zparse.go"
	if data[p] == 10 { goto tr1296 }
	goto st389
tr1282:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st390
st390:
	p++
	if p == pe { goto _test_eof390 }
	fallthrough
case 390:
// line 27879 "zparse.go"
	if data[p] == 10 { goto tr1284 }
	goto st390
st391:
	p++
	if p == pe { goto _test_eof391 }
	fallthrough
case 391:
	switch data[p] {
		case 9: goto tr1364
		case 10: goto tr1365
		case 32: goto tr1364
		case 40: goto tr1366
		case 41: goto tr1367
		case 43: goto st115
		case 59: goto tr1368
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1371:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st392
tr1372:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st392
tr1370:
// line 101 "zparse.rl"
	{ lines++ }
	goto st392
tr1364:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st392
tr1365:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st392
tr1366:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st392
tr1367:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st392
st392:
	p++
	if p == pe { goto _test_eof392 }
	fallthrough
case 392:
// line 27989 "zparse.go"
	switch data[p] {
		case 9: goto st392
		case 10: goto tr1370
		case 32: goto st392
		case 40: goto tr1371
		case 41: goto tr1372
		case 59: goto st403
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1373 }
	goto st0
tr1373:
// line 89 "zparse.rl"
	{ mark = p }
	goto st393
st393:
	p++
	if p == pe { goto _test_eof393 }
	fallthrough
case 393:
// line 28009 "zparse.go"
	switch data[p] {
		case 9: goto tr1375
		case 10: goto tr1376
		case 32: goto tr1375
		case 40: goto tr1377
		case 41: goto tr1378
		case 59: goto tr1380
	}
	if 48 <= data[p] && data[p] <= 57 { goto st393 }
	goto st0
tr1383:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st394
tr1384:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st394
tr1382:
// line 101 "zparse.rl"
	{ lines++ }
	goto st394
tr1375:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st394
tr1376:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st394
tr1377:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st394
tr1378:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st394
st394:
	p++
	if p == pe { goto _test_eof394 }
	fallthrough
case 394:
// line 28059 "zparse.go"
	switch data[p] {
		case 9: goto st394
		case 10: goto tr1382
		case 32: goto st394
		case 40: goto tr1383
		case 41: goto tr1384
		case 59: goto st402
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1385 }
	goto st0
tr1385:
// line 89 "zparse.rl"
	{ mark = p }
	goto st395
st395:
	p++
	if p == pe { goto _test_eof395 }
	fallthrough
case 395:
// line 28079 "zparse.go"
	switch data[p] {
		case 9: goto tr1387
		case 10: goto tr1388
		case 32: goto tr1387
		case 40: goto tr1389
		case 41: goto tr1390
		case 59: goto tr1392
	}
	if 48 <= data[p] && data[p] <= 57 { goto st395 }
	goto st0
tr1395:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st396
tr1396:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st396
tr1394:
// line 101 "zparse.rl"
	{ lines++ }
	goto st396
tr1387:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st396
tr1388:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st396
tr1389:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st396
tr1390:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st396
st396:
	p++
	if p == pe { goto _test_eof396 }
	fallthrough
case 396:
// line 28129 "zparse.go"
	switch data[p] {
		case 9: goto st396
		case 10: goto tr1394
		case 32: goto st396
		case 40: goto tr1395
		case 41: goto tr1396
		case 59: goto st401
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1397 }
	goto st0
tr1397:
// line 89 "zparse.rl"
	{ mark = p }
	goto st397
st397:
	p++
	if p == pe { goto _test_eof397 }
	fallthrough
case 397:
// line 28149 "zparse.go"
	switch data[p] {
		case 9: goto tr1399
		case 10: goto tr1400
		case 32: goto tr1399
		case 40: goto tr1401
		case 41: goto tr1402
		case 59: goto tr1404
	}
	if 48 <= data[p] && data[p] <= 57 { goto st397 }
	goto st0
tr1407:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st398
tr1408:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st398
tr1406:
// line 101 "zparse.rl"
	{ lines++ }
	goto st398
tr1399:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st398
tr1400:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st398
tr1401:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st398
tr1402:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st398
st398:
	p++
	if p == pe { goto _test_eof398 }
	fallthrough
case 398:
// line 28199 "zparse.go"
	switch data[p] {
		case 9: goto st398
		case 10: goto tr1406
		case 32: goto st398
		case 40: goto tr1407
		case 41: goto tr1408
		case 43: goto tr233
		case 58: goto tr233
		case 59: goto st400
		case 61: goto tr233
		case 92: goto tr233
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr233 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr233 }
		} else if data[p] >= 65 {
			goto tr233
		}
	} else {
		goto tr1409
	}
	goto st0
tr1409:
// line 89 "zparse.rl"
	{ mark = p }
	goto st399
st399:
	p++
	if p == pe { goto _test_eof399 }
	fallthrough
case 399:
// line 28233 "zparse.go"
	switch data[p] {
		case 9: goto tr1411
		case 10: goto tr1412
		case 32: goto tr1411
		case 40: goto tr1413
		case 41: goto tr1414
		case 43: goto st59
		case 58: goto st59
		case 59: goto tr1416
		case 61: goto st59
		case 92: goto st59
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st59 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st59 }
		} else if data[p] >= 65 {
			goto st59
		}
	} else {
		goto st399
	}
	goto st0
tr1404:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st400
st400:
	p++
	if p == pe { goto _test_eof400 }
	fallthrough
case 400:
// line 28267 "zparse.go"
	if data[p] == 10 { goto tr1406 }
	goto st400
tr1392:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st401
st401:
	p++
	if p == pe { goto _test_eof401 }
	fallthrough
case 401:
// line 28279 "zparse.go"
	if data[p] == 10 { goto tr1394 }
	goto st401
tr1380:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st402
st402:
	p++
	if p == pe { goto _test_eof402 }
	fallthrough
case 402:
// line 28291 "zparse.go"
	if data[p] == 10 { goto tr1382 }
	goto st402
tr1368:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st403
st403:
	p++
	if p == pe { goto _test_eof403 }
	fallthrough
case 403:
// line 28314 "zparse.go"
	if data[p] == 10 { goto tr1370 }
	goto st403
tr1141:
// line 89 "zparse.rl"
	{ mark = p }
	goto st404
st404:
	p++
	if p == pe { goto _test_eof404 }
	fallthrough
case 404:
// line 28326 "zparse.go"
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 83: goto st355
		case 92: goto st115
		case 115: goto st355
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1142:
// line 89 "zparse.rl"
	{ mark = p }
	goto st405
st405:
	p++
	if p == pe { goto _test_eof405 }
	fallthrough
case 405:
// line 28357 "zparse.go"
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 78: goto st355
		case 92: goto st115
		case 110: goto st355
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1962:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st406
tr1143:
// line 89 "zparse.rl"
	{ mark = p }
	goto st406
st406:
	p++
	if p == pe { goto _test_eof406 }
	fallthrough
case 406:
// line 28394 "zparse.go"
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 88: goto st407
		case 92: goto st115
		case 120: goto st407
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st407:
	p++
	if p == pe { goto _test_eof407 }
	fallthrough
case 407:
	switch data[p] {
		case 9: goto tr1418
		case 10: goto tr1419
		case 32: goto tr1418
		case 40: goto tr1420
		case 41: goto tr1421
		case 43: goto st115
		case 59: goto tr1422
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1425:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st408
tr1426:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st408
tr1424:
// line 101 "zparse.rl"
	{ lines++ }
	goto st408
tr1418:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st408
tr1419:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st408
tr1420:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st408
tr1421:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st408
st408:
	p++
	if p == pe { goto _test_eof408 }
	fallthrough
case 408:
// line 28523 "zparse.go"
	switch data[p] {
		case 9: goto st408
		case 10: goto tr1424
		case 32: goto st408
		case 40: goto tr1425
		case 41: goto tr1426
		case 59: goto st424
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1427 }
	goto st0
tr1427:
// line 89 "zparse.rl"
	{ mark = p }
	goto st409
st409:
	p++
	if p == pe { goto _test_eof409 }
	fallthrough
case 409:
// line 28543 "zparse.go"
	switch data[p] {
		case 9: goto tr1429
		case 10: goto tr1430
		case 32: goto tr1429
		case 40: goto tr1431
		case 41: goto tr1432
		case 59: goto tr1434
	}
	if 48 <= data[p] && data[p] <= 57 { goto st409 }
	goto st0
tr1437:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st410
tr1438:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st410
tr1436:
// line 101 "zparse.rl"
	{ lines++ }
	goto st410
tr1429:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st410
tr1430:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st410
tr1431:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st410
tr1432:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st410
st410:
	p++
	if p == pe { goto _test_eof410 }
	fallthrough
case 410:
// line 28593 "zparse.go"
	switch data[p] {
		case 9: goto st410
		case 10: goto tr1436
		case 32: goto st410
		case 40: goto tr1437
		case 41: goto tr1438
		case 43: goto tr263
		case 58: goto tr263
		case 59: goto st423
		case 61: goto tr263
		case 92: goto tr263
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr263 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr263 }
		} else if data[p] >= 65 {
			goto tr263
		}
	} else {
		goto tr1439
	}
	goto st0
tr1439:
// line 89 "zparse.rl"
	{ mark = p }
	goto st411
st411:
	p++
	if p == pe { goto _test_eof411 }
	fallthrough
case 411:
// line 28627 "zparse.go"
	switch data[p] {
		case 9: goto tr1441
		case 10: goto tr1442
		case 32: goto tr1441
		case 40: goto tr1443
		case 41: goto tr1444
		case 43: goto st69
		case 58: goto st69
		case 59: goto tr1446
		case 61: goto st69
		case 92: goto st69
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st69 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st69 }
		} else if data[p] >= 65 {
			goto st69
		}
	} else {
		goto st411
	}
	goto st0
tr1449:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st412
tr1450:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st412
tr1441:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st412
tr1443:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st412
tr1444:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st412
st412:
	p++
	if p == pe { goto _test_eof412 }
	fallthrough
case 412:
// line 28714 "zparse.go"
	switch data[p] {
		case 9: goto st412
		case 10: goto tr1448
		case 32: goto st412
		case 40: goto tr1449
		case 41: goto tr1450
		case 59: goto tr1451
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr465 }
	goto st0
tr1448:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1739
tr1489:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1739
tr1442:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1739
st1739:
	p++
	if p == pe { goto _test_eof1739 }
	fallthrough
case 1739:
// line 28757 "zparse.go"
	switch data[p] {
		case 9: goto st413
		case 10: goto tr1453
		case 32: goto st413
		case 40: goto tr1454
		case 41: goto tr1455
		case 59: goto tr1456
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5401
	}
	goto st0
tr1454:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st413
tr1455:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st413
st413:
	p++
	if p == pe { goto _test_eof413 }
	fallthrough
case 413:
// line 28793 "zparse.go"
	switch data[p] {
		case 9: goto st413
		case 10: goto tr1453
		case 32: goto st413
		case 40: goto tr1454
		case 41: goto tr1455
		case 59: goto tr1456
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1187 }
	goto st0
tr1453:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1740
tr1481:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1740
st1740:
	p++
	if p == pe { goto _test_eof1740 }
	fallthrough
case 1740:
// line 28837 "zparse.go"
	switch data[p] {
		case 9: goto st413
		case 10: goto tr1453
		case 32: goto st413
		case 40: goto tr1454
		case 41: goto tr1455
		case 59: goto tr1456
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5402
	}
	goto st0
tr5402:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st414
st414:
	p++
	if p == pe { goto _test_eof414 }
	fallthrough
case 414:
// line 28889 "zparse.go"
	switch data[p] {
		case 9: goto tr1457
		case 10: goto tr1458
		case 32: goto tr1457
		case 40: goto tr1459
		case 41: goto tr1460
		case 59: goto tr1462
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st414
	}
	goto st0
tr1465:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st415
tr1466:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st415
tr1464:
// line 101 "zparse.rl"
	{ lines++ }
	goto st415
tr1457:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st415
tr1458:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st415
tr1459:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st415
tr1460:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st415
tr1482:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st415
tr1483:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st415
tr1484:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st415
tr1485:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st415
st415:
	p++
	if p == pe { goto _test_eof415 }
	fallthrough
case 415:
// line 28997 "zparse.go"
	switch data[p] {
		case 9: goto st415
		case 10: goto tr1464
		case 32: goto st415
		case 40: goto tr1465
		case 41: goto tr1466
		case 59: goto st419
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1467 }
	goto st0
tr1467:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st416
st416:
	p++
	if p == pe { goto _test_eof416 }
	fallthrough
case 416:
// line 29037 "zparse.go"
	switch data[p] {
		case 9: goto tr1469
		case 10: goto tr1470
		case 32: goto tr1469
		case 40: goto tr1471
		case 41: goto tr1472
		case 59: goto tr1474
	}
	if 48 <= data[p] && data[p] <= 57 { goto st416 }
	goto st0
tr1477:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st417
tr1478:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st417
tr1476:
// line 101 "zparse.rl"
	{ lines++ }
	goto st417
tr1469:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st417
tr1470:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st417
tr1471:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st417
tr1472:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st417
st417:
	p++
	if p == pe { goto _test_eof417 }
	fallthrough
case 417:
// line 29095 "zparse.go"
	switch data[p] {
		case 9: goto st417
		case 10: goto tr1476
		case 32: goto st417
		case 40: goto tr1477
		case 41: goto tr1478
		case 59: goto st418
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr489 }
	goto st0
tr1474:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st418
st418:
	p++
	if p == pe { goto _test_eof418 }
	fallthrough
case 418:
// line 29135 "zparse.go"
	if data[p] == 10 { goto tr1476 }
	goto st418
tr1462:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st419
tr1487:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st419
st419:
	p++
	if p == pe { goto _test_eof419 }
	fallthrough
case 419:
// line 29157 "zparse.go"
	if data[p] == 10 { goto tr1464 }
	goto st419
tr1456:
// line 89 "zparse.rl"
	{ mark = p }
	goto st420
st420:
	p++
	if p == pe { goto _test_eof420 }
	fallthrough
case 420:
// line 29169 "zparse.go"
	if data[p] == 10 { goto tr1481 }
	goto st420
tr5401:
// line 89 "zparse.rl"
	{ mark = p }
	goto st421
st421:
	p++
	if p == pe { goto _test_eof421 }
	fallthrough
case 421:
// line 29181 "zparse.go"
	switch data[p] {
		case 9: goto tr1482
		case 10: goto tr1483
		case 32: goto tr1482
		case 40: goto tr1484
		case 41: goto tr1485
		case 59: goto tr1487
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st421
	}
	goto st0
tr1451:
// line 89 "zparse.rl"
	{ mark = p }
	goto st422
tr1446:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st422
st422:
	p++
	if p == pe { goto _test_eof422 }
	fallthrough
case 422:
// line 29228 "zparse.go"
	if data[p] == 10 { goto tr1489 }
	goto st422
tr1434:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st423
st423:
	p++
	if p == pe { goto _test_eof423 }
	fallthrough
case 423:
// line 29240 "zparse.go"
	if data[p] == 10 { goto tr1436 }
	goto st423
tr1422:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st424
st424:
	p++
	if p == pe { goto _test_eof424 }
	fallthrough
case 424:
// line 29263 "zparse.go"
	if data[p] == 10 { goto tr1424 }
	goto st424
tr1144:
// line 89 "zparse.rl"
	{ mark = p }
	goto st425
st425:
	p++
	if p == pe { goto _test_eof425 }
	fallthrough
case 425:
// line 29275 "zparse.go"
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 79: goto st426
		case 83: goto st428
		case 92: goto st115
		case 111: goto st426
		case 115: goto st428
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st426:
	p++
	if p == pe { goto _test_eof426 }
	fallthrough
case 426:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 78: goto st427
		case 92: goto st115
		case 110: goto st427
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st427:
	p++
	if p == pe { goto _test_eof427 }
	fallthrough
case 427:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 69: goto st355
		case 92: goto st115
		case 101: goto st355
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st428:
	p++
	if p == pe { goto _test_eof428 }
	fallthrough
case 428:
	switch data[p] {
		case 9: goto tr1493
		case 10: goto tr1494
		case 32: goto tr1493
		case 40: goto tr1495
		case 41: goto tr1496
		case 43: goto st115
		case 59: goto tr1497
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1500:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st429
tr1501:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st429
tr1499:
// line 101 "zparse.rl"
	{ lines++ }
	goto st429
tr1493:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st429
tr1494:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st429
tr1495:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st429
tr1496:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st429
st429:
	p++
	if p == pe { goto _test_eof429 }
	fallthrough
case 429:
// line 29458 "zparse.go"
	switch data[p] {
		case 9: goto st429
		case 10: goto tr1499
		case 32: goto st429
		case 40: goto tr1500
		case 41: goto tr1501
		case 43: goto tr281
		case 58: goto tr281
		case 59: goto st431
		case 61: goto tr281
		case 92: goto tr281
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr281 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr281 }
		} else if data[p] >= 65 {
			goto tr281
		}
	} else {
		goto tr1502
	}
	goto st0
tr1502:
// line 89 "zparse.rl"
	{ mark = p }
	goto st430
st430:
	p++
	if p == pe { goto _test_eof430 }
	fallthrough
case 430:
// line 29492 "zparse.go"
	switch data[p] {
		case 9: goto tr1504
		case 10: goto tr1505
		case 32: goto tr1504
		case 40: goto tr1506
		case 41: goto tr1507
		case 43: goto st75
		case 58: goto st75
		case 59: goto tr1509
		case 61: goto st75
		case 92: goto st75
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st75 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st75 }
		} else if data[p] >= 65 {
			goto st75
		}
	} else {
		goto st430
	}
	goto st0
tr1497:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st431
st431:
	p++
	if p == pe { goto _test_eof431 }
	fallthrough
case 431:
// line 29537 "zparse.go"
	if data[p] == 10 { goto tr1499 }
	goto st431
tr1964:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st432
tr1145:
// line 89 "zparse.rl"
	{ mark = p }
	goto st432
st432:
	p++
	if p == pe { goto _test_eof432 }
	fallthrough
case 432:
// line 29555 "zparse.go"
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 82: goto st433
		case 92: goto st115
		case 114: goto st433
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st433:
	p++
	if p == pe { goto _test_eof433 }
	fallthrough
case 433:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 83: goto st434
		case 92: goto st115
		case 115: goto st434
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st434:
	p++
	if p == pe { goto _test_eof434 }
	fallthrough
case 434:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 73: goto st435
		case 92: goto st115
		case 105: goto st435
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st435:
	p++
	if p == pe { goto _test_eof435 }
	fallthrough
case 435:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 71: goto st436
		case 92: goto st115
		case 103: goto st436
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st436:
	p++
	if p == pe { goto _test_eof436 }
	fallthrough
case 436:
	switch data[p] {
		case 9: goto tr1514
		case 10: goto tr1515
		case 32: goto tr1514
		case 40: goto tr1516
		case 41: goto tr1517
		case 43: goto st115
		case 59: goto tr1518
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1521:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st437
tr1522:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st437
tr1520:
// line 101 "zparse.rl"
	{ lines++ }
	goto st437
tr1514:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st437
tr1515:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st437
tr1516:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st437
tr1517:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st437
st437:
	p++
	if p == pe { goto _test_eof437 }
	fallthrough
case 437:
// line 29762 "zparse.go"
	switch data[p] {
		case 9: goto st437
		case 10: goto tr1520
		case 32: goto st437
		case 40: goto tr1521
		case 41: goto tr1522
		case 59: goto st1708
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1523 }
	goto st0
tr1523:
// line 89 "zparse.rl"
	{ mark = p }
	goto st438
st438:
	p++
	if p == pe { goto _test_eof438 }
	fallthrough
case 438:
// line 29782 "zparse.go"
	switch data[p] {
		case 9: goto tr1525
		case 10: goto tr1526
		case 32: goto tr1525
		case 40: goto tr1527
		case 41: goto tr1528
		case 59: goto tr1530
	}
	if 48 <= data[p] && data[p] <= 57 { goto st438 }
	goto st0
tr1533:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st439
tr1534:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st439
tr1532:
// line 101 "zparse.rl"
	{ lines++ }
	goto st439
tr1525:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st439
tr1526:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st439
tr1527:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st439
tr1528:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st439
st439:
	p++
	if p == pe { goto _test_eof439 }
	fallthrough
case 439:
// line 29832 "zparse.go"
	switch data[p] {
		case 9: goto st439
		case 10: goto tr1532
		case 32: goto st439
		case 40: goto tr1533
		case 41: goto tr1534
		case 59: goto st1707
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1535 }
	goto st0
tr1535:
// line 89 "zparse.rl"
	{ mark = p }
	goto st440
st440:
	p++
	if p == pe { goto _test_eof440 }
	fallthrough
case 440:
// line 29852 "zparse.go"
	switch data[p] {
		case 9: goto tr1537
		case 10: goto tr1538
		case 32: goto tr1537
		case 40: goto tr1539
		case 41: goto tr1540
		case 59: goto tr1542
	}
	if 48 <= data[p] && data[p] <= 57 { goto st440 }
	goto st0
tr1545:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st441
tr1546:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st441
tr1544:
// line 101 "zparse.rl"
	{ lines++ }
	goto st441
tr1537:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st441
tr1538:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st441
tr1539:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st441
tr1540:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st441
st441:
	p++
	if p == pe { goto _test_eof441 }
	fallthrough
case 441:
// line 29902 "zparse.go"
	switch data[p] {
		case 9: goto st441
		case 10: goto tr1544
		case 32: goto st441
		case 40: goto tr1545
		case 41: goto tr1546
		case 59: goto st1706
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1547 }
	goto st0
tr1547:
// line 89 "zparse.rl"
	{ mark = p }
	goto st442
st442:
	p++
	if p == pe { goto _test_eof442 }
	fallthrough
case 442:
// line 29922 "zparse.go"
	switch data[p] {
		case 9: goto tr1549
		case 10: goto tr1550
		case 32: goto tr1549
		case 40: goto tr1551
		case 41: goto tr1552
		case 59: goto tr1554
	}
	if 48 <= data[p] && data[p] <= 57 { goto st442 }
	goto st0
tr1557:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st443
tr1558:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st443
tr1556:
// line 101 "zparse.rl"
	{ lines++ }
	goto st443
tr1549:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st443
tr1550:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st443
tr1551:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st443
tr1552:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st443
st443:
	p++
	if p == pe { goto _test_eof443 }
	fallthrough
case 443:
// line 29972 "zparse.go"
	switch data[p] {
		case 9: goto st443
		case 10: goto tr1556
		case 32: goto st443
		case 40: goto tr1557
		case 41: goto tr1558
		case 59: goto st1705
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1559 }
	goto st0
tr1559:
// line 89 "zparse.rl"
	{ mark = p }
	goto st444
st444:
	p++
	if p == pe { goto _test_eof444 }
	fallthrough
case 444:
// line 29992 "zparse.go"
	switch data[p] {
		case 9: goto tr1561
		case 10: goto tr1562
		case 32: goto tr1561
		case 40: goto tr1563
		case 41: goto tr1564
		case 59: goto tr1566
	}
	if 48 <= data[p] && data[p] <= 57 { goto st444 }
	goto st0
tr1569:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st445
tr1570:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st445
tr1568:
// line 101 "zparse.rl"
	{ lines++ }
	goto st445
tr1561:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st445
tr1562:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st445
tr1563:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st445
tr1564:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st445
st445:
	p++
	if p == pe { goto _test_eof445 }
	fallthrough
case 445:
// line 30042 "zparse.go"
	switch data[p] {
		case 9: goto st445
		case 10: goto tr1568
		case 32: goto st445
		case 40: goto tr1569
		case 41: goto tr1570
		case 59: goto st1704
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1571 }
	goto st0
tr1571:
// line 89 "zparse.rl"
	{ mark = p }
	goto st446
st446:
	p++
	if p == pe { goto _test_eof446 }
	fallthrough
case 446:
// line 30062 "zparse.go"
	switch data[p] {
		case 9: goto tr1573
		case 10: goto tr1574
		case 32: goto tr1573
		case 40: goto tr1575
		case 41: goto tr1576
		case 59: goto tr1578
	}
	if 48 <= data[p] && data[p] <= 57 { goto st446 }
	goto st0
tr1581:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st447
tr1582:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st447
tr1573:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st447
tr1575:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st447
tr1576:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st447
st447:
	p++
	if p == pe { goto _test_eof447 }
	fallthrough
case 447:
// line 30144 "zparse.go"
	switch data[p] {
		case 9: goto st447
		case 10: goto tr1580
		case 32: goto st447
		case 40: goto tr1581
		case 41: goto tr1582
		case 59: goto tr1583
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr362 }
	goto st0
tr1580:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1741
tr5318:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1741
tr1574:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1741
st1741:
	p++
	if p == pe { goto _test_eof1741 }
	fallthrough
case 1741:
// line 30190 "zparse.go"
	switch data[p] {
		case 9: goto st448
		case 10: goto tr1585
		case 32: goto st448
		case 40: goto tr1586
		case 41: goto tr1587
		case 59: goto tr1589
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5403
	}
	goto st0
tr1586:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st448
tr1587:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st448
st448:
	p++
	if p == pe { goto _test_eof448 }
	fallthrough
case 448:
// line 30226 "zparse.go"
	switch data[p] {
		case 9: goto st448
		case 10: goto tr1585
		case 32: goto st448
		case 40: goto tr1586
		case 41: goto tr1587
		case 59: goto tr1589
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1588 }
	goto st0
tr1585:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1742
tr5299:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1742
st1742:
	p++
	if p == pe { goto _test_eof1742 }
	fallthrough
case 1742:
// line 30270 "zparse.go"
	switch data[p] {
		case 9: goto st448
		case 10: goto tr1585
		case 32: goto st448
		case 40: goto tr1586
		case 41: goto tr1587
		case 59: goto tr1589
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5404
	}
	goto st0
tr5404:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st449
st449:
	p++
	if p == pe { goto _test_eof449 }
	fallthrough
case 449:
// line 30322 "zparse.go"
	switch data[p] {
		case 9: goto tr1590
		case 10: goto tr1591
		case 32: goto tr1590
		case 40: goto tr1592
		case 41: goto tr1593
		case 59: goto tr1595
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st449
	}
	goto st0
tr1598:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st450
tr1599:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st450
tr1597:
// line 101 "zparse.rl"
	{ lines++ }
	goto st450
tr1590:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st450
tr1591:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st450
tr1592:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st450
tr1593:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st450
tr5311:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st450
tr5312:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st450
tr5313:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st450
tr5314:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st450
st450:
	p++
	if p == pe { goto _test_eof450 }
	fallthrough
case 450:
// line 30430 "zparse.go"
	switch data[p] {
		case 9: goto st450
		case 10: goto tr1597
		case 32: goto st450
		case 40: goto tr1598
		case 41: goto tr1599
		case 59: goto st1697
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1600 }
	goto st0
tr1600:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st451
st451:
	p++
	if p == pe { goto _test_eof451 }
	fallthrough
case 451:
// line 30470 "zparse.go"
	switch data[p] {
		case 9: goto tr1602
		case 10: goto tr1603
		case 32: goto tr1602
		case 40: goto tr1604
		case 41: goto tr1605
		case 59: goto tr1607
	}
	if 48 <= data[p] && data[p] <= 57 { goto st451 }
	goto st0
tr1610:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st452
tr1611:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st452
tr1609:
// line 101 "zparse.rl"
	{ lines++ }
	goto st452
tr1602:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st452
tr1603:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st452
tr1604:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st452
tr1605:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st452
st452:
	p++
	if p == pe { goto _test_eof452 }
	fallthrough
case 452:
// line 30528 "zparse.go"
	switch data[p] {
		case 9: goto st452
		case 10: goto tr1609
		case 32: goto st452
		case 40: goto tr1610
		case 41: goto tr1611
		case 43: goto tr386
		case 59: goto st453
		case 61: goto tr386
		case 65: goto tr1613
		case 67: goto tr1614
		case 68: goto tr1615
		case 72: goto tr1616
		case 73: goto tr1617
		case 77: goto tr1618
		case 78: goto tr1619
		case 82: goto tr1620
		case 83: goto tr1621
		case 92: goto tr386
		case 97: goto tr1613
		case 99: goto tr1614
		case 100: goto tr1615
		case 104: goto tr1616
		case 105: goto tr1617
		case 109: goto tr1618
		case 110: goto tr1619
		case 114: goto tr1620
		case 115: goto tr1621
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto tr386 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto tr386 }
	} else {
		goto tr386
	}
	goto st0
tr1607:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st453
st453:
	p++
	if p == pe { goto _test_eof453 }
	fallthrough
case 453:
// line 30577 "zparse.go"
	if data[p] == 10 { goto tr1609 }
	goto st453
tr1613:
// line 89 "zparse.rl"
	{ mark = p }
	goto st454
st454:
	p++
	if p == pe { goto _test_eof454 }
	fallthrough
case 454:
// line 30589 "zparse.go"
	switch data[p] {
		case 9: goto tr1622
		case 10: goto tr1623
		case 32: goto tr1622
		case 40: goto tr1624
		case 41: goto tr1625
		case 43: goto st97
		case 59: goto tr1626
		case 61: goto st97
		case 65: goto st458
		case 78: goto st464
		case 92: goto st97
		case 97: goto st458
		case 110: goto st464
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr1631:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st455
tr1632:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st455
tr1630:
// line 101 "zparse.rl"
	{ lines++ }
	goto st455
tr1622:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st455
tr1623:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st455
tr1624:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st455
tr1625:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st455
st455:
	p++
	if p == pe { goto _test_eof455 }
	fallthrough
case 455:
// line 30696 "zparse.go"
	switch data[p] {
		case 9: goto st455
		case 10: goto tr1630
		case 32: goto st455
		case 40: goto tr1631
		case 41: goto tr1632
		case 43: goto tr1633
		case 59: goto st457
		case 61: goto tr1633
		case 92: goto tr1633
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr1633 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr1633 }
	} else {
		goto tr1633
	}
	goto st0
tr1633:
// line 89 "zparse.rl"
	{ mark = p }
	goto st456
st456:
	p++
	if p == pe { goto _test_eof456 }
	fallthrough
case 456:
// line 30725 "zparse.go"
	switch data[p] {
		case 9: goto tr1635
		case 10: goto tr1636
		case 32: goto tr1635
		case 40: goto tr1637
		case 41: goto tr1638
		case 43: goto st456
		case 59: goto tr1640
		case 61: goto st456
		case 92: goto st456
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st456 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st456 }
	} else {
		goto st456
	}
	goto st0
tr1626:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st457
st457:
	p++
	if p == pe { goto _test_eof457 }
	fallthrough
case 457:
// line 30765 "zparse.go"
	if data[p] == 10 { goto tr1630 }
	goto st457
st458:
	p++
	if p == pe { goto _test_eof458 }
	fallthrough
case 458:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 65: goto st459
		case 92: goto st97
		case 97: goto st459
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st459:
	p++
	if p == pe { goto _test_eof459 }
	fallthrough
case 459:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 65: goto st460
		case 92: goto st97
		case 97: goto st460
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st460:
	p++
	if p == pe { goto _test_eof460 }
	fallthrough
case 460:
	switch data[p] {
		case 9: goto tr1643
		case 10: goto tr1644
		case 32: goto tr1643
		case 40: goto tr1645
		case 41: goto tr1646
		case 43: goto st97
		case 59: goto tr1647
		case 61: goto st97
		case 92: goto st97
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr1650:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st461
tr1651:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st461
tr1649:
// line 101 "zparse.rl"
	{ lines++ }
	goto st461
tr1643:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st461
tr1644:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st461
tr1645:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st461
tr1646:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st461
st461:
	p++
	if p == pe { goto _test_eof461 }
	fallthrough
case 461:
// line 30927 "zparse.go"
	switch data[p] {
		case 9: goto st461
		case 10: goto tr1649
		case 32: goto st461
		case 40: goto tr1650
		case 41: goto tr1651
		case 43: goto tr1652
		case 59: goto st463
		case 61: goto tr1652
		case 92: goto tr1652
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr1652 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr1652 }
	} else {
		goto tr1652
	}
	goto st0
tr1652:
// line 89 "zparse.rl"
	{ mark = p }
	goto st462
st462:
	p++
	if p == pe { goto _test_eof462 }
	fallthrough
case 462:
// line 30956 "zparse.go"
	switch data[p] {
		case 9: goto tr1654
		case 10: goto tr1655
		case 32: goto tr1654
		case 40: goto tr1656
		case 41: goto tr1657
		case 43: goto st462
		case 59: goto tr1659
		case 61: goto st462
		case 92: goto st462
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st462 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st462 }
	} else {
		goto st462
	}
	goto st0
tr1647:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st463
st463:
	p++
	if p == pe { goto _test_eof463 }
	fallthrough
case 463:
// line 30996 "zparse.go"
	if data[p] == 10 { goto tr1649 }
	goto st463
st464:
	p++
	if p == pe { goto _test_eof464 }
	fallthrough
case 464:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 89: goto st465
		case 92: goto st97
		case 121: goto st465
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st465:
	p++
	if p == pe { goto _test_eof465 }
	fallthrough
case 465:
	switch data[p] {
		case 9: goto tr1661
		case 10: goto tr1662
		case 32: goto tr1661
		case 40: goto tr1663
		case 41: goto tr1664
		case 43: goto st97
		case 59: goto tr1665
		case 61: goto st97
		case 92: goto st97
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr1668:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st466
tr1669:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st466
tr1667:
// line 101 "zparse.rl"
	{ lines++ }
	goto st466
tr1661:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st466
tr1662:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st466
tr1663:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st466
tr1664:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st466
st466:
	p++
	if p == pe { goto _test_eof466 }
	fallthrough
case 466:
// line 31096 "zparse.go"
	switch data[p] {
		case 9: goto st466
		case 10: goto tr1667
		case 32: goto st466
		case 40: goto tr1668
		case 41: goto tr1669
		case 43: goto tr398
		case 59: goto st467
		case 61: goto tr398
		case 65: goto tr1671
		case 67: goto tr1672
		case 68: goto tr1673
		case 77: goto tr1674
		case 78: goto tr1675
		case 82: goto tr1676
		case 83: goto tr1677
		case 92: goto tr398
		case 97: goto tr1671
		case 99: goto tr1672
		case 100: goto tr1673
		case 109: goto tr1674
		case 110: goto tr1675
		case 114: goto tr1676
		case 115: goto tr1677
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto tr398 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto tr398 }
	} else {
		goto tr398
	}
	goto st0
tr1665:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st467
st467:
	p++
	if p == pe { goto _test_eof467 }
	fallthrough
case 467:
// line 31141 "zparse.go"
	if data[p] == 10 { goto tr1667 }
	goto st467
tr1671:
// line 89 "zparse.rl"
	{ mark = p }
	goto st468
st468:
	p++
	if p == pe { goto _test_eof468 }
	fallthrough
case 468:
// line 31153 "zparse.go"
	switch data[p] {
		case 9: goto tr1678
		case 10: goto tr1679
		case 32: goto tr1678
		case 40: goto tr1680
		case 41: goto tr1681
		case 43: goto st99
		case 59: goto tr1682
		case 61: goto st99
		case 65: goto st469
		case 92: goto st99
		case 97: goto st469
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st469:
	p++
	if p == pe { goto _test_eof469 }
	fallthrough
case 469:
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 65: goto st470
		case 92: goto st99
		case 97: goto st470
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st470:
	p++
	if p == pe { goto _test_eof470 }
	fallthrough
case 470:
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 65: goto st471
		case 92: goto st99
		case 97: goto st471
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st471:
	p++
	if p == pe { goto _test_eof471 }
	fallthrough
case 471:
	switch data[p] {
		case 9: goto tr1686
		case 10: goto tr1687
		case 32: goto tr1686
		case 40: goto tr1688
		case 41: goto tr1689
		case 43: goto st99
		case 59: goto tr1690
		case 61: goto st99
		case 92: goto st99
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
tr1672:
// line 89 "zparse.rl"
	{ mark = p }
	goto st472
st472:
	p++
	if p == pe { goto _test_eof472 }
	fallthrough
case 472:
// line 31260 "zparse.go"
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 78: goto st473
		case 92: goto st99
		case 110: goto st473
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st473:
	p++
	if p == pe { goto _test_eof473 }
	fallthrough
case 473:
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 65: goto st474
		case 92: goto st99
		case 97: goto st474
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st474:
	p++
	if p == pe { goto _test_eof474 }
	fallthrough
case 474:
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 77: goto st475
		case 92: goto st99
		case 109: goto st475
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st475:
	p++
	if p == pe { goto _test_eof475 }
	fallthrough
case 475:
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 69: goto st476
		case 92: goto st99
		case 101: goto st476
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st476:
	p++
	if p == pe { goto _test_eof476 }
	fallthrough
case 476:
	switch data[p] {
		case 9: goto tr1695
		case 10: goto tr1696
		case 32: goto tr1695
		case 40: goto tr1697
		case 41: goto tr1698
		case 43: goto st99
		case 59: goto tr1699
		case 61: goto st99
		case 92: goto st99
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
tr1673:
// line 89 "zparse.rl"
	{ mark = p }
	goto st477
st477:
	p++
	if p == pe { goto _test_eof477 }
	fallthrough
case 477:
// line 31393 "zparse.go"
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 78: goto st478
		case 83: goto st483
		case 92: goto st99
		case 110: goto st478
		case 115: goto st483
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st478:
	p++
	if p == pe { goto _test_eof478 }
	fallthrough
case 478:
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 83: goto st479
		case 92: goto st99
		case 115: goto st479
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st479:
	p++
	if p == pe { goto _test_eof479 }
	fallthrough
case 479:
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 75: goto st480
		case 92: goto st99
		case 107: goto st480
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st480:
	p++
	if p == pe { goto _test_eof480 }
	fallthrough
case 480:
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 69: goto st481
		case 92: goto st99
		case 101: goto st481
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st481:
	p++
	if p == pe { goto _test_eof481 }
	fallthrough
case 481:
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 89: goto st482
		case 92: goto st99
		case 121: goto st482
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st482:
	p++
	if p == pe { goto _test_eof482 }
	fallthrough
case 482:
	switch data[p] {
		case 9: goto tr1706
		case 10: goto tr1707
		case 32: goto tr1706
		case 40: goto tr1708
		case 41: goto tr1709
		case 43: goto st99
		case 59: goto tr1710
		case 61: goto st99
		case 92: goto st99
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st483:
	p++
	if p == pe { goto _test_eof483 }
	fallthrough
case 483:
	switch data[p] {
		case 9: goto tr1711
		case 10: goto tr1712
		case 32: goto tr1711
		case 40: goto tr1713
		case 41: goto tr1714
		case 43: goto st99
		case 59: goto tr1715
		case 61: goto st99
		case 92: goto st99
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
tr1046:
// line 89 "zparse.rl"
	{ mark = p }
	goto st484
tr1041:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st484
tr1715:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st484
tr1792:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st484
tr2338:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st484
tr2501:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st484
tr2647:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st484
tr3754:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st484
tr3898:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st484
st484:
	p++
	if p == pe { goto _test_eof484 }
	fallthrough
case 484:
// line 31777 "zparse.go"
	if data[p] == 10 { goto tr1717 }
	goto st484
tr1674:
// line 89 "zparse.rl"
	{ mark = p }
	goto st485
st485:
	p++
	if p == pe { goto _test_eof485 }
	fallthrough
case 485:
// line 31789 "zparse.go"
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 88: goto st486
		case 92: goto st99
		case 120: goto st486
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st486:
	p++
	if p == pe { goto _test_eof486 }
	fallthrough
case 486:
	switch data[p] {
		case 9: goto tr1719
		case 10: goto tr1720
		case 32: goto tr1719
		case 40: goto tr1721
		case 41: goto tr1722
		case 43: goto st99
		case 59: goto tr1723
		case 61: goto st99
		case 92: goto st99
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
tr1726:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st487
tr1727:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st487
tr1794:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr1796:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr1797:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr2927:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr2929:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr2930:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr1719:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr1721:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr1722:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr2340:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr2342:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr2343:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr2503:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr2505:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr2506:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr2649:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr2651:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr2652:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr3756:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr3758:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr3759:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr3900:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr3902:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
tr3903:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st487
st487:
	p++
	if p == pe { goto _test_eof487 }
	fallthrough
case 487:
// line 32477 "zparse.go"
	switch data[p] {
		case 9: goto st487
		case 10: goto tr1725
		case 32: goto st487
		case 40: goto tr1726
		case 41: goto tr1727
		case 59: goto tr1728
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr251 }
	goto st0
tr1725:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1743
tr1800:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1743
tr1795:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1743
tr2928:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1743
tr1720:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1743
tr2341:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1743
tr2504:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1743
tr2650:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1743
tr3757:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1743
tr3901:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1743
st1743:
	p++
	if p == pe { goto _test_eof1743 }
	fallthrough
case 1743:
// line 32718 "zparse.go"
	switch data[p] {
		case 9: goto st488
		case 10: goto tr1730
		case 32: goto st488
		case 40: goto tr1731
		case 41: goto tr1732
		case 59: goto tr1733
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5405
	}
	goto st0
tr1731:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st488
tr1732:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st488
tr2252:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st488
tr2254:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st488
tr2255:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st488
tr2442:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st488
tr2444:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st488
tr2445:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st488
tr2582:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st488
tr2584:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st488
tr2585:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st488
tr1879:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st488
tr1881:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st488
tr1882:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st488
tr4027:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st488
tr4029:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st488
tr4030:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st488
st488:
	p++
	if p == pe { goto _test_eof488 }
	fallthrough
case 488:
// line 33152 "zparse.go"
	switch data[p] {
		case 9: goto st488
		case 10: goto tr1730
		case 32: goto st488
		case 40: goto tr1731
		case 41: goto tr1732
		case 59: goto tr1733
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr849 }
	goto st0
tr1730:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1744
tr1885:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1744
tr2253:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1744
tr2443:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1744
tr2583:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1744
tr1880:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1744
tr4028:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1744
st1744:
	p++
	if p == pe { goto _test_eof1744 }
	fallthrough
case 1744:
// line 33332 "zparse.go"
	switch data[p] {
		case 9: goto st488
		case 10: goto tr1730
		case 32: goto st488
		case 40: goto tr1731
		case 41: goto tr1732
		case 59: goto tr1733
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5406
	}
	goto st0
tr5406:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st489
st489:
	p++
	if p == pe { goto _test_eof489 }
	fallthrough
case 489:
// line 33384 "zparse.go"
	switch data[p] {
		case 9: goto tr1734
		case 10: goto tr1735
		case 32: goto tr1734
		case 40: goto tr1736
		case 41: goto tr1737
		case 59: goto tr1739
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st489
	}
	goto st0
tr1742:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st490
tr1743:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st490
tr1741:
// line 101 "zparse.rl"
	{ lines++ }
	goto st490
tr1734:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st490
tr1735:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st490
tr1736:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st490
tr1737:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st490
tr5290:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st490
tr5291:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st490
tr5292:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st490
tr5293:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st490
st490:
	p++
	if p == pe { goto _test_eof490 }
	fallthrough
case 490:
// line 33492 "zparse.go"
	switch data[p] {
		case 9: goto st490
		case 10: goto tr1741
		case 32: goto st490
		case 40: goto tr1742
		case 41: goto tr1743
		case 43: goto tr263
		case 58: goto tr263
		case 59: goto st492
		case 61: goto tr263
		case 65: goto tr1746
		case 67: goto tr1747
		case 68: goto tr1748
		case 72: goto tr1749
		case 73: goto tr1750
		case 77: goto tr1751
		case 78: goto tr1752
		case 82: goto tr1753
		case 83: goto tr1754
		case 92: goto tr263
		case 97: goto tr1746
		case 99: goto tr1747
		case 100: goto tr1748
		case 104: goto tr1749
		case 105: goto tr1750
		case 109: goto tr1751
		case 110: goto tr1752
		case 114: goto tr1753
		case 115: goto tr1754
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr263 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr263 }
		} else if data[p] >= 66 {
			goto tr263
		}
	} else {
		goto tr1744
	}
	goto st0
tr1744:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st491
st491:
	p++
	if p == pe { goto _test_eof491 }
	fallthrough
case 491:
// line 33546 "zparse.go"
	switch data[p] {
		case 9: goto tr1755
		case 10: goto tr1756
		case 32: goto tr1755
		case 40: goto tr1757
		case 41: goto tr1758
		case 43: goto st69
		case 58: goto st69
		case 59: goto tr1760
		case 61: goto st69
		case 92: goto st69
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st69 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st69 }
		} else if data[p] >= 65 {
			goto st69
		}
	} else {
		goto st491
	}
	goto st0
tr1739:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st492
tr5295:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st492
st492:
	p++
	if p == pe { goto _test_eof492 }
	fallthrough
case 492:
// line 33590 "zparse.go"
	if data[p] == 10 { goto tr1741 }
	goto st492
tr1746:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st493
st493:
	p++
	if p == pe { goto _test_eof493 }
	fallthrough
case 493:
// line 33604 "zparse.go"
	switch data[p] {
		case 9: goto tr871
		case 10: goto tr872
		case 32: goto tr871
		case 40: goto tr873
		case 41: goto tr874
		case 43: goto st69
		case 59: goto tr875
		case 61: goto st69
		case 65: goto st248
		case 78: goto st494
		case 92: goto st69
		case 97: goto st248
		case 110: goto st494
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st494:
	p++
	if p == pe { goto _test_eof494 }
	fallthrough
case 494:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 89: goto st495
		case 92: goto st69
		case 121: goto st495
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st495:
	p++
	if p == pe { goto _test_eof495 }
	fallthrough
case 495:
	switch data[p] {
		case 9: goto tr1763
		case 10: goto tr1764
		case 32: goto tr1763
		case 40: goto tr1765
		case 41: goto tr1766
		case 43: goto st69
		case 59: goto tr1767
		case 61: goto st69
		case 92: goto st69
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr1747:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st496
st496:
	p++
	if p == pe { goto _test_eof496 }
	fallthrough
case 496:
// line 33689 "zparse.go"
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 72: goto st495
		case 78: goto st497
		case 83: goto st495
		case 92: goto st69
		case 104: goto st495
		case 110: goto st497
		case 115: goto st495
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st497:
	p++
	if p == pe { goto _test_eof497 }
	fallthrough
case 497:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 65: goto st498
		case 92: goto st69
		case 97: goto st498
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st498:
	p++
	if p == pe { goto _test_eof498 }
	fallthrough
case 498:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 77: goto st499
		case 92: goto st69
		case 109: goto st499
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st499:
	p++
	if p == pe { goto _test_eof499 }
	fallthrough
case 499:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 69: goto st500
		case 92: goto st69
		case 101: goto st500
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st500:
	p++
	if p == pe { goto _test_eof500 }
	fallthrough
case 500:
	switch data[p] {
		case 9: goto tr1772
		case 10: goto tr1773
		case 32: goto tr1772
		case 40: goto tr1774
		case 41: goto tr1775
		case 43: goto st69
		case 59: goto tr1776
		case 61: goto st69
		case 92: goto st69
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr1748:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st501
tr864:
// line 89 "zparse.rl"
	{ mark = p }
	goto st501
st501:
	p++
	if p == pe { goto _test_eof501 }
	fallthrough
case 501:
// line 33832 "zparse.go"
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 78: goto st502
		case 83: goto st507
		case 92: goto st69
		case 110: goto st502
		case 115: goto st507
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st502:
	p++
	if p == pe { goto _test_eof502 }
	fallthrough
case 502:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 83: goto st503
		case 92: goto st69
		case 115: goto st503
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st503:
	p++
	if p == pe { goto _test_eof503 }
	fallthrough
case 503:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 75: goto st504
		case 92: goto st69
		case 107: goto st504
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st504:
	p++
	if p == pe { goto _test_eof504 }
	fallthrough
case 504:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 69: goto st505
		case 92: goto st69
		case 101: goto st505
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st505:
	p++
	if p == pe { goto _test_eof505 }
	fallthrough
case 505:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 89: goto st506
		case 92: goto st69
		case 121: goto st506
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st506:
	p++
	if p == pe { goto _test_eof506 }
	fallthrough
case 506:
	switch data[p] {
		case 9: goto tr1783
		case 10: goto tr1784
		case 32: goto tr1783
		case 40: goto tr1785
		case 41: goto tr1786
		case 43: goto st69
		case 59: goto tr1787
		case 61: goto st69
		case 92: goto st69
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st507:
	p++
	if p == pe { goto _test_eof507 }
	fallthrough
case 507:
	switch data[p] {
		case 9: goto tr1788
		case 10: goto tr1789
		case 32: goto tr1788
		case 40: goto tr1790
		case 41: goto tr1791
		case 43: goto st69
		case 59: goto tr1792
		case 61: goto st69
		case 92: goto st69
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr1749:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st508
st508:
	p++
	if p == pe { goto _test_eof508 }
	fallthrough
case 508:
// line 34019 "zparse.go"
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 83: goto st495
		case 92: goto st69
		case 115: goto st495
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr1750:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st509
st509:
	p++
	if p == pe { goto _test_eof509 }
	fallthrough
case 509:
// line 34052 "zparse.go"
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 78: goto st495
		case 92: goto st69
		case 110: goto st495
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr1751:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st510
tr867:
// line 89 "zparse.rl"
	{ mark = p }
	goto st510
st510:
	p++
	if p == pe { goto _test_eof510 }
	fallthrough
case 510:
// line 34089 "zparse.go"
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 88: goto st511
		case 92: goto st69
		case 120: goto st511
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st511:
	p++
	if p == pe { goto _test_eof511 }
	fallthrough
case 511:
	switch data[p] {
		case 9: goto tr1794
		case 10: goto tr1795
		case 32: goto tr1794
		case 40: goto tr1796
		case 41: goto tr1797
		case 43: goto st69
		case 59: goto tr1798
		case 61: goto st69
		case 92: goto st69
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr1728:
// line 89 "zparse.rl"
	{ mark = p }
	goto st512
tr1798:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st512
tr2931:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st512
tr1723:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st512
tr2344:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st512
tr2507:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st512
tr2653:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st512
tr3760:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st512
tr3904:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st512
st512:
	p++
	if p == pe { goto _test_eof512 }
	fallthrough
case 512:
// line 34343 "zparse.go"
	if data[p] == 10 { goto tr1800 }
	goto st512
tr1752:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st513
st513:
	p++
	if p == pe { goto _test_eof513 }
	fallthrough
case 513:
// line 34357 "zparse.go"
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 79: goto st514
		case 83: goto st516
		case 92: goto st69
		case 111: goto st514
		case 115: goto st516
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st514:
	p++
	if p == pe { goto _test_eof514 }
	fallthrough
case 514:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 78: goto st515
		case 92: goto st69
		case 110: goto st515
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st515:
	p++
	if p == pe { goto _test_eof515 }
	fallthrough
case 515:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 69: goto st495
		case 92: goto st69
		case 101: goto st495
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st516:
	p++
	if p == pe { goto _test_eof516 }
	fallthrough
case 516:
	switch data[p] {
		case 9: goto tr1804
		case 10: goto tr1805
		case 32: goto tr1804
		case 40: goto tr1806
		case 41: goto tr1807
		case 43: goto st69
		case 59: goto tr1808
		case 61: goto st69
		case 92: goto st69
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr1811:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st517
tr1812:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st517
tr2657:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr2659:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr2660:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr1804:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr1806:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr1807:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr2935:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr2937:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr2938:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr3584:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr3586:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr3587:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr2348:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr2350:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr2351:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr2511:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr2513:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr2514:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr3764:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr3766:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr3767:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr3908:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr3910:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
tr3911:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st517
st517:
	p++
	if p == pe { goto _test_eof517 }
	fallthrough
case 517:
// line 35099 "zparse.go"
	switch data[p] {
		case 9: goto st517
		case 10: goto tr1810
		case 32: goto st517
		case 40: goto tr1811
		case 41: goto tr1812
		case 43: goto tr281
		case 59: goto tr1813
		case 61: goto tr281
		case 92: goto tr281
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr281 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr281 }
	} else {
		goto tr281
	}
	goto st0
tr1810:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1745
tr2354:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1745
tr2658:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1745
tr1805:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1745
tr2936:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1745
tr3585:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1745
tr2349:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1745
tr2512:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1745
tr3765:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1745
tr3909:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1745
st1745:
	p++
	if p == pe { goto _test_eof1745 }
	fallthrough
case 1745:
// line 35349 "zparse.go"
	switch data[p] {
		case 9: goto st518
		case 10: goto tr1815
		case 32: goto st518
		case 40: goto tr1816
		case 41: goto tr1817
		case 43: goto tr281
		case 47: goto tr281
		case 58: goto tr281
		case 59: goto tr1818
		case 61: goto tr281
		case 92: goto tr5407
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto tr5407 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr5407 }
	} else {
		goto tr5407
	}
	goto st0
tr1816:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st518
tr1817:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st518
tr2260:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st518
tr2262:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st518
tr2263:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st518
tr2450:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st518
tr2452:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st518
tr2453:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st518
tr2590:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st518
tr2592:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st518
tr2593:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st518
tr1889:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st518
tr1891:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st518
tr1892:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st518
tr4035:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st518
tr4037:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st518
tr4038:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st518
st518:
	p++
	if p == pe { goto _test_eof518 }
	fallthrough
case 518:
// line 35783 "zparse.go"
	switch data[p] {
		case 9: goto st518
		case 10: goto tr1815
		case 32: goto st518
		case 40: goto tr1816
		case 41: goto tr1817
		case 43: goto tr281
		case 58: goto tr281
		case 59: goto tr1818
		case 61: goto tr281
		case 65: goto tr960
		case 67: goto tr961
		case 68: goto tr962
		case 72: goto tr963
		case 73: goto tr964
		case 77: goto tr965
		case 78: goto tr966
		case 82: goto tr967
		case 83: goto tr968
		case 92: goto tr281
		case 97: goto tr960
		case 99: goto tr961
		case 100: goto tr962
		case 104: goto tr963
		case 105: goto tr964
		case 109: goto tr965
		case 110: goto tr966
		case 114: goto tr967
		case 115: goto tr968
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr281 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr281 }
		} else if data[p] >= 66 {
			goto tr281
		}
	} else {
		goto tr958
	}
	goto st0
tr1815:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1746
tr1832:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1746
tr2261:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1746
tr2451:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1746
tr2591:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1746
tr1890:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1746
tr4036:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1746
st1746:
	p++
	if p == pe { goto _test_eof1746 }
	fallthrough
case 1746:
// line 35977 "zparse.go"
	switch data[p] {
		case 9: goto st518
		case 10: goto tr1815
		case 32: goto st518
		case 40: goto tr1816
		case 41: goto tr1817
		case 43: goto tr281
		case 47: goto tr281
		case 58: goto tr281
		case 59: goto tr1818
		case 61: goto tr281
		case 65: goto tr5409
		case 67: goto tr5410
		case 68: goto tr5411
		case 72: goto tr5412
		case 73: goto tr5413
		case 77: goto tr5414
		case 78: goto tr5415
		case 82: goto tr5416
		case 83: goto tr5417
		case 92: goto tr5407
		case 95: goto st2
		case 97: goto tr5409
		case 99: goto tr5410
		case 100: goto tr5411
		case 104: goto tr5412
		case 105: goto tr5413
		case 109: goto tr5414
		case 110: goto tr5415
		case 114: goto tr5416
		case 115: goto tr5417
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5407 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr5407 }
		} else if data[p] >= 66 {
			goto tr5407
		}
	} else {
		goto tr5408
	}
	goto st0
tr5407:
// line 89 "zparse.rl"
	{ mark = p }
	goto st519
st519:
	p++
	if p == pe { goto _test_eof519 }
	fallthrough
case 519:
// line 36031 "zparse.go"
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 92: goto st519
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
tr5408:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st520
st520:
	p++
	if p == pe { goto _test_eof520 }
	fallthrough
case 520:
// line 36065 "zparse.go"
	switch data[p] {
		case 9: goto tr1825
		case 10: goto tr1826
		case 32: goto tr1825
		case 40: goto tr1827
		case 41: goto tr1828
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1830
		case 61: goto st75
		case 92: goto st519
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st519 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st519 }
		} else if data[p] >= 65 {
			goto st519
		}
	} else {
		goto st520
	}
	goto st0
tr1818:
// line 89 "zparse.rl"
	{ mark = p }
	goto st521
tr2264:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st521
tr2454:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st521
tr2594:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st521
tr1893:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st521
tr4039:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st521
st521:
	p++
	if p == pe { goto _test_eof521 }
	fallthrough
case 521:
// line 36227 "zparse.go"
	if data[p] == 10 { goto tr1832 }
	goto st521
tr5409:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st522
st522:
	p++
	if p == pe { goto _test_eof522 }
	fallthrough
case 522:
// line 36241 "zparse.go"
	switch data[p] {
		case 9: goto tr1833
		case 10: goto tr1834
		case 32: goto tr1833
		case 40: goto tr1835
		case 41: goto tr1836
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1837
		case 61: goto st75
		case 65: goto st523
		case 78: goto st526
		case 92: goto st519
		case 95: goto st2
		case 97: goto st523
		case 110: goto st526
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st523:
	p++
	if p == pe { goto _test_eof523 }
	fallthrough
case 523:
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 65: goto st524
		case 92: goto st519
		case 95: goto st2
		case 97: goto st524
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st524:
	p++
	if p == pe { goto _test_eof524 }
	fallthrough
case 524:
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 65: goto st525
		case 92: goto st519
		case 95: goto st2
		case 97: goto st525
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st525:
	p++
	if p == pe { goto _test_eof525 }
	fallthrough
case 525:
	switch data[p] {
		case 9: goto tr1842
		case 10: goto tr1843
		case 32: goto tr1842
		case 40: goto tr1844
		case 41: goto tr1845
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1846
		case 61: goto st75
		case 92: goto st519
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st526:
	p++
	if p == pe { goto _test_eof526 }
	fallthrough
case 526:
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 89: goto st527
		case 92: goto st519
		case 95: goto st2
		case 121: goto st527
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st527:
	p++
	if p == pe { goto _test_eof527 }
	fallthrough
case 527:
	switch data[p] {
		case 9: goto tr1848
		case 10: goto tr1849
		case 32: goto tr1848
		case 40: goto tr1850
		case 41: goto tr1851
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1852
		case 61: goto st75
		case 92: goto st519
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
tr5410:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st528
st528:
	p++
	if p == pe { goto _test_eof528 }
	fallthrough
case 528:
// line 36420 "zparse.go"
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 72: goto st527
		case 78: goto st529
		case 83: goto st527
		case 92: goto st519
		case 95: goto st2
		case 104: goto st527
		case 110: goto st529
		case 115: goto st527
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st529:
	p++
	if p == pe { goto _test_eof529 }
	fallthrough
case 529:
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 65: goto st530
		case 92: goto st519
		case 95: goto st2
		case 97: goto st530
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st530:
	p++
	if p == pe { goto _test_eof530 }
	fallthrough
case 530:
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 77: goto st531
		case 92: goto st519
		case 95: goto st2
		case 109: goto st531
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st531:
	p++
	if p == pe { goto _test_eof531 }
	fallthrough
case 531:
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 69: goto st532
		case 92: goto st519
		case 95: goto st2
		case 101: goto st532
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st532:
	p++
	if p == pe { goto _test_eof532 }
	fallthrough
case 532:
	switch data[p] {
		case 9: goto tr1857
		case 10: goto tr1858
		case 32: goto tr1857
		case 40: goto tr1859
		case 41: goto tr1860
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1861
		case 61: goto st75
		case 92: goto st519
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
tr5411:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st533
st533:
	p++
	if p == pe { goto _test_eof533 }
	fallthrough
case 533:
// line 36574 "zparse.go"
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 78: goto st534
		case 83: goto st539
		case 92: goto st519
		case 95: goto st2
		case 110: goto st534
		case 115: goto st539
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st534:
	p++
	if p == pe { goto _test_eof534 }
	fallthrough
case 534:
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 83: goto st535
		case 92: goto st519
		case 95: goto st2
		case 115: goto st535
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st535:
	p++
	if p == pe { goto _test_eof535 }
	fallthrough
case 535:
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 75: goto st536
		case 92: goto st519
		case 95: goto st2
		case 107: goto st536
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st536:
	p++
	if p == pe { goto _test_eof536 }
	fallthrough
case 536:
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 69: goto st537
		case 92: goto st519
		case 95: goto st2
		case 101: goto st537
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st537:
	p++
	if p == pe { goto _test_eof537 }
	fallthrough
case 537:
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 89: goto st538
		case 92: goto st519
		case 95: goto st2
		case 121: goto st538
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st538:
	p++
	if p == pe { goto _test_eof538 }
	fallthrough
case 538:
	switch data[p] {
		case 9: goto tr1868
		case 10: goto tr1869
		case 32: goto tr1868
		case 40: goto tr1870
		case 41: goto tr1871
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1872
		case 61: goto st75
		case 92: goto st519
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st539:
	p++
	if p == pe { goto _test_eof539 }
	fallthrough
case 539:
	switch data[p] {
		case 9: goto tr1873
		case 10: goto tr1874
		case 32: goto tr1873
		case 40: goto tr1875
		case 41: goto tr1876
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1877
		case 61: goto st75
		case 92: goto st519
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
tr5412:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st540
st540:
	p++
	if p == pe { goto _test_eof540 }
	fallthrough
case 540:
// line 36782 "zparse.go"
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 83: goto st527
		case 92: goto st519
		case 95: goto st2
		case 115: goto st527
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
tr5413:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st541
st541:
	p++
	if p == pe { goto _test_eof541 }
	fallthrough
case 541:
// line 36818 "zparse.go"
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 78: goto st527
		case 92: goto st519
		case 95: goto st2
		case 110: goto st527
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
tr5414:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st542
st542:
	p++
	if p == pe { goto _test_eof542 }
	fallthrough
case 542:
// line 36854 "zparse.go"
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 88: goto st543
		case 92: goto st519
		case 95: goto st2
		case 120: goto st543
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st543:
	p++
	if p == pe { goto _test_eof543 }
	fallthrough
case 543:
	switch data[p] {
		case 9: goto tr1879
		case 10: goto tr1880
		case 32: goto tr1879
		case 40: goto tr1881
		case 41: goto tr1882
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1883
		case 61: goto st75
		case 92: goto st519
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
tr1733:
// line 89 "zparse.rl"
	{ mark = p }
	goto st544
tr2256:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st544
tr2446:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st544
tr2586:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st544
tr1883:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st544
tr4031:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st544
st544:
	p++
	if p == pe { goto _test_eof544 }
	fallthrough
case 544:
// line 37041 "zparse.go"
	if data[p] == 10 { goto tr1885 }
	goto st544
tr5415:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st545
st545:
	p++
	if p == pe { goto _test_eof545 }
	fallthrough
case 545:
// line 37055 "zparse.go"
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 79: goto st546
		case 83: goto st548
		case 92: goto st519
		case 95: goto st2
		case 111: goto st546
		case 115: goto st548
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st546:
	p++
	if p == pe { goto _test_eof546 }
	fallthrough
case 546:
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 78: goto st547
		case 92: goto st519
		case 95: goto st2
		case 110: goto st547
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st547:
	p++
	if p == pe { goto _test_eof547 }
	fallthrough
case 547:
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 69: goto st527
		case 92: goto st519
		case 95: goto st2
		case 101: goto st527
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st548:
	p++
	if p == pe { goto _test_eof548 }
	fallthrough
case 548:
	switch data[p] {
		case 9: goto tr1889
		case 10: goto tr1890
		case 32: goto tr1889
		case 40: goto tr1891
		case 41: goto tr1892
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1893
		case 61: goto st75
		case 92: goto st519
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
tr5416:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st549
st549:
	p++
	if p == pe { goto _test_eof549 }
	fallthrough
case 549:
// line 37178 "zparse.go"
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 82: goto st550
		case 92: goto st519
		case 95: goto st2
		case 114: goto st550
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st550:
	p++
	if p == pe { goto _test_eof550 }
	fallthrough
case 550:
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 83: goto st551
		case 92: goto st519
		case 95: goto st2
		case 115: goto st551
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st551:
	p++
	if p == pe { goto _test_eof551 }
	fallthrough
case 551:
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 73: goto st552
		case 92: goto st519
		case 95: goto st2
		case 105: goto st552
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st552:
	p++
	if p == pe { goto _test_eof552 }
	fallthrough
case 552:
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 71: goto st553
		case 92: goto st519
		case 95: goto st2
		case 103: goto st553
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st553:
	p++
	if p == pe { goto _test_eof553 }
	fallthrough
case 553:
	switch data[p] {
		case 9: goto tr1898
		case 10: goto tr1899
		case 32: goto tr1898
		case 40: goto tr1900
		case 41: goto tr1901
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1902
		case 61: goto st75
		case 92: goto st519
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
tr1905:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st554
tr1906:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st554
tr2269:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st554
tr2271:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st554
tr2272:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st554
tr2459:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st554
tr2461:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st554
tr2462:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st554
tr2599:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st554
tr2601:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st554
tr2602:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st554
tr1898:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st554
tr1900:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st554
tr1901:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st554
tr4044:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st554
tr4046:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st554
tr4047:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st554
st554:
	p++
	if p == pe { goto _test_eof554 }
	fallthrough
case 554:
// line 37728 "zparse.go"
	switch data[p] {
		case 9: goto st554
		case 10: goto tr1904
		case 32: goto st554
		case 40: goto tr1905
		case 41: goto tr1906
		case 59: goto tr1907
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1092 }
	goto st0
tr1904:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1747
tr1932:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1747
tr2270:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1747
tr2460:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1747
tr2600:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1747
tr1899:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1747
tr4045:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1747
st1747:
	p++
	if p == pe { goto _test_eof1747 }
	fallthrough
case 1747:
// line 37908 "zparse.go"
	switch data[p] {
		case 9: goto st554
		case 10: goto tr1904
		case 32: goto st554
		case 40: goto tr1905
		case 41: goto tr1906
		case 59: goto tr1907
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5418
	}
	goto st0
tr5418:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st555
st555:
	p++
	if p == pe { goto _test_eof555 }
	fallthrough
case 555:
// line 37960 "zparse.go"
	switch data[p] {
		case 9: goto tr1908
		case 10: goto tr1909
		case 32: goto tr1908
		case 40: goto tr1910
		case 41: goto tr1911
		case 59: goto tr1913
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st555
	}
	goto st0
tr1916:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st556
tr1917:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st556
tr1915:
// line 101 "zparse.rl"
	{ lines++ }
	goto st556
tr1908:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st556
tr1909:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st556
tr1910:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st556
tr1911:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st556
tr2369:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st556
tr2370:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st556
tr2371:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st556
tr2372:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st556
st556:
	p++
	if p == pe { goto _test_eof556 }
	fallthrough
case 556:
// line 38068 "zparse.go"
	switch data[p] {
		case 9: goto st556
		case 10: goto tr1915
		case 32: goto st556
		case 40: goto tr1916
		case 41: goto tr1917
		case 59: goto st560
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1918 }
	goto st0
tr1918:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st557
st557:
	p++
	if p == pe { goto _test_eof557 }
	fallthrough
case 557:
// line 38108 "zparse.go"
	switch data[p] {
		case 9: goto tr1920
		case 10: goto tr1921
		case 32: goto tr1920
		case 40: goto tr1922
		case 41: goto tr1923
		case 59: goto tr1925
	}
	if 48 <= data[p] && data[p] <= 57 { goto st557 }
	goto st0
tr1928:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st558
tr1929:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st558
tr1927:
// line 101 "zparse.rl"
	{ lines++ }
	goto st558
tr1920:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st558
tr1921:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st558
tr1922:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st558
tr1923:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st558
st558:
	p++
	if p == pe { goto _test_eof558 }
	fallthrough
case 558:
// line 38166 "zparse.go"
	switch data[p] {
		case 9: goto st558
		case 10: goto tr1927
		case 32: goto st558
		case 40: goto tr1928
		case 41: goto tr1929
		case 59: goto st559
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr326 }
	goto st0
tr1925:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st559
st559:
	p++
	if p == pe { goto _test_eof559 }
	fallthrough
case 559:
// line 38206 "zparse.go"
	if data[p] == 10 { goto tr1927 }
	goto st559
tr1913:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st560
tr2374:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st560
st560:
	p++
	if p == pe { goto _test_eof560 }
	fallthrough
case 560:
// line 38228 "zparse.go"
	if data[p] == 10 { goto tr1915 }
	goto st560
tr1907:
// line 89 "zparse.rl"
	{ mark = p }
	goto st561
tr2273:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st561
tr2463:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st561
tr2603:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st561
tr1902:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st561
tr4048:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st561
st561:
	p++
	if p == pe { goto _test_eof561 }
	fallthrough
case 561:
// line 38366 "zparse.go"
	if data[p] == 10 { goto tr1932 }
	goto st561
tr5417:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st562
st562:
	p++
	if p == pe { goto _test_eof562 }
	fallthrough
case 562:
// line 38380 "zparse.go"
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 79: goto st563
		case 92: goto st519
		case 95: goto st2
		case 111: goto st563
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st563:
	p++
	if p == pe { goto _test_eof563 }
	fallthrough
case 563:
	switch data[p] {
		case 9: goto tr1819
		case 10: goto tr1820
		case 32: goto tr1819
		case 40: goto tr1821
		case 41: goto tr1822
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1824
		case 61: goto st75
		case 65: goto st564
		case 92: goto st519
		case 95: goto st2
		case 97: goto st564
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
st564:
	p++
	if p == pe { goto _test_eof564 }
	fallthrough
case 564:
	switch data[p] {
		case 9: goto tr1935
		case 10: goto tr1936
		case 32: goto tr1935
		case 40: goto tr1937
		case 41: goto tr1938
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr1939
		case 61: goto st75
		case 92: goto st519
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st519 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st519 }
	} else {
		goto st519
	}
	goto st0
tr1942:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st565
tr1943:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st565
tr2276:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st565
tr2278:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st565
tr2279:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st565
tr2466:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st565
tr2468:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st565
tr2469:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st565
tr2606:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st565
tr2608:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st565
tr2609:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st565
tr1935:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st565
tr1937:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st565
tr1938:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st565
tr4051:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st565
tr4053:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st565
tr4054:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st565
st565:
	p++
	if p == pe { goto _test_eof565 }
	fallthrough
case 565:
// line 38872 "zparse.go"
	switch data[p] {
		case 9: goto st565
		case 10: goto tr1941
		case 32: goto st565
		case 40: goto tr1942
		case 41: goto tr1943
		case 43: goto tr417
		case 58: goto tr417
		case 59: goto tr1944
		case 61: goto tr417
		case 65: goto tr1118
		case 67: goto tr1119
		case 68: goto tr1120
		case 72: goto tr1121
		case 73: goto tr1122
		case 77: goto tr1123
		case 78: goto tr1124
		case 82: goto tr1125
		case 83: goto tr1126
		case 92: goto tr417
		case 97: goto tr1118
		case 99: goto tr1119
		case 100: goto tr1120
		case 104: goto tr1121
		case 105: goto tr1122
		case 109: goto tr1123
		case 110: goto tr1124
		case 114: goto tr1125
		case 115: goto tr1126
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr417 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr417 }
		} else if data[p] >= 66 {
			goto tr417
		}
	} else {
		goto tr1116
	}
	goto st0
tr1941:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1748
tr2108:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1748
tr2277:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1748
tr2467:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1748
tr2607:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1748
tr1936:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1748
tr4052:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1748
st1748:
	p++
	if p == pe { goto _test_eof1748 }
	fallthrough
case 1748:
// line 39066 "zparse.go"
	switch data[p] {
		case 9: goto st565
		case 10: goto tr1941
		case 32: goto st565
		case 40: goto tr1942
		case 41: goto tr1943
		case 43: goto tr417
		case 47: goto tr417
		case 58: goto tr417
		case 59: goto tr1944
		case 61: goto tr417
		case 65: goto tr5421
		case 67: goto tr5422
		case 68: goto tr5423
		case 72: goto tr5424
		case 73: goto tr5425
		case 77: goto tr5426
		case 78: goto tr5427
		case 82: goto tr5428
		case 83: goto tr5429
		case 92: goto tr5419
		case 95: goto st2
		case 97: goto tr5421
		case 99: goto tr5422
		case 100: goto tr5423
		case 104: goto tr5424
		case 105: goto tr5425
		case 109: goto tr5426
		case 110: goto tr5427
		case 114: goto tr5428
		case 115: goto tr5429
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5419 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr5419 }
		} else if data[p] >= 66 {
			goto tr5419
		}
	} else {
		goto tr5420
	}
	goto st0
tr5419:
// line 89 "zparse.rl"
	{ mark = p }
	goto st566
st566:
	p++
	if p == pe { goto _test_eof566 }
	fallthrough
case 566:
// line 39120 "zparse.go"
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 92: goto st566
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
tr1953:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st567
tr1954:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st567
tr1952:
// line 101 "zparse.rl"
	{ lines++ }
	goto st567
tr1945:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st567
tr1946:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st567
tr1947:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st567
tr1948:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st567
tr2101:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st567
tr2102:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st567
tr2103:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st567
tr2104:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st567
tr3073:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st567
tr3074:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st567
tr3075:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st567
tr3076:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st567
st567:
	p++
	if p == pe { goto _test_eof567 }
	fallthrough
case 567:
// line 39266 "zparse.go"
	switch data[p] {
		case 9: goto st567
		case 10: goto tr1952
		case 32: goto st567
		case 40: goto tr1953
		case 41: goto tr1954
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st571
		case 61: goto tr429
		case 65: goto tr1957
		case 67: goto tr1958
		case 68: goto tr1959
		case 72: goto tr1960
		case 73: goto tr1961
		case 77: goto tr1962
		case 78: goto tr1963
		case 82: goto tr1964
		case 83: goto tr1965
		case 92: goto tr429
		case 97: goto tr1957
		case 99: goto tr1958
		case 100: goto tr1959
		case 104: goto tr1960
		case 105: goto tr1961
		case 109: goto tr1962
		case 110: goto tr1963
		case 114: goto tr1964
		case 115: goto tr1965
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 66 {
			goto tr429
		}
	} else {
		goto tr1955
	}
	goto st0
tr1955:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st568
st568:
	p++
	if p == pe { goto _test_eof568 }
	fallthrough
case 568:
// line 39320 "zparse.go"
	switch data[p] {
		case 9: goto tr1966
		case 10: goto tr1967
		case 32: goto tr1966
		case 40: goto tr1968
		case 41: goto tr1969
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr1971
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st568
	}
	goto st0
tr1974:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st569
tr1975:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st569
tr1973:
// line 101 "zparse.rl"
	{ lines++ }
	goto st569
tr1966:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st569
tr1967:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st569
tr1968:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st569
tr1969:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st569
st569:
	p++
	if p == pe { goto _test_eof569 }
	fallthrough
case 569:
// line 39392 "zparse.go"
	switch data[p] {
		case 9: goto st569
		case 10: goto tr1973
		case 32: goto st569
		case 40: goto tr1974
		case 41: goto tr1975
		case 59: goto st570
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr441 }
	goto st0
tr1971:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st570
st570:
	p++
	if p == pe { goto _test_eof570 }
	fallthrough
case 570:
// line 39432 "zparse.go"
	if data[p] == 10 { goto tr1973 }
	goto st570
tr1950:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st571
tr2106:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st571
tr3077:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st571
st571:
	p++
	if p == pe { goto _test_eof571 }
	fallthrough
case 571:
// line 39462 "zparse.go"
	if data[p] == 10 { goto tr1952 }
	goto st571
tr1957:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st572
st572:
	p++
	if p == pe { goto _test_eof572 }
	fallthrough
case 572:
// line 39476 "zparse.go"
	switch data[p] {
		case 9: goto tr1147
		case 10: goto tr1148
		case 32: goto tr1147
		case 40: goto tr1149
		case 41: goto tr1150
		case 43: goto st115
		case 59: goto tr1151
		case 61: goto st115
		case 65: goto st348
		case 78: goto st573
		case 92: goto st115
		case 97: goto st348
		case 110: goto st573
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st573:
	p++
	if p == pe { goto _test_eof573 }
	fallthrough
case 573:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 89: goto st574
		case 92: goto st115
		case 121: goto st574
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st574:
	p++
	if p == pe { goto _test_eof574 }
	fallthrough
case 574:
	switch data[p] {
		case 9: goto tr1979
		case 10: goto tr1980
		case 32: goto tr1979
		case 40: goto tr1981
		case 41: goto tr1982
		case 43: goto st115
		case 59: goto tr1983
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1986:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st575
tr1987:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st575
tr1985:
// line 101 "zparse.rl"
	{ lines++ }
	goto st575
tr1979:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st575
tr1980:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st575
tr1981:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st575
tr1982:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st575
st575:
	p++
	if p == pe { goto _test_eof575 }
	fallthrough
case 575:
// line 39597 "zparse.go"
	switch data[p] {
		case 9: goto st575
		case 10: goto tr1985
		case 32: goto st575
		case 40: goto tr1986
		case 41: goto tr1987
		case 59: goto st579
		case 65: goto tr105
		case 67: goto tr106
		case 68: goto tr40
		case 77: goto tr43
		case 78: goto tr107
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr105
		case 99: goto tr106
		case 100: goto tr40
		case 109: goto tr43
		case 110: goto tr107
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1988 }
	goto st0
tr1988:
// line 89 "zparse.rl"
	{ mark = p }
	goto st576
st576:
	p++
	if p == pe { goto _test_eof576 }
	fallthrough
case 576:
// line 39631 "zparse.go"
	switch data[p] {
		case 9: goto tr1990
		case 10: goto tr1991
		case 32: goto tr1990
		case 40: goto tr1992
		case 41: goto tr1993
		case 59: goto tr1995
	}
	if 48 <= data[p] && data[p] <= 57 { goto st576 }
	goto st0
tr1998:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st577
tr1999:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st577
tr1997:
// line 101 "zparse.rl"
	{ lines++ }
	goto st577
tr1990:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st577
tr1991:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st577
tr1992:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st577
tr1993:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st577
st577:
	p++
	if p == pe { goto _test_eof577 }
	fallthrough
case 577:
// line 39689 "zparse.go"
	switch data[p] {
		case 9: goto st577
		case 10: goto tr1997
		case 32: goto st577
		case 40: goto tr1998
		case 41: goto tr1999
		case 59: goto st578
		case 65: goto tr105
		case 67: goto tr106
		case 68: goto tr40
		case 77: goto tr43
		case 78: goto tr107
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr105
		case 99: goto tr106
		case 100: goto tr40
		case 109: goto tr43
		case 110: goto tr107
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr453 }
	goto st0
tr1995:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st578
st578:
	p++
	if p == pe { goto _test_eof578 }
	fallthrough
case 578:
// line 39725 "zparse.go"
	if data[p] == 10 { goto tr1997 }
	goto st578
tr1983:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st579
st579:
	p++
	if p == pe { goto _test_eof579 }
	fallthrough
case 579:
// line 39739 "zparse.go"
	if data[p] == 10 { goto tr1985 }
	goto st579
tr1958:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st580
st580:
	p++
	if p == pe { goto _test_eof580 }
	fallthrough
case 580:
// line 39753 "zparse.go"
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 72: goto st574
		case 78: goto st359
		case 83: goto st574
		case 92: goto st115
		case 104: goto st574
		case 110: goto st359
		case 115: goto st574
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1960:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st581
st581:
	p++
	if p == pe { goto _test_eof581 }
	fallthrough
case 581:
// line 39790 "zparse.go"
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 83: goto st574
		case 92: goto st115
		case 115: goto st574
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1961:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st582
st582:
	p++
	if p == pe { goto _test_eof582 }
	fallthrough
case 582:
// line 39823 "zparse.go"
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 78: goto st574
		case 92: goto st115
		case 110: goto st574
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1963:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st583
st583:
	p++
	if p == pe { goto _test_eof583 }
	fallthrough
case 583:
// line 39856 "zparse.go"
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 79: goto st584
		case 83: goto st428
		case 92: goto st115
		case 111: goto st584
		case 115: goto st428
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st584:
	p++
	if p == pe { goto _test_eof584 }
	fallthrough
case 584:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 78: goto st585
		case 92: goto st115
		case 110: goto st585
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st585:
	p++
	if p == pe { goto _test_eof585 }
	fallthrough
case 585:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 69: goto st574
		case 92: goto st115
		case 101: goto st574
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1965:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st586
tr1146:
// line 89 "zparse.rl"
	{ mark = p }
	goto st586
st586:
	p++
	if p == pe { goto _test_eof586 }
	fallthrough
case 586:
// line 39947 "zparse.go"
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 79: goto st587
		case 92: goto st115
		case 111: goto st587
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st587:
	p++
	if p == pe { goto _test_eof587 }
	fallthrough
case 587:
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 65: goto st588
		case 92: goto st115
		case 97: goto st588
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
st588:
	p++
	if p == pe { goto _test_eof588 }
	fallthrough
case 588:
	switch data[p] {
		case 9: goto tr2005
		case 10: goto tr2006
		case 32: goto tr2005
		case 40: goto tr2007
		case 41: goto tr2008
		case 43: goto st115
		case 59: goto tr2009
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr2012:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st589
tr2013:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st589
tr2011:
// line 101 "zparse.rl"
	{ lines++ }
	goto st589
tr2005:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st589
tr2006:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st589
tr2007:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st589
tr2008:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st589
st589:
	p++
	if p == pe { goto _test_eof589 }
	fallthrough
case 589:
// line 40102 "zparse.go"
	switch data[p] {
		case 9: goto st589
		case 10: goto tr2011
		case 32: goto st589
		case 40: goto tr2012
		case 41: goto tr2013
		case 43: goto tr417
		case 58: goto tr417
		case 59: goto st611
		case 61: goto tr417
		case 92: goto tr417
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr417 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr417 }
		} else if data[p] >= 65 {
			goto tr417
		}
	} else {
		goto tr2014
	}
	goto st0
tr2014:
// line 89 "zparse.rl"
	{ mark = p }
	goto st590
st590:
	p++
	if p == pe { goto _test_eof590 }
	fallthrough
case 590:
// line 40136 "zparse.go"
	switch data[p] {
		case 9: goto tr2016
		case 10: goto tr2017
		case 32: goto tr2016
		case 40: goto tr2018
		case 41: goto tr2019
		case 43: goto st113
		case 58: goto st113
		case 59: goto tr2021
		case 61: goto st113
		case 92: goto st113
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st113 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st113 }
		} else if data[p] >= 65 {
			goto st113
		}
	} else {
		goto st590
	}
	goto st0
tr2024:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st591
tr2025:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st591
tr2023:
// line 101 "zparse.rl"
	{ lines++ }
	goto st591
tr2016:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st591
tr2017:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st591
tr2018:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st591
tr2019:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st591
st591:
	p++
	if p == pe { goto _test_eof591 }
	fallthrough
case 591:
// line 40208 "zparse.go"
	switch data[p] {
		case 9: goto st591
		case 10: goto tr2023
		case 32: goto st591
		case 40: goto tr2024
		case 41: goto tr2025
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st610
		case 61: goto tr429
		case 92: goto tr429
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 65 {
			goto tr429
		}
	} else {
		goto tr2026
	}
	goto st0
tr2026:
// line 89 "zparse.rl"
	{ mark = p }
	goto st592
st592:
	p++
	if p == pe { goto _test_eof592 }
	fallthrough
case 592:
// line 40242 "zparse.go"
	switch data[p] {
		case 9: goto tr2028
		case 10: goto tr2029
		case 32: goto tr2028
		case 40: goto tr2030
		case 41: goto tr2031
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr2033
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st592
	}
	goto st0
tr2036:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st593
tr2037:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st593
tr2035:
// line 101 "zparse.rl"
	{ lines++ }
	goto st593
tr2028:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st593
tr2029:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st593
tr2030:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st593
tr2031:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st593
st593:
	p++
	if p == pe { goto _test_eof593 }
	fallthrough
case 593:
// line 40314 "zparse.go"
	switch data[p] {
		case 9: goto st593
		case 10: goto tr2035
		case 32: goto st593
		case 40: goto tr2036
		case 41: goto tr2037
		case 59: goto st609
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2038 }
	goto st0
tr2038:
// line 89 "zparse.rl"
	{ mark = p }
	goto st594
st594:
	p++
	if p == pe { goto _test_eof594 }
	fallthrough
case 594:
// line 40334 "zparse.go"
	switch data[p] {
		case 9: goto tr2040
		case 10: goto tr2041
		case 32: goto tr2040
		case 40: goto tr2042
		case 41: goto tr2043
		case 59: goto tr2045
	}
	if 48 <= data[p] && data[p] <= 57 { goto st594 }
	goto st0
tr2048:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st595
tr2049:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st595
tr2047:
// line 101 "zparse.rl"
	{ lines++ }
	goto st595
tr2040:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st595
tr2041:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st595
tr2042:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st595
tr2043:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st595
st595:
	p++
	if p == pe { goto _test_eof595 }
	fallthrough
case 595:
// line 40384 "zparse.go"
	switch data[p] {
		case 9: goto st595
		case 10: goto tr2047
		case 32: goto st595
		case 40: goto tr2048
		case 41: goto tr2049
		case 59: goto st608
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2050 }
	goto st0
tr2050:
// line 89 "zparse.rl"
	{ mark = p }
	goto st596
st596:
	p++
	if p == pe { goto _test_eof596 }
	fallthrough
case 596:
// line 40404 "zparse.go"
	switch data[p] {
		case 9: goto tr2052
		case 10: goto tr2053
		case 32: goto tr2052
		case 40: goto tr2054
		case 41: goto tr2055
		case 59: goto tr2057
	}
	if 48 <= data[p] && data[p] <= 57 { goto st596 }
	goto st0
tr2060:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st597
tr2061:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st597
tr2059:
// line 101 "zparse.rl"
	{ lines++ }
	goto st597
tr2052:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st597
tr2053:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st597
tr2054:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st597
tr2055:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st597
st597:
	p++
	if p == pe { goto _test_eof597 }
	fallthrough
case 597:
// line 40454 "zparse.go"
	switch data[p] {
		case 9: goto st597
		case 10: goto tr2059
		case 32: goto st597
		case 40: goto tr2060
		case 41: goto tr2061
		case 59: goto st607
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2062 }
	goto st0
tr2062:
// line 89 "zparse.rl"
	{ mark = p }
	goto st598
st598:
	p++
	if p == pe { goto _test_eof598 }
	fallthrough
case 598:
// line 40474 "zparse.go"
	switch data[p] {
		case 9: goto tr2064
		case 10: goto tr2065
		case 32: goto tr2064
		case 40: goto tr2066
		case 41: goto tr2067
		case 59: goto tr2069
	}
	if 48 <= data[p] && data[p] <= 57 { goto st598 }
	goto st0
tr2072:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st599
tr2073:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st599
tr2064:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st599
tr3244:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st599
tr3246:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st599
tr3247:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st599
tr3297:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st599
tr3299:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st599
tr3300:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st599
tr2066:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st599
tr2067:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st599
st599:
	p++
	if p == pe { goto _test_eof599 }
	fallthrough
case 599:
// line 40666 "zparse.go"
	switch data[p] {
		case 9: goto st599
		case 10: goto tr2071
		case 32: goto st599
		case 40: goto tr2072
		case 41: goto tr2073
		case 59: goto tr2074
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr477 }
	goto st0
tr2071:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1749
tr2100:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1749
tr3245:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1749
tr3298:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1749
tr2065:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1749
st1749:
	p++
	if p == pe { goto _test_eof1749 }
	fallthrough
case 1749:
// line 40750 "zparse.go"
	switch data[p] {
		case 9: goto st600
		case 10: goto tr2076
		case 32: goto st600
		case 40: goto tr2077
		case 41: goto tr2078
		case 59: goto tr2079
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5430
	}
	goto st0
tr2077:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st600
tr2078:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st600
st600:
	p++
	if p == pe { goto _test_eof600 }
	fallthrough
case 600:
// line 40786 "zparse.go"
	switch data[p] {
		case 9: goto st600
		case 10: goto tr2076
		case 32: goto st600
		case 40: goto tr2077
		case 41: goto tr2078
		case 59: goto tr2079
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1467 }
	goto st0
tr2076:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1750
tr2092:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1750
st1750:
	p++
	if p == pe { goto _test_eof1750 }
	fallthrough
case 1750:
// line 40830 "zparse.go"
	switch data[p] {
		case 9: goto st600
		case 10: goto tr2076
		case 32: goto st600
		case 40: goto tr2077
		case 41: goto tr2078
		case 59: goto tr2079
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5431
	}
	goto st0
tr5431:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st601
st601:
	p++
	if p == pe { goto _test_eof601 }
	fallthrough
case 601:
// line 40882 "zparse.go"
	switch data[p] {
		case 9: goto tr2080
		case 10: goto tr2081
		case 32: goto tr2080
		case 40: goto tr2082
		case 41: goto tr2083
		case 59: goto tr2085
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st601
	}
	goto st0
tr2088:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st602
tr2089:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st602
tr2087:
// line 101 "zparse.rl"
	{ lines++ }
	goto st602
tr2080:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st602
tr2081:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st602
tr2082:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st602
tr2083:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st602
tr2093:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st602
tr2094:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st602
tr2095:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st602
tr2096:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st602
st602:
	p++
	if p == pe { goto _test_eof602 }
	fallthrough
case 602:
// line 40990 "zparse.go"
	switch data[p] {
		case 9: goto st602
		case 10: goto tr2087
		case 32: goto st602
		case 40: goto tr2088
		case 41: goto tr2089
		case 59: goto st603
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1340 }
	goto st0
tr2085:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st603
tr2098:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st603
st603:
	p++
	if p == pe { goto _test_eof603 }
	fallthrough
case 603:
// line 41038 "zparse.go"
	if data[p] == 10 { goto tr2087 }
	goto st603
tr2079:
// line 89 "zparse.rl"
	{ mark = p }
	goto st604
st604:
	p++
	if p == pe { goto _test_eof604 }
	fallthrough
case 604:
// line 41050 "zparse.go"
	if data[p] == 10 { goto tr2092 }
	goto st604
tr5430:
// line 89 "zparse.rl"
	{ mark = p }
	goto st605
st605:
	p++
	if p == pe { goto _test_eof605 }
	fallthrough
case 605:
// line 41062 "zparse.go"
	switch data[p] {
		case 9: goto tr2093
		case 10: goto tr2094
		case 32: goto tr2093
		case 40: goto tr2095
		case 41: goto tr2096
		case 59: goto tr2098
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st605
	}
	goto st0
tr2074:
// line 89 "zparse.rl"
	{ mark = p }
	goto st606
tr2069:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st606
tr3249:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st606
tr3302:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st606
st606:
	p++
	if p == pe { goto _test_eof606 }
	fallthrough
case 606:
// line 41146 "zparse.go"
	if data[p] == 10 { goto tr2100 }
	goto st606
tr2057:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st607
st607:
	p++
	if p == pe { goto _test_eof607 }
	fallthrough
case 607:
// line 41158 "zparse.go"
	if data[p] == 10 { goto tr2059 }
	goto st607
tr2045:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st608
st608:
	p++
	if p == pe { goto _test_eof608 }
	fallthrough
case 608:
// line 41170 "zparse.go"
	if data[p] == 10 { goto tr2047 }
	goto st608
tr2033:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st609
st609:
	p++
	if p == pe { goto _test_eof609 }
	fallthrough
case 609:
// line 41184 "zparse.go"
	if data[p] == 10 { goto tr2035 }
	goto st609
tr2021:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st610
st610:
	p++
	if p == pe { goto _test_eof610 }
	fallthrough
case 610:
// line 41198 "zparse.go"
	if data[p] == 10 { goto tr2023 }
	goto st610
tr2009:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st611
st611:
	p++
	if p == pe { goto _test_eof611 }
	fallthrough
case 611:
// line 41221 "zparse.go"
	if data[p] == 10 { goto tr2011 }
	goto st611
tr5420:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st612
st612:
	p++
	if p == pe { goto _test_eof612 }
	fallthrough
case 612:
// line 41235 "zparse.go"
	switch data[p] {
		case 9: goto tr2101
		case 10: goto tr2102
		case 32: goto tr2101
		case 40: goto tr2103
		case 41: goto tr2104
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr2106
		case 61: goto st113
		case 92: goto st566
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st566 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st566 }
		} else if data[p] >= 65 {
			goto st566
		}
	} else {
		goto st612
	}
	goto st0
tr1944:
// line 89 "zparse.rl"
	{ mark = p }
	goto st613
tr2280:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st613
tr2470:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st613
tr2610:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st613
tr1939:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st613
tr4055:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st613
st613:
	p++
	if p == pe { goto _test_eof613 }
	fallthrough
case 613:
// line 41397 "zparse.go"
	if data[p] == 10 { goto tr2108 }
	goto st613
tr5421:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st614
st614:
	p++
	if p == pe { goto _test_eof614 }
	fallthrough
case 614:
// line 41411 "zparse.go"
	switch data[p] {
		case 9: goto tr2109
		case 10: goto tr2110
		case 32: goto tr2109
		case 40: goto tr2111
		case 41: goto tr2112
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr2113
		case 61: goto st113
		case 65: goto st1649
		case 78: goto st1689
		case 92: goto st566
		case 95: goto st2
		case 97: goto st1649
		case 110: goto st1689
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
tr2118:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st615
tr2119:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st615
tr2117:
// line 101 "zparse.rl"
	{ lines++ }
	goto st615
tr2109:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st615
tr2110:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st615
tr2111:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st615
tr2112:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st615
st615:
	p++
	if p == pe { goto _test_eof615 }
	fallthrough
case 615:
// line 41529 "zparse.go"
	switch data[p] {
		case 9: goto st615
		case 10: goto tr2117
		case 32: goto st615
		case 40: goto tr2118
		case 41: goto tr2119
		case 43: goto tr2120
		case 58: goto tr2120
		case 59: goto st631
		case 61: goto tr2120
		case 65: goto tr2123
		case 67: goto tr2124
		case 68: goto tr2125
		case 72: goto tr2126
		case 73: goto tr2127
		case 77: goto tr2128
		case 78: goto tr2129
		case 82: goto tr2130
		case 83: goto tr2131
		case 92: goto tr2120
		case 97: goto tr2123
		case 99: goto tr2124
		case 100: goto tr2125
		case 104: goto tr2126
		case 105: goto tr2127
		case 109: goto tr2128
		case 110: goto tr2129
		case 114: goto tr2130
		case 115: goto tr2131
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr2120 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr2120 }
		} else if data[p] >= 66 {
			goto tr2120
		}
	} else {
		goto tr2121
	}
	goto st0
tr2120:
// line 89 "zparse.rl"
	{ mark = p }
	goto st616
st616:
	p++
	if p == pe { goto _test_eof616 }
	fallthrough
case 616:
// line 41581 "zparse.go"
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 92: goto st616
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
tr2140:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st617
tr2141:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st617
tr2132:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st617
tr4346:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st617
tr3102:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st617
tr3357:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st617
tr2134:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st617
tr2135:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st617
tr3104:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st617
tr3105:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st617
tr3359:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st617
tr3360:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st617
tr4348:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st617
tr4349:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st617
st617:
	p++
	if p == pe { goto _test_eof617 }
	fallthrough
case 617:
// line 41774 "zparse.go"
	switch data[p] {
		case 9: goto st617
		case 10: goto tr2139
		case 32: goto st617
		case 40: goto tr2140
		case 41: goto tr2141
		case 59: goto tr2142
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr441 }
	goto st0
tr2139:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1751
tr2180:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1751
tr2133:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1751
tr3103:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1751
tr3358:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1751
tr4347:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1751
st1751:
	p++
	if p == pe { goto _test_eof1751 }
	fallthrough
case 1751:
// line 41856 "zparse.go"
	switch data[p] {
		case 9: goto st618
		case 10: goto tr2144
		case 32: goto st618
		case 40: goto tr2145
		case 41: goto tr2146
		case 59: goto tr2148
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5432
	}
	goto st0
tr2145:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st618
tr2146:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st618
st618:
	p++
	if p == pe { goto _test_eof618 }
	fallthrough
case 618:
// line 41892 "zparse.go"
	switch data[p] {
		case 9: goto st618
		case 10: goto tr2144
		case 32: goto st618
		case 40: goto tr2145
		case 41: goto tr2146
		case 59: goto tr2148
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2147 }
	goto st0
tr2144:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1752
tr2161:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1752
st1752:
	p++
	if p == pe { goto _test_eof1752 }
	fallthrough
case 1752:
// line 41936 "zparse.go"
	switch data[p] {
		case 9: goto st618
		case 10: goto tr2144
		case 32: goto st618
		case 40: goto tr2145
		case 41: goto tr2146
		case 59: goto tr2148
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5433
	}
	goto st0
tr5433:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st619
tr5439:
// line 89 "zparse.rl"
	{ mark = p }
	goto st619
st619:
	p++
	if p == pe { goto _test_eof619 }
	fallthrough
case 619:
// line 41992 "zparse.go"
	switch data[p] {
		case 9: goto tr2149
		case 10: goto tr2150
		case 32: goto tr2149
		case 40: goto tr2151
		case 41: goto tr2152
		case 59: goto tr2154
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st619
	}
	goto st0
tr2157:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st620
tr2158:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st620
tr2156:
// line 101 "zparse.rl"
	{ lines++ }
	goto st620
tr2149:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st620
tr2150:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st620
tr2151:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st620
tr2152:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st620
tr2173:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st620
tr2174:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st620
tr2175:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st620
tr2176:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st620
st620:
	p++
	if p == pe { goto _test_eof620 }
	fallthrough
case 620:
// line 42100 "zparse.go"
	switch data[p] {
		case 9: goto st620
		case 10: goto tr2156
		case 32: goto st620
		case 40: goto tr2157
		case 41: goto tr2158
		case 59: goto st621
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1175 }
	goto st0
tr2154:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st621
tr2178:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st621
st621:
	p++
	if p == pe { goto _test_eof621 }
	fallthrough
case 621:
// line 42148 "zparse.go"
	if data[p] == 10 { goto tr2156 }
	goto st621
tr2148:
// line 89 "zparse.rl"
	{ mark = p }
	goto st622
st622:
	p++
	if p == pe { goto _test_eof622 }
	fallthrough
case 622:
// line 42160 "zparse.go"
	if data[p] == 10 { goto tr2161 }
	goto st622
tr2147:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st623
st623:
	p++
	if p == pe { goto _test_eof623 }
	fallthrough
case 623:
// line 42174 "zparse.go"
	switch data[p] {
		case 9: goto tr2162
		case 10: goto tr2163
		case 32: goto tr2162
		case 40: goto tr2164
		case 41: goto tr2165
		case 59: goto tr2167
	}
	if 48 <= data[p] && data[p] <= 57 { goto st623 }
	goto st0
tr2170:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st624
tr2171:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st624
tr2169:
// line 101 "zparse.rl"
	{ lines++ }
	goto st624
tr2162:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st624
tr2163:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st624
tr2164:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st624
tr2165:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st624
st624:
	p++
	if p == pe { goto _test_eof624 }
	fallthrough
case 624:
// line 42232 "zparse.go"
	switch data[p] {
		case 9: goto st624
		case 10: goto tr2169
		case 32: goto st624
		case 40: goto tr2170
		case 41: goto tr2171
		case 59: goto st625
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr453 }
	goto st0
tr2167:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st625
st625:
	p++
	if p == pe { goto _test_eof625 }
	fallthrough
case 625:
// line 42272 "zparse.go"
	if data[p] == 10 { goto tr2169 }
	goto st625
tr5432:
// line 89 "zparse.rl"
	{ mark = p }
	goto st626
st626:
	p++
	if p == pe { goto _test_eof626 }
	fallthrough
case 626:
// line 42284 "zparse.go"
	switch data[p] {
		case 9: goto tr2173
		case 10: goto tr2174
		case 32: goto tr2173
		case 40: goto tr2175
		case 41: goto tr2176
		case 59: goto tr2178
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st626
	}
	goto st0
tr2142:
// line 89 "zparse.rl"
	{ mark = p }
	goto st627
tr2137:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st627
tr4351:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st627
tr3107:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st627
tr3362:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st627
st627:
	p++
	if p == pe { goto _test_eof627 }
	fallthrough
case 627:
// line 42364 "zparse.go"
	if data[p] == 10 { goto tr2180 }
	goto st627
tr2121:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st628
st628:
	p++
	if p == pe { goto _test_eof628 }
	fallthrough
case 628:
// line 42378 "zparse.go"
	switch data[p] {
		case 9: goto tr2181
		case 10: goto tr2182
		case 32: goto tr2181
		case 40: goto tr2183
		case 41: goto tr2184
		case 43: goto st616
		case 58: goto st616
		case 59: goto tr2186
		case 61: goto st616
		case 92: goto st616
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st616 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st616 }
		} else if data[p] >= 65 {
			goto st616
		}
	} else {
		goto st628
	}
	goto st0
tr2189:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st629
tr2190:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st629
tr2181:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st629
tr2183:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st629
tr2184:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st629
tr3108:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st629
tr3110:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st629
tr3111:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st629
tr5209:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st629
tr5211:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st629
tr5212:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st629
tr3363:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st629
tr3365:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st629
tr3366:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st629
st629:
	p++
	if p == pe { goto _test_eof629 }
	fallthrough
case 629:
// line 42600 "zparse.go"
	switch data[p] {
		case 9: goto st629
		case 10: goto tr2188
		case 32: goto st629
		case 40: goto tr2189
		case 41: goto tr2190
		case 59: goto tr2191
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr441 }
	goto st0
tr2188:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1753
tr2193:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1753
tr2182:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1753
tr3109:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1753
tr5210:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1753
tr3364:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1753
st1753:
	p++
	if p == pe { goto _test_eof1753 }
	fallthrough
case 1753:
// line 42708 "zparse.go"
	switch data[p] {
		case 9: goto st618
		case 10: goto tr2144
		case 32: goto st618
		case 40: goto tr2145
		case 41: goto tr2146
		case 59: goto tr2148
		case 65: goto tr5347
		case 67: goto tr5348
		case 68: goto tr5349
		case 72: goto tr5350
		case 73: goto tr5351
		case 77: goto tr5352
		case 78: goto tr5353
		case 82: goto tr5354
		case 83: goto tr5355
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5347
		case 99: goto tr5348
		case 100: goto tr5349
		case 104: goto tr5350
		case 105: goto tr5351
		case 109: goto tr5352
		case 110: goto tr5353
		case 114: goto tr5354
		case 115: goto tr5355
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5432
	}
	goto st0
tr2191:
// line 89 "zparse.rl"
	{ mark = p }
	goto st630
tr2186:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st630
tr3113:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st630
tr5214:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st630
tr3368:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st630
st630:
	p++
	if p == pe { goto _test_eof630 }
	fallthrough
case 630:
// line 42814 "zparse.go"
	if data[p] == 10 { goto tr2193 }
	goto st630
tr2113:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st631
st631:
	p++
	if p == pe { goto _test_eof631 }
	fallthrough
case 631:
// line 42839 "zparse.go"
	if data[p] == 10 { goto tr2117 }
	goto st631
tr2123:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st632
st632:
	p++
	if p == pe { goto _test_eof632 }
	fallthrough
case 632:
// line 42853 "zparse.go"
	switch data[p] {
		case 9: goto tr2194
		case 10: goto tr2195
		case 32: goto tr2194
		case 40: goto tr2196
		case 41: goto tr2197
		case 43: goto st616
		case 59: goto tr2198
		case 61: goto st616
		case 65: goto st711
		case 78: goto st772
		case 92: goto st616
		case 97: goto st711
		case 110: goto st772
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
tr2203:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st633
tr2204:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st633
tr3114:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st633
tr3116:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st633
tr3117:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st633
tr5215:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st633
tr5217:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st633
tr5218:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st633
tr3369:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st633
tr3371:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st633
tr3372:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st633
tr2194:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st633
tr2196:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st633
tr2197:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st633
st633:
	p++
	if p == pe { goto _test_eof633 }
	fallthrough
case 633:
// line 43182 "zparse.go"
	switch data[p] {
		case 9: goto st633
		case 10: goto tr2202
		case 32: goto st633
		case 40: goto tr2203
		case 41: goto tr2204
		case 43: goto tr58
		case 58: goto tr58
		case 59: goto tr2205
		case 61: goto tr58
		case 92: goto tr58
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr58 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr58 }
		} else if data[p] >= 65 {
			goto tr58
		}
	} else {
		goto tr1158
	}
	goto st0
tr2202:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1754
tr2398:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1754
tr3115:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1754
tr5216:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1754
tr3370:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1754
tr2195:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1754
st1754:
	p++
	if p == pe { goto _test_eof1754 }
	fallthrough
case 1754:
// line 43322 "zparse.go"
	switch data[p] {
		case 9: goto st634
		case 10: goto tr2207
		case 32: goto st634
		case 40: goto tr2208
		case 41: goto tr2209
		case 43: goto tr58
		case 47: goto tr58
		case 58: goto tr58
		case 59: goto tr2211
		case 61: goto tr58
		case 92: goto tr5356
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5356 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr5356 }
		} else if data[p] >= 65 {
			goto tr5356
		}
	} else {
		goto tr5434
	}
	goto st0
tr2208:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st634
tr2209:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st634
st634:
	p++
	if p == pe { goto _test_eof634 }
	fallthrough
case 634:
// line 43362 "zparse.go"
	switch data[p] {
		case 9: goto st634
		case 10: goto tr2207
		case 32: goto st634
		case 40: goto tr2208
		case 41: goto tr2209
		case 43: goto tr58
		case 58: goto tr58
		case 59: goto tr2211
		case 61: goto tr58
		case 65: goto tr539
		case 67: goto tr540
		case 68: goto tr541
		case 72: goto tr542
		case 73: goto tr543
		case 77: goto tr544
		case 78: goto tr545
		case 82: goto tr546
		case 83: goto tr547
		case 92: goto tr58
		case 97: goto tr539
		case 99: goto tr540
		case 100: goto tr541
		case 104: goto tr542
		case 105: goto tr543
		case 109: goto tr544
		case 110: goto tr545
		case 114: goto tr546
		case 115: goto tr547
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr58 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr58 }
		} else if data[p] >= 66 {
			goto tr58
		}
	} else {
		goto tr2210
	}
	goto st0
tr2207:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1755
tr2219:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1755
st1755:
	p++
	if p == pe { goto _test_eof1755 }
	fallthrough
case 1755:
// line 43420 "zparse.go"
	switch data[p] {
		case 9: goto st634
		case 10: goto tr2207
		case 32: goto st634
		case 40: goto tr2208
		case 41: goto tr2209
		case 43: goto tr58
		case 47: goto tr58
		case 58: goto tr58
		case 59: goto tr2211
		case 61: goto tr58
		case 65: goto tr5358
		case 67: goto tr5359
		case 68: goto tr5360
		case 72: goto tr5361
		case 73: goto tr5362
		case 77: goto tr5363
		case 78: goto tr5364
		case 82: goto tr5365
		case 83: goto tr5366
		case 92: goto tr5356
		case 95: goto st2
		case 97: goto tr5358
		case 99: goto tr5359
		case 100: goto tr5360
		case 104: goto tr5361
		case 105: goto tr5362
		case 109: goto tr5363
		case 110: goto tr5364
		case 114: goto tr5365
		case 115: goto tr5366
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5356 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr5356 }
		} else if data[p] >= 66 {
			goto tr5356
		}
	} else {
		goto tr5435
	}
	goto st0
tr5435:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st635
st635:
	p++
	if p == pe { goto _test_eof635 }
	fallthrough
case 635:
// line 43476 "zparse.go"
	switch data[p] {
		case 9: goto tr2212
		case 10: goto tr2213
		case 32: goto tr2212
		case 40: goto tr2214
		case 41: goto tr2215
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr2217
		case 61: goto st9
		case 92: goto st170
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st170 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st170 }
		} else if data[p] >= 65 {
			goto st170
		}
	} else {
		goto st635
	}
	goto st0
tr2211:
// line 89 "zparse.rl"
	{ mark = p }
	goto st636
st636:
	p++
	if p == pe { goto _test_eof636 }
	fallthrough
case 636:
// line 43512 "zparse.go"
	if data[p] == 10 { goto tr2219 }
	goto st636
tr5359:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st637
st637:
	p++
	if p == pe { goto _test_eof637 }
	fallthrough
case 637:
// line 43526 "zparse.go"
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 72: goto st638
		case 78: goto st639
		case 83: goto st638
		case 92: goto st170
		case 95: goto st2
		case 104: goto st638
		case 110: goto st639
		case 115: goto st638
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st638:
	p++
	if p == pe { goto _test_eof638 }
	fallthrough
case 638:
	switch data[p] {
		case 9: goto tr2222
		case 10: goto tr2223
		case 32: goto tr2222
		case 40: goto tr2224
		case 41: goto tr2225
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr2226
		case 61: goto st9
		case 92: goto st170
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st639:
	p++
	if p == pe { goto _test_eof639 }
	fallthrough
case 639:
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 65: goto st640
		case 92: goto st170
		case 95: goto st2
		case 97: goto st640
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st640:
	p++
	if p == pe { goto _test_eof640 }
	fallthrough
case 640:
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 77: goto st641
		case 92: goto st170
		case 95: goto st2
		case 109: goto st641
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st641:
	p++
	if p == pe { goto _test_eof641 }
	fallthrough
case 641:
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 69: goto st642
		case 92: goto st170
		case 95: goto st2
		case 101: goto st642
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st642:
	p++
	if p == pe { goto _test_eof642 }
	fallthrough
case 642:
	switch data[p] {
		case 9: goto tr2230
		case 10: goto tr2231
		case 32: goto tr2230
		case 40: goto tr2232
		case 41: goto tr2233
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr2234
		case 61: goto st9
		case 92: goto st170
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
tr5360:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st643
st643:
	p++
	if p == pe { goto _test_eof643 }
	fallthrough
case 643:
// line 43707 "zparse.go"
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 78: goto st644
		case 83: goto st649
		case 92: goto st170
		case 95: goto st2
		case 110: goto st644
		case 115: goto st649
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st644:
	p++
	if p == pe { goto _test_eof644 }
	fallthrough
case 644:
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 83: goto st645
		case 92: goto st170
		case 95: goto st2
		case 115: goto st645
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st645:
	p++
	if p == pe { goto _test_eof645 }
	fallthrough
case 645:
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 75: goto st646
		case 92: goto st170
		case 95: goto st2
		case 107: goto st646
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st646:
	p++
	if p == pe { goto _test_eof646 }
	fallthrough
case 646:
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 69: goto st647
		case 92: goto st170
		case 95: goto st2
		case 101: goto st647
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st647:
	p++
	if p == pe { goto _test_eof647 }
	fallthrough
case 647:
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 89: goto st648
		case 92: goto st170
		case 95: goto st2
		case 121: goto st648
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st648:
	p++
	if p == pe { goto _test_eof648 }
	fallthrough
case 648:
	switch data[p] {
		case 9: goto tr2241
		case 10: goto tr2242
		case 32: goto tr2241
		case 40: goto tr2243
		case 41: goto tr2244
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr2245
		case 61: goto st9
		case 92: goto st170
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st649:
	p++
	if p == pe { goto _test_eof649 }
	fallthrough
case 649:
	switch data[p] {
		case 9: goto tr2246
		case 10: goto tr2247
		case 32: goto tr2246
		case 40: goto tr2248
		case 41: goto tr2249
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr2250
		case 61: goto st9
		case 92: goto st170
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
tr5361:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st650
st650:
	p++
	if p == pe { goto _test_eof650 }
	fallthrough
case 650:
// line 43915 "zparse.go"
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 83: goto st638
		case 92: goto st170
		case 95: goto st2
		case 115: goto st638
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
tr5362:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st651
st651:
	p++
	if p == pe { goto _test_eof651 }
	fallthrough
case 651:
// line 43951 "zparse.go"
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 78: goto st638
		case 92: goto st170
		case 95: goto st2
		case 110: goto st638
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
tr5363:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st652
st652:
	p++
	if p == pe { goto _test_eof652 }
	fallthrough
case 652:
// line 43987 "zparse.go"
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 88: goto st653
		case 92: goto st170
		case 95: goto st2
		case 120: goto st653
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st653:
	p++
	if p == pe { goto _test_eof653 }
	fallthrough
case 653:
	switch data[p] {
		case 9: goto tr2252
		case 10: goto tr2253
		case 32: goto tr2252
		case 40: goto tr2254
		case 41: goto tr2255
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr2256
		case 61: goto st9
		case 92: goto st170
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
tr5364:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st654
st654:
	p++
	if p == pe { goto _test_eof654 }
	fallthrough
case 654:
// line 44050 "zparse.go"
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 79: goto st655
		case 83: goto st657
		case 92: goto st170
		case 95: goto st2
		case 111: goto st655
		case 115: goto st657
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st655:
	p++
	if p == pe { goto _test_eof655 }
	fallthrough
case 655:
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 78: goto st656
		case 92: goto st170
		case 95: goto st2
		case 110: goto st656
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st656:
	p++
	if p == pe { goto _test_eof656 }
	fallthrough
case 656:
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 69: goto st638
		case 92: goto st170
		case 95: goto st2
		case 101: goto st638
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st657:
	p++
	if p == pe { goto _test_eof657 }
	fallthrough
case 657:
	switch data[p] {
		case 9: goto tr2260
		case 10: goto tr2261
		case 32: goto tr2260
		case 40: goto tr2262
		case 41: goto tr2263
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr2264
		case 61: goto st9
		case 92: goto st170
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
tr5365:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st658
st658:
	p++
	if p == pe { goto _test_eof658 }
	fallthrough
case 658:
// line 44173 "zparse.go"
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 82: goto st659
		case 92: goto st170
		case 95: goto st2
		case 114: goto st659
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st659:
	p++
	if p == pe { goto _test_eof659 }
	fallthrough
case 659:
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 83: goto st660
		case 92: goto st170
		case 95: goto st2
		case 115: goto st660
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st660:
	p++
	if p == pe { goto _test_eof660 }
	fallthrough
case 660:
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 73: goto st661
		case 92: goto st170
		case 95: goto st2
		case 105: goto st661
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st661:
	p++
	if p == pe { goto _test_eof661 }
	fallthrough
case 661:
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 71: goto st662
		case 92: goto st170
		case 95: goto st2
		case 103: goto st662
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st662:
	p++
	if p == pe { goto _test_eof662 }
	fallthrough
case 662:
	switch data[p] {
		case 9: goto tr2269
		case 10: goto tr2270
		case 32: goto tr2269
		case 40: goto tr2271
		case 41: goto tr2272
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr2273
		case 61: goto st9
		case 92: goto st170
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
tr5366:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st663
st663:
	p++
	if p == pe { goto _test_eof663 }
	fallthrough
case 663:
// line 44323 "zparse.go"
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 79: goto st664
		case 92: goto st170
		case 95: goto st2
		case 111: goto st664
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st664:
	p++
	if p == pe { goto _test_eof664 }
	fallthrough
case 664:
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 65: goto st665
		case 92: goto st170
		case 95: goto st2
		case 97: goto st665
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st665:
	p++
	if p == pe { goto _test_eof665 }
	fallthrough
case 665:
	switch data[p] {
		case 9: goto tr2276
		case 10: goto tr2277
		case 32: goto tr2276
		case 40: goto tr2278
		case 41: goto tr2279
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr2280
		case 61: goto st9
		case 92: goto st170
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
tr2210:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st666
st666:
	p++
	if p == pe { goto _test_eof666 }
	fallthrough
case 666:
// line 44415 "zparse.go"
	switch data[p] {
		case 9: goto tr2281
		case 10: goto tr2282
		case 32: goto tr2281
		case 40: goto tr2283
		case 41: goto tr2284
		case 43: goto st9
		case 58: goto st9
		case 59: goto tr2286
		case 61: goto st9
		case 92: goto st9
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st9 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st9 }
		} else if data[p] >= 65 {
			goto st9
		}
	} else {
		goto st666
	}
	goto st0
tr2289:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st667
tr2290:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st667
tr2281:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st667
tr2283:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st667
tr2284:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st667
tr2471:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st667
tr2473:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st667
tr2474:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st667
tr2611:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st667
tr2613:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st667
tr2614:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st667
tr2920:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st667
tr2922:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st667
tr2923:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st667
st667:
	p++
	if p == pe { goto _test_eof667 }
	fallthrough
case 667:
// line 44661 "zparse.go"
	switch data[p] {
		case 9: goto st667
		case 10: goto tr2288
		case 32: goto st667
		case 40: goto tr2289
		case 41: goto tr2290
		case 59: goto tr2291
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr453 }
	goto st0
tr2288:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1756
tr2293:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1756
tr2282:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1756
tr2472:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1756
tr2612:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1756
tr2921:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1756
st1756:
	p++
	if p == pe { goto _test_eof1756 }
	fallthrough
case 1756:
// line 44777 "zparse.go"
	switch data[p] {
		case 9: goto st334
		case 10: goto tr1172
		case 32: goto st334
		case 40: goto tr1173
		case 41: goto tr1174
		case 59: goto tr1176
		case 65: goto tr5347
		case 67: goto tr5348
		case 68: goto tr5349
		case 72: goto tr5350
		case 73: goto tr5351
		case 77: goto tr5352
		case 78: goto tr5353
		case 82: goto tr5354
		case 83: goto tr5355
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5347
		case 99: goto tr5348
		case 100: goto tr5349
		case 104: goto tr5350
		case 105: goto tr5351
		case 109: goto tr5352
		case 110: goto tr5353
		case 114: goto tr5354
		case 115: goto tr5355
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5397
	}
	goto st0
tr2291:
// line 89 "zparse.rl"
	{ mark = p }
	goto st668
tr2286:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st668
tr2476:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st668
tr2616:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st668
tr2925:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st668
st668:
	p++
	if p == pe { goto _test_eof668 }
	fallthrough
case 668:
// line 44891 "zparse.go"
	if data[p] == 10 { goto tr2293 }
	goto st668
tr539:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st669
st669:
	p++
	if p == pe { goto _test_eof669 }
	fallthrough
case 669:
// line 44905 "zparse.go"
	switch data[p] {
		case 9: goto tr2294
		case 10: goto tr2295
		case 32: goto tr2294
		case 40: goto tr2296
		case 41: goto tr2297
		case 43: goto st9
		case 59: goto tr2298
		case 61: goto st9
		case 65: goto st670
		case 78: goto st673
		case 92: goto st9
		case 97: goto st670
		case 110: goto st673
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st670:
	p++
	if p == pe { goto _test_eof670 }
	fallthrough
case 670:
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 65: goto st671
		case 92: goto st9
		case 97: goto st671
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st671:
	p++
	if p == pe { goto _test_eof671 }
	fallthrough
case 671:
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 65: goto st672
		case 92: goto st9
		case 97: goto st672
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st672:
	p++
	if p == pe { goto _test_eof672 }
	fallthrough
case 672:
	switch data[p] {
		case 9: goto tr2303
		case 10: goto tr2304
		case 32: goto tr2303
		case 40: goto tr2305
		case 41: goto tr2306
		case 43: goto st9
		case 59: goto tr2307
		case 61: goto st9
		case 92: goto st9
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st673:
	p++
	if p == pe { goto _test_eof673 }
	fallthrough
case 673:
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 89: goto st674
		case 92: goto st9
		case 121: goto st674
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st674:
	p++
	if p == pe { goto _test_eof674 }
	fallthrough
case 674:
	switch data[p] {
		case 9: goto tr2309
		case 10: goto tr2310
		case 32: goto tr2309
		case 40: goto tr2311
		case 41: goto tr2312
		case 43: goto st9
		case 59: goto tr2313
		case 61: goto st9
		case 92: goto st9
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
tr540:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st675
st675:
	p++
	if p == pe { goto _test_eof675 }
	fallthrough
case 675:
// line 45066 "zparse.go"
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 72: goto st674
		case 78: goto st676
		case 83: goto st674
		case 92: goto st9
		case 104: goto st674
		case 110: goto st676
		case 115: goto st674
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st676:
	p++
	if p == pe { goto _test_eof676 }
	fallthrough
case 676:
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 65: goto st677
		case 92: goto st9
		case 97: goto st677
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st677:
	p++
	if p == pe { goto _test_eof677 }
	fallthrough
case 677:
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 77: goto st678
		case 92: goto st9
		case 109: goto st678
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st678:
	p++
	if p == pe { goto _test_eof678 }
	fallthrough
case 678:
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 69: goto st679
		case 92: goto st9
		case 101: goto st679
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st679:
	p++
	if p == pe { goto _test_eof679 }
	fallthrough
case 679:
	switch data[p] {
		case 9: goto tr2318
		case 10: goto tr2319
		case 32: goto tr2318
		case 40: goto tr2320
		case 41: goto tr2321
		case 43: goto st9
		case 59: goto tr2322
		case 61: goto st9
		case 92: goto st9
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
tr541:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st680
st680:
	p++
	if p == pe { goto _test_eof680 }
	fallthrough
case 680:
// line 45205 "zparse.go"
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 78: goto st681
		case 83: goto st686
		case 92: goto st9
		case 110: goto st681
		case 115: goto st686
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st681:
	p++
	if p == pe { goto _test_eof681 }
	fallthrough
case 681:
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 83: goto st682
		case 92: goto st9
		case 115: goto st682
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st682:
	p++
	if p == pe { goto _test_eof682 }
	fallthrough
case 682:
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 75: goto st683
		case 92: goto st9
		case 107: goto st683
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st683:
	p++
	if p == pe { goto _test_eof683 }
	fallthrough
case 683:
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 69: goto st684
		case 92: goto st9
		case 101: goto st684
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st684:
	p++
	if p == pe { goto _test_eof684 }
	fallthrough
case 684:
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 89: goto st685
		case 92: goto st9
		case 121: goto st685
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st685:
	p++
	if p == pe { goto _test_eof685 }
	fallthrough
case 685:
	switch data[p] {
		case 9: goto tr2329
		case 10: goto tr2330
		case 32: goto tr2329
		case 40: goto tr2331
		case 41: goto tr2332
		case 43: goto st9
		case 59: goto tr2333
		case 61: goto st9
		case 92: goto st9
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st686:
	p++
	if p == pe { goto _test_eof686 }
	fallthrough
case 686:
	switch data[p] {
		case 9: goto tr2334
		case 10: goto tr2335
		case 32: goto tr2334
		case 40: goto tr2336
		case 41: goto tr2337
		case 43: goto st9
		case 59: goto tr2338
		case 61: goto st9
		case 92: goto st9
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
tr542:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st687
st687:
	p++
	if p == pe { goto _test_eof687 }
	fallthrough
case 687:
// line 45392 "zparse.go"
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 83: goto st674
		case 92: goto st9
		case 115: goto st674
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
tr543:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st688
st688:
	p++
	if p == pe { goto _test_eof688 }
	fallthrough
case 688:
// line 45425 "zparse.go"
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 78: goto st674
		case 92: goto st9
		case 110: goto st674
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
tr544:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st689
st689:
	p++
	if p == pe { goto _test_eof689 }
	fallthrough
case 689:
// line 45458 "zparse.go"
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 88: goto st690
		case 92: goto st9
		case 120: goto st690
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st690:
	p++
	if p == pe { goto _test_eof690 }
	fallthrough
case 690:
	switch data[p] {
		case 9: goto tr2340
		case 10: goto tr2341
		case 32: goto tr2340
		case 40: goto tr2342
		case 41: goto tr2343
		case 43: goto st9
		case 59: goto tr2344
		case 61: goto st9
		case 92: goto st9
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
tr545:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st691
st691:
	p++
	if p == pe { goto _test_eof691 }
	fallthrough
case 691:
// line 45515 "zparse.go"
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 79: goto st692
		case 83: goto st694
		case 92: goto st9
		case 111: goto st692
		case 115: goto st694
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st692:
	p++
	if p == pe { goto _test_eof692 }
	fallthrough
case 692:
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 78: goto st693
		case 92: goto st9
		case 110: goto st693
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st693:
	p++
	if p == pe { goto _test_eof693 }
	fallthrough
case 693:
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 69: goto st674
		case 92: goto st9
		case 101: goto st674
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st694:
	p++
	if p == pe { goto _test_eof694 }
	fallthrough
case 694:
	switch data[p] {
		case 9: goto tr2348
		case 10: goto tr2349
		case 32: goto tr2348
		case 40: goto tr2350
		case 41: goto tr2351
		case 43: goto st9
		case 59: goto tr2352
		case 61: goto st9
		case 92: goto st9
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
tr1813:
// line 89 "zparse.rl"
	{ mark = p }
	goto st695
tr2661:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st695
tr1808:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st695
tr2939:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st695
tr3588:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st695
tr2352:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st695
tr2515:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st695
tr3768:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st695
tr3912:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st695
st695:
	p++
	if p == pe { goto _test_eof695 }
	fallthrough
case 695:
// line 45823 "zparse.go"
	if data[p] == 10 { goto tr2354 }
	goto st695
tr546:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st696
st696:
	p++
	if p == pe { goto _test_eof696 }
	fallthrough
case 696:
// line 45837 "zparse.go"
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 82: goto st697
		case 92: goto st9
		case 114: goto st697
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st697:
	p++
	if p == pe { goto _test_eof697 }
	fallthrough
case 697:
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 83: goto st698
		case 92: goto st9
		case 115: goto st698
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st698:
	p++
	if p == pe { goto _test_eof698 }
	fallthrough
case 698:
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 73: goto st699
		case 92: goto st9
		case 105: goto st699
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st699:
	p++
	if p == pe { goto _test_eof699 }
	fallthrough
case 699:
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 71: goto st700
		case 92: goto st9
		case 103: goto st700
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st700:
	p++
	if p == pe { goto _test_eof700 }
	fallthrough
case 700:
	switch data[p] {
		case 9: goto tr2359
		case 10: goto tr2360
		case 32: goto tr2359
		case 40: goto tr2361
		case 41: goto tr2362
		case 43: goto st9
		case 59: goto tr2363
		case 61: goto st9
		case 92: goto st9
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
tr2366:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st701
tr2367:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st701
tr2944:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr2946:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr2947:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr3593:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr3595:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr3596:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr2858:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr2860:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr2861:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr2359:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr2361:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr2362:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr2520:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr2522:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr2523:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr2666:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr2668:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr2669:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr3773:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr3775:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr3776:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr3917:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr3919:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
tr3920:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st701
st701:
	p++
	if p == pe { goto _test_eof701 }
	fallthrough
case 701:
// line 46603 "zparse.go"
	switch data[p] {
		case 9: goto st701
		case 10: goto tr2365
		case 32: goto st701
		case 40: goto tr2366
		case 41: goto tr2367
		case 59: goto tr2368
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr302 }
	goto st0
tr2365:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1757
tr2376:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1757
tr2945:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1757
tr3594:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1757
tr2859:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1757
tr2360:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1757
tr2521:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1757
tr2667:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1757
tr3774:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1757
tr3918:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1757
st1757:
	p++
	if p == pe { goto _test_eof1757 }
	fallthrough
case 1757:
// line 46844 "zparse.go"
	switch data[p] {
		case 9: goto st554
		case 10: goto tr1904
		case 32: goto st554
		case 40: goto tr1905
		case 41: goto tr1906
		case 59: goto tr1907
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5436
	}
	goto st0
tr5436:
// line 89 "zparse.rl"
	{ mark = p }
	goto st702
st702:
	p++
	if p == pe { goto _test_eof702 }
	fallthrough
case 702:
// line 46876 "zparse.go"
	switch data[p] {
		case 9: goto tr2369
		case 10: goto tr2370
		case 32: goto tr2369
		case 40: goto tr2371
		case 41: goto tr2372
		case 59: goto tr2374
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st702
	}
	goto st0
tr2368:
// line 89 "zparse.rl"
	{ mark = p }
	goto st703
tr2948:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st703
tr3597:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st703
tr2862:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st703
tr2363:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st703
tr2524:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st703
tr2670:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st703
tr3777:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st703
tr3921:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st703
st703:
	p++
	if p == pe { goto _test_eof703 }
	fallthrough
case 703:
// line 47107 "zparse.go"
	if data[p] == 10 { goto tr2376 }
	goto st703
tr547:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st704
st704:
	p++
	if p == pe { goto _test_eof704 }
	fallthrough
case 704:
// line 47121 "zparse.go"
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 79: goto st705
		case 92: goto st9
		case 111: goto st705
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st705:
	p++
	if p == pe { goto _test_eof705 }
	fallthrough
case 705:
	switch data[p] {
		case 9: goto tr60
		case 10: goto tr61
		case 32: goto tr60
		case 40: goto tr62
		case 41: goto tr63
		case 43: goto st9
		case 59: goto tr65
		case 61: goto st9
		case 65: goto st706
		case 92: goto st9
		case 97: goto st706
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
st706:
	p++
	if p == pe { goto _test_eof706 }
	fallthrough
case 706:
	switch data[p] {
		case 9: goto tr2379
		case 10: goto tr2380
		case 32: goto tr2379
		case 40: goto tr2381
		case 41: goto tr2382
		case 43: goto st9
		case 59: goto tr2383
		case 61: goto st9
		case 92: goto st9
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st9 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st9 }
	} else {
		goto st9
	}
	goto st0
tr2386:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st707
tr2387:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st707
tr2865:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr2867:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr2868:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr2951:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr2953:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr2954:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr3600:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr3602:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr3603:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr2379:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr2381:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr2382:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr2527:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr2529:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr2530:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr2673:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr2675:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr2676:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr3780:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr3782:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr3783:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr3924:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr3926:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
tr3927:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st707
st707:
	p++
	if p == pe { goto _test_eof707 }
	fallthrough
case 707:
// line 47835 "zparse.go"
	switch data[p] {
		case 9: goto st707
		case 10: goto tr2385
		case 32: goto st707
		case 40: goto tr2386
		case 41: goto tr2387
		case 43: goto tr417
		case 59: goto tr2388
		case 61: goto tr417
		case 92: goto tr417
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr417 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr417 }
	} else {
		goto tr417
	}
	goto st0
tr2385:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1758
tr2390:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1758
tr2866:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1758
tr2952:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1758
tr3601:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1758
tr2380:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1758
tr2528:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1758
tr2674:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1758
tr3781:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1758
tr3925:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1758
st1758:
	p++
	if p == pe { goto _test_eof1758 }
	fallthrough
case 1758:
// line 48085 "zparse.go"
	switch data[p] {
		case 9: goto st565
		case 10: goto tr1941
		case 32: goto st565
		case 40: goto tr1942
		case 41: goto tr1943
		case 43: goto tr417
		case 47: goto tr417
		case 58: goto tr417
		case 59: goto tr1944
		case 61: goto tr417
		case 92: goto tr5419
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto tr5419 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr5419 }
	} else {
		goto tr5419
	}
	goto st0
tr2388:
// line 89 "zparse.rl"
	{ mark = p }
	goto st708
tr2869:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st708
tr2955:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st708
tr3604:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st708
tr2383:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st708
tr2531:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st708
tr2677:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st708
tr3784:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st708
tr3928:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st708
st708:
	p++
	if p == pe { goto _test_eof708 }
	fallthrough
case 708:
// line 48316 "zparse.go"
	if data[p] == 10 { goto tr2390 }
	goto st708
tr5434:
// line 89 "zparse.rl"
	{ mark = p }
	goto st709
st709:
	p++
	if p == pe { goto _test_eof709 }
	fallthrough
case 709:
// line 48328 "zparse.go"
	switch data[p] {
		case 9: goto tr2391
		case 10: goto tr2392
		case 32: goto tr2391
		case 40: goto tr2393
		case 41: goto tr2394
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr2396
		case 61: goto st9
		case 92: goto st170
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st170 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st170 }
		} else if data[p] >= 65 {
			goto st170
		}
	} else {
		goto st709
	}
	goto st0
tr2205:
// line 89 "zparse.rl"
	{ mark = p }
	goto st710
tr3118:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st710
tr5219:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st710
tr3373:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st710
tr2198:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st710
st710:
	p++
	if p == pe { goto _test_eof710 }
	fallthrough
case 710:
// line 48456 "zparse.go"
	if data[p] == 10 { goto tr2398 }
	goto st710
st711:
	p++
	if p == pe { goto _test_eof711 }
	fallthrough
case 711:
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 65: goto st712
		case 92: goto st616
		case 97: goto st712
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st712:
	p++
	if p == pe { goto _test_eof712 }
	fallthrough
case 712:
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 65: goto st713
		case 92: goto st616
		case 97: goto st713
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st713:
	p++
	if p == pe { goto _test_eof713 }
	fallthrough
case 713:
	switch data[p] {
		case 9: goto tr2401
		case 10: goto tr2402
		case 32: goto tr2401
		case 40: goto tr2403
		case 41: goto tr2404
		case 43: goto st616
		case 59: goto tr2405
		case 61: goto st616
		case 92: goto st616
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
tr2408:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st714
tr2409:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st714
tr3123:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st714
tr3125:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st714
tr3126:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st714
tr5224:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st714
tr5226:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st714
tr5227:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st714
tr3378:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st714
tr3380:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st714
tr3381:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st714
tr2401:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st714
tr2403:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st714
tr2404:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st714
st714:
	p++
	if p == pe { goto _test_eof714 }
	fallthrough
case 714:
// line 48840 "zparse.go"
	switch data[p] {
		case 9: goto st714
		case 10: goto tr2407
		case 32: goto st714
		case 40: goto tr2408
		case 41: goto tr2409
		case 43: goto tr86
		case 58: goto tr86
		case 59: goto tr2410
		case 61: goto tr86
		case 92: goto tr86
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr86 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr86 }
		} else if data[p] >= 65 {
			goto tr86
		}
	} else {
		goto tr1232
	}
	goto st0
tr2407:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1759
tr2539:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1759
tr3124:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1759
tr5225:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1759
tr3379:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1759
tr2402:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1759
st1759:
	p++
	if p == pe { goto _test_eof1759 }
	fallthrough
case 1759:
// line 48980 "zparse.go"
	switch data[p] {
		case 9: goto st715
		case 10: goto tr2412
		case 32: goto st715
		case 40: goto tr2413
		case 41: goto tr2414
		case 43: goto tr86
		case 47: goto tr86
		case 58: goto tr86
		case 59: goto tr2416
		case 61: goto tr86
		case 92: goto tr5367
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5367 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr5367 }
		} else if data[p] >= 65 {
			goto tr5367
		}
	} else {
		goto tr5437
	}
	goto st0
tr2413:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st715
tr2414:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st715
st715:
	p++
	if p == pe { goto _test_eof715 }
	fallthrough
case 715:
// line 49020 "zparse.go"
	switch data[p] {
		case 9: goto st715
		case 10: goto tr2412
		case 32: goto st715
		case 40: goto tr2413
		case 41: goto tr2414
		case 43: goto tr86
		case 58: goto tr86
		case 59: goto tr2416
		case 61: goto tr86
		case 65: goto tr648
		case 67: goto tr649
		case 68: goto tr650
		case 72: goto tr651
		case 73: goto tr652
		case 77: goto tr653
		case 78: goto tr654
		case 82: goto tr655
		case 83: goto tr656
		case 92: goto tr86
		case 97: goto tr648
		case 99: goto tr649
		case 100: goto tr650
		case 104: goto tr651
		case 105: goto tr652
		case 109: goto tr653
		case 110: goto tr654
		case 114: goto tr655
		case 115: goto tr656
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr86 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr86 }
		} else if data[p] >= 66 {
			goto tr86
		}
	} else {
		goto tr2415
	}
	goto st0
tr2412:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1760
tr2424:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1760
st1760:
	p++
	if p == pe { goto _test_eof1760 }
	fallthrough
case 1760:
// line 49078 "zparse.go"
	switch data[p] {
		case 9: goto st715
		case 10: goto tr2412
		case 32: goto st715
		case 40: goto tr2413
		case 41: goto tr2414
		case 43: goto tr86
		case 47: goto tr86
		case 58: goto tr86
		case 59: goto tr2416
		case 61: goto tr86
		case 65: goto tr5369
		case 67: goto tr5370
		case 68: goto tr5371
		case 72: goto tr5372
		case 73: goto tr5373
		case 77: goto tr5374
		case 78: goto tr5375
		case 82: goto tr5376
		case 83: goto tr5377
		case 92: goto tr5367
		case 95: goto st2
		case 97: goto tr5369
		case 99: goto tr5370
		case 100: goto tr5371
		case 104: goto tr5372
		case 105: goto tr5373
		case 109: goto tr5374
		case 110: goto tr5375
		case 114: goto tr5376
		case 115: goto tr5377
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5367 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr5367 }
		} else if data[p] >= 66 {
			goto tr5367
		}
	} else {
		goto tr5438
	}
	goto st0
tr5438:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st716
st716:
	p++
	if p == pe { goto _test_eof716 }
	fallthrough
case 716:
// line 49134 "zparse.go"
	switch data[p] {
		case 9: goto tr2417
		case 10: goto tr2418
		case 32: goto tr2417
		case 40: goto tr2419
		case 41: goto tr2420
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr2422
		case 61: goto st18
		case 92: goto st178
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st178 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st178 }
		} else if data[p] >= 65 {
			goto st178
		}
	} else {
		goto st716
	}
	goto st0
tr2416:
// line 89 "zparse.rl"
	{ mark = p }
	goto st717
st717:
	p++
	if p == pe { goto _test_eof717 }
	fallthrough
case 717:
// line 49170 "zparse.go"
	if data[p] == 10 { goto tr2424 }
	goto st717
tr5371:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st718
st718:
	p++
	if p == pe { goto _test_eof718 }
	fallthrough
case 718:
// line 49184 "zparse.go"
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 78: goto st719
		case 83: goto st724
		case 92: goto st178
		case 95: goto st2
		case 110: goto st719
		case 115: goto st724
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st719:
	p++
	if p == pe { goto _test_eof719 }
	fallthrough
case 719:
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 83: goto st720
		case 92: goto st178
		case 95: goto st2
		case 115: goto st720
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st720:
	p++
	if p == pe { goto _test_eof720 }
	fallthrough
case 720:
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 75: goto st721
		case 92: goto st178
		case 95: goto st2
		case 107: goto st721
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st721:
	p++
	if p == pe { goto _test_eof721 }
	fallthrough
case 721:
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 69: goto st722
		case 92: goto st178
		case 95: goto st2
		case 101: goto st722
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st722:
	p++
	if p == pe { goto _test_eof722 }
	fallthrough
case 722:
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 89: goto st723
		case 92: goto st178
		case 95: goto st2
		case 121: goto st723
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st723:
	p++
	if p == pe { goto _test_eof723 }
	fallthrough
case 723:
	switch data[p] {
		case 9: goto tr2431
		case 10: goto tr2432
		case 32: goto tr2431
		case 40: goto tr2433
		case 41: goto tr2434
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr2435
		case 61: goto st18
		case 92: goto st178
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st724:
	p++
	if p == pe { goto _test_eof724 }
	fallthrough
case 724:
	switch data[p] {
		case 9: goto tr2436
		case 10: goto tr2437
		case 32: goto tr2436
		case 40: goto tr2438
		case 41: goto tr2439
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr2440
		case 61: goto st18
		case 92: goto st178
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
tr5372:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st725
st725:
	p++
	if p == pe { goto _test_eof725 }
	fallthrough
case 725:
// line 49392 "zparse.go"
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 83: goto st186
		case 92: goto st178
		case 95: goto st2
		case 115: goto st186
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
tr5373:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st726
st726:
	p++
	if p == pe { goto _test_eof726 }
	fallthrough
case 726:
// line 49428 "zparse.go"
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 78: goto st186
		case 92: goto st178
		case 95: goto st2
		case 110: goto st186
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
tr5374:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st727
st727:
	p++
	if p == pe { goto _test_eof727 }
	fallthrough
case 727:
// line 49464 "zparse.go"
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 88: goto st728
		case 92: goto st178
		case 95: goto st2
		case 120: goto st728
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st728:
	p++
	if p == pe { goto _test_eof728 }
	fallthrough
case 728:
	switch data[p] {
		case 9: goto tr2442
		case 10: goto tr2443
		case 32: goto tr2442
		case 40: goto tr2444
		case 41: goto tr2445
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr2446
		case 61: goto st18
		case 92: goto st178
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
tr5375:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st729
st729:
	p++
	if p == pe { goto _test_eof729 }
	fallthrough
case 729:
// line 49527 "zparse.go"
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 79: goto st730
		case 83: goto st732
		case 92: goto st178
		case 95: goto st2
		case 111: goto st730
		case 115: goto st732
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st730:
	p++
	if p == pe { goto _test_eof730 }
	fallthrough
case 730:
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 78: goto st731
		case 92: goto st178
		case 95: goto st2
		case 110: goto st731
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st731:
	p++
	if p == pe { goto _test_eof731 }
	fallthrough
case 731:
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 69: goto st186
		case 92: goto st178
		case 95: goto st2
		case 101: goto st186
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st732:
	p++
	if p == pe { goto _test_eof732 }
	fallthrough
case 732:
	switch data[p] {
		case 9: goto tr2450
		case 10: goto tr2451
		case 32: goto tr2450
		case 40: goto tr2452
		case 41: goto tr2453
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr2454
		case 61: goto st18
		case 92: goto st178
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
tr5376:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st733
st733:
	p++
	if p == pe { goto _test_eof733 }
	fallthrough
case 733:
// line 49650 "zparse.go"
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 82: goto st734
		case 92: goto st178
		case 95: goto st2
		case 114: goto st734
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st734:
	p++
	if p == pe { goto _test_eof734 }
	fallthrough
case 734:
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 83: goto st735
		case 92: goto st178
		case 95: goto st2
		case 115: goto st735
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st735:
	p++
	if p == pe { goto _test_eof735 }
	fallthrough
case 735:
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 73: goto st736
		case 92: goto st178
		case 95: goto st2
		case 105: goto st736
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st736:
	p++
	if p == pe { goto _test_eof736 }
	fallthrough
case 736:
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 71: goto st737
		case 92: goto st178
		case 95: goto st2
		case 103: goto st737
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st737:
	p++
	if p == pe { goto _test_eof737 }
	fallthrough
case 737:
	switch data[p] {
		case 9: goto tr2459
		case 10: goto tr2460
		case 32: goto tr2459
		case 40: goto tr2461
		case 41: goto tr2462
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr2463
		case 61: goto st18
		case 92: goto st178
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
tr5377:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st738
st738:
	p++
	if p == pe { goto _test_eof738 }
	fallthrough
case 738:
// line 49800 "zparse.go"
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 79: goto st739
		case 92: goto st178
		case 95: goto st2
		case 111: goto st739
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st739:
	p++
	if p == pe { goto _test_eof739 }
	fallthrough
case 739:
	switch data[p] {
		case 9: goto tr657
		case 10: goto tr658
		case 32: goto tr657
		case 40: goto tr659
		case 41: goto tr660
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr662
		case 61: goto st18
		case 65: goto st740
		case 92: goto st178
		case 95: goto st2
		case 97: goto st740
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
st740:
	p++
	if p == pe { goto _test_eof740 }
	fallthrough
case 740:
	switch data[p] {
		case 9: goto tr2466
		case 10: goto tr2467
		case 32: goto tr2466
		case 40: goto tr2468
		case 41: goto tr2469
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr2470
		case 61: goto st18
		case 92: goto st178
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st178 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st178 }
	} else {
		goto st178
	}
	goto st0
tr2415:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st741
st741:
	p++
	if p == pe { goto _test_eof741 }
	fallthrough
case 741:
// line 49892 "zparse.go"
	switch data[p] {
		case 9: goto tr2471
		case 10: goto tr2472
		case 32: goto tr2471
		case 40: goto tr2473
		case 41: goto tr2474
		case 43: goto st18
		case 58: goto st18
		case 59: goto tr2476
		case 61: goto st18
		case 92: goto st18
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st18 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st18 }
		} else if data[p] >= 65 {
			goto st18
		}
	} else {
		goto st741
	}
	goto st0
tr649:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st742
st742:
	p++
	if p == pe { goto _test_eof742 }
	fallthrough
case 742:
// line 49928 "zparse.go"
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 72: goto st269
		case 78: goto st743
		case 83: goto st269
		case 92: goto st18
		case 104: goto st269
		case 110: goto st743
		case 115: goto st269
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st743:
	p++
	if p == pe { goto _test_eof743 }
	fallthrough
case 743:
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 65: goto st744
		case 92: goto st18
		case 97: goto st744
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st744:
	p++
	if p == pe { goto _test_eof744 }
	fallthrough
case 744:
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 77: goto st745
		case 92: goto st18
		case 109: goto st745
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st745:
	p++
	if p == pe { goto _test_eof745 }
	fallthrough
case 745:
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 69: goto st746
		case 92: goto st18
		case 101: goto st746
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st746:
	p++
	if p == pe { goto _test_eof746 }
	fallthrough
case 746:
	switch data[p] {
		case 9: goto tr2481
		case 10: goto tr2482
		case 32: goto tr2481
		case 40: goto tr2483
		case 41: goto tr2484
		case 43: goto st18
		case 59: goto tr2485
		case 61: goto st18
		case 92: goto st18
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
tr650:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st747
st747:
	p++
	if p == pe { goto _test_eof747 }
	fallthrough
case 747:
// line 50067 "zparse.go"
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 78: goto st748
		case 83: goto st753
		case 92: goto st18
		case 110: goto st748
		case 115: goto st753
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st748:
	p++
	if p == pe { goto _test_eof748 }
	fallthrough
case 748:
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 83: goto st749
		case 92: goto st18
		case 115: goto st749
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st749:
	p++
	if p == pe { goto _test_eof749 }
	fallthrough
case 749:
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 75: goto st750
		case 92: goto st18
		case 107: goto st750
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st750:
	p++
	if p == pe { goto _test_eof750 }
	fallthrough
case 750:
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 69: goto st751
		case 92: goto st18
		case 101: goto st751
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st751:
	p++
	if p == pe { goto _test_eof751 }
	fallthrough
case 751:
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 89: goto st752
		case 92: goto st18
		case 121: goto st752
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st752:
	p++
	if p == pe { goto _test_eof752 }
	fallthrough
case 752:
	switch data[p] {
		case 9: goto tr2492
		case 10: goto tr2493
		case 32: goto tr2492
		case 40: goto tr2494
		case 41: goto tr2495
		case 43: goto st18
		case 59: goto tr2496
		case 61: goto st18
		case 92: goto st18
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st753:
	p++
	if p == pe { goto _test_eof753 }
	fallthrough
case 753:
	switch data[p] {
		case 9: goto tr2497
		case 10: goto tr2498
		case 32: goto tr2497
		case 40: goto tr2499
		case 41: goto tr2500
		case 43: goto st18
		case 59: goto tr2501
		case 61: goto st18
		case 92: goto st18
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
tr651:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st754
st754:
	p++
	if p == pe { goto _test_eof754 }
	fallthrough
case 754:
// line 50254 "zparse.go"
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 83: goto st269
		case 92: goto st18
		case 115: goto st269
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
tr652:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st755
st755:
	p++
	if p == pe { goto _test_eof755 }
	fallthrough
case 755:
// line 50287 "zparse.go"
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 78: goto st269
		case 92: goto st18
		case 110: goto st269
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
tr653:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st756
st756:
	p++
	if p == pe { goto _test_eof756 }
	fallthrough
case 756:
// line 50320 "zparse.go"
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 88: goto st757
		case 92: goto st18
		case 120: goto st757
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st757:
	p++
	if p == pe { goto _test_eof757 }
	fallthrough
case 757:
	switch data[p] {
		case 9: goto tr2503
		case 10: goto tr2504
		case 32: goto tr2503
		case 40: goto tr2505
		case 41: goto tr2506
		case 43: goto st18
		case 59: goto tr2507
		case 61: goto st18
		case 92: goto st18
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
tr654:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st758
st758:
	p++
	if p == pe { goto _test_eof758 }
	fallthrough
case 758:
// line 50377 "zparse.go"
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 79: goto st759
		case 83: goto st761
		case 92: goto st18
		case 111: goto st759
		case 115: goto st761
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st759:
	p++
	if p == pe { goto _test_eof759 }
	fallthrough
case 759:
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 78: goto st760
		case 92: goto st18
		case 110: goto st760
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st760:
	p++
	if p == pe { goto _test_eof760 }
	fallthrough
case 760:
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 69: goto st269
		case 92: goto st18
		case 101: goto st269
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st761:
	p++
	if p == pe { goto _test_eof761 }
	fallthrough
case 761:
	switch data[p] {
		case 9: goto tr2511
		case 10: goto tr2512
		case 32: goto tr2511
		case 40: goto tr2513
		case 41: goto tr2514
		case 43: goto st18
		case 59: goto tr2515
		case 61: goto st18
		case 92: goto st18
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
tr655:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st762
st762:
	p++
	if p == pe { goto _test_eof762 }
	fallthrough
case 762:
// line 50488 "zparse.go"
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 82: goto st763
		case 92: goto st18
		case 114: goto st763
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st763:
	p++
	if p == pe { goto _test_eof763 }
	fallthrough
case 763:
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 83: goto st764
		case 92: goto st18
		case 115: goto st764
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st764:
	p++
	if p == pe { goto _test_eof764 }
	fallthrough
case 764:
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 73: goto st765
		case 92: goto st18
		case 105: goto st765
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st765:
	p++
	if p == pe { goto _test_eof765 }
	fallthrough
case 765:
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 71: goto st766
		case 92: goto st18
		case 103: goto st766
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st766:
	p++
	if p == pe { goto _test_eof766 }
	fallthrough
case 766:
	switch data[p] {
		case 9: goto tr2520
		case 10: goto tr2521
		case 32: goto tr2520
		case 40: goto tr2522
		case 41: goto tr2523
		case 43: goto st18
		case 59: goto tr2524
		case 61: goto st18
		case 92: goto st18
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
tr656:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st767
st767:
	p++
	if p == pe { goto _test_eof767 }
	fallthrough
case 767:
// line 50623 "zparse.go"
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 79: goto st768
		case 92: goto st18
		case 111: goto st768
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st768:
	p++
	if p == pe { goto _test_eof768 }
	fallthrough
case 768:
	switch data[p] {
		case 9: goto tr88
		case 10: goto tr89
		case 32: goto tr88
		case 40: goto tr90
		case 41: goto tr91
		case 43: goto st18
		case 59: goto tr93
		case 61: goto st18
		case 65: goto st769
		case 92: goto st18
		case 97: goto st769
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
st769:
	p++
	if p == pe { goto _test_eof769 }
	fallthrough
case 769:
	switch data[p] {
		case 9: goto tr2527
		case 10: goto tr2528
		case 32: goto tr2527
		case 40: goto tr2529
		case 41: goto tr2530
		case 43: goto st18
		case 59: goto tr2531
		case 61: goto st18
		case 92: goto st18
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st18 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st18 }
	} else {
		goto st18
	}
	goto st0
tr5437:
// line 89 "zparse.rl"
	{ mark = p }
	goto st770
st770:
	p++
	if p == pe { goto _test_eof770 }
	fallthrough
case 770:
// line 50704 "zparse.go"
	switch data[p] {
		case 9: goto tr2532
		case 10: goto tr2533
		case 32: goto tr2532
		case 40: goto tr2534
		case 41: goto tr2535
		case 43: goto st18
		case 47: goto st18
		case 58: goto st18
		case 59: goto tr2537
		case 61: goto st18
		case 92: goto st178
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st178 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st178 }
		} else if data[p] >= 65 {
			goto st178
		}
	} else {
		goto st770
	}
	goto st0
tr2410:
// line 89 "zparse.rl"
	{ mark = p }
	goto st771
tr3127:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st771
tr5228:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st771
tr3382:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st771
tr2405:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st771
st771:
	p++
	if p == pe { goto _test_eof771 }
	fallthrough
case 771:
// line 50832 "zparse.go"
	if data[p] == 10 { goto tr2539 }
	goto st771
st772:
	p++
	if p == pe { goto _test_eof772 }
	fallthrough
case 772:
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 89: goto st773
		case 92: goto st616
		case 121: goto st773
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st773:
	p++
	if p == pe { goto _test_eof773 }
	fallthrough
case 773:
	switch data[p] {
		case 9: goto tr2541
		case 10: goto tr2542
		case 32: goto tr2541
		case 40: goto tr2543
		case 41: goto tr2544
		case 43: goto st616
		case 59: goto tr2545
		case 61: goto st616
		case 92: goto st616
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
tr2548:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st774
tr2549:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st774
tr5230:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st774
tr5232:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st774
tr5233:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st774
tr3384:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st774
tr3386:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st774
tr3387:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st774
tr2541:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st774
tr2543:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st774
tr2544:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st774
tr3129:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st774
tr3131:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st774
tr3132:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st774
st774:
	p++
	if p == pe { goto _test_eof774 }
	fallthrough
case 774:
// line 51082 "zparse.go"
	switch data[p] {
		case 9: goto st774
		case 10: goto tr2547
		case 32: goto st774
		case 40: goto tr2548
		case 41: goto tr2549
		case 59: goto tr2550
		case 65: goto tr105
		case 67: goto tr106
		case 68: goto tr40
		case 77: goto tr43
		case 78: goto tr107
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr105
		case 99: goto tr106
		case 100: goto tr40
		case 109: goto tr43
		case 110: goto tr107
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1988 }
	goto st0
tr2547:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1761
tr2552:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1761
tr5231:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1761
tr3385:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1761
tr2542:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1761
tr3130:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1761
st1761:
	p++
	if p == pe { goto _test_eof1761 }
	fallthrough
case 1761:
// line 51186 "zparse.go"
	switch data[p] {
		case 9: goto st618
		case 10: goto tr2144
		case 32: goto st618
		case 40: goto tr2145
		case 41: goto tr2146
		case 59: goto tr2148
		case 65: goto tr5390
		case 67: goto tr5391
		case 68: goto tr5349
		case 77: goto tr5352
		case 78: goto tr5392
		case 82: goto tr5354
		case 83: goto tr5355
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5390
		case 99: goto tr5391
		case 100: goto tr5349
		case 109: goto tr5352
		case 110: goto tr5392
		case 114: goto tr5354
		case 115: goto tr5355
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5439
	}
	goto st0
tr2550:
// line 89 "zparse.rl"
	{ mark = p }
	goto st775
tr5234:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st775
tr3388:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st775
tr2545:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st775
tr3133:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st775
st775:
	p++
	if p == pe { goto _test_eof775 }
	fallthrough
case 775:
// line 51288 "zparse.go"
	if data[p] == 10 { goto tr2552 }
	goto st775
tr2124:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st776
st776:
	p++
	if p == pe { goto _test_eof776 }
	fallthrough
case 776:
// line 51302 "zparse.go"
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 72: goto st773
		case 78: goto st777
		case 83: goto st773
		case 92: goto st616
		case 104: goto st773
		case 110: goto st777
		case 115: goto st773
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st777:
	p++
	if p == pe { goto _test_eof777 }
	fallthrough
case 777:
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 65: goto st778
		case 92: goto st616
		case 97: goto st778
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st778:
	p++
	if p == pe { goto _test_eof778 }
	fallthrough
case 778:
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 77: goto st779
		case 92: goto st616
		case 109: goto st779
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st779:
	p++
	if p == pe { goto _test_eof779 }
	fallthrough
case 779:
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 69: goto st780
		case 92: goto st616
		case 101: goto st780
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st780:
	p++
	if p == pe { goto _test_eof780 }
	fallthrough
case 780:
	switch data[p] {
		case 9: goto tr2557
		case 10: goto tr2558
		case 32: goto tr2557
		case 40: goto tr2559
		case 41: goto tr2560
		case 43: goto st616
		case 59: goto tr2561
		case 61: goto st616
		case 92: goto st616
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
tr2564:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st781
tr2565:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st781
tr3138:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st781
tr3140:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st781
tr3141:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st781
tr3393:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st781
tr3395:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st781
tr3396:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st781
tr2557:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st781
tr2559:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st781
tr2560:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st781
tr5239:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st781
tr5241:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st781
tr5242:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st781
st781:
	p++
	if p == pe { goto _test_eof781 }
	fallthrough
case 781:
// line 51735 "zparse.go"
	switch data[p] {
		case 9: goto st781
		case 10: goto tr2563
		case 32: goto st781
		case 40: goto tr2564
		case 41: goto tr2565
		case 43: goto tr121
		case 58: goto tr121
		case 59: goto tr2566
		case 61: goto tr121
		case 92: goto tr121
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr121 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr121 }
		} else if data[p] >= 65 {
			goto tr121
		}
	} else {
		goto tr1264
	}
	goto st0
tr2563:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1762
tr2685:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1762
tr3139:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1762
tr3394:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1762
tr2558:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1762
tr5240:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1762
st1762:
	p++
	if p == pe { goto _test_eof1762 }
	fallthrough
case 1762:
// line 51875 "zparse.go"
	switch data[p] {
		case 9: goto st782
		case 10: goto tr2568
		case 32: goto st782
		case 40: goto tr2569
		case 41: goto tr2570
		case 43: goto tr121
		case 47: goto tr121
		case 58: goto tr121
		case 59: goto tr2572
		case 61: goto tr121
		case 92: goto tr5378
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5378 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr5378 }
		} else if data[p] >= 65 {
			goto tr5378
		}
	} else {
		goto tr5440
	}
	goto st0
tr2569:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st782
tr2570:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st782
st782:
	p++
	if p == pe { goto _test_eof782 }
	fallthrough
case 782:
// line 51915 "zparse.go"
	switch data[p] {
		case 9: goto st782
		case 10: goto tr2568
		case 32: goto st782
		case 40: goto tr2569
		case 41: goto tr2570
		case 43: goto tr121
		case 58: goto tr121
		case 59: goto tr2572
		case 61: goto tr121
		case 65: goto tr580
		case 67: goto tr581
		case 68: goto tr582
		case 72: goto tr583
		case 73: goto tr584
		case 77: goto tr585
		case 78: goto tr586
		case 82: goto tr587
		case 83: goto tr588
		case 92: goto tr121
		case 97: goto tr580
		case 99: goto tr581
		case 100: goto tr582
		case 104: goto tr583
		case 105: goto tr584
		case 109: goto tr585
		case 110: goto tr586
		case 114: goto tr587
		case 115: goto tr588
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr121 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr121 }
		} else if data[p] >= 66 {
			goto tr121
		}
	} else {
		goto tr2571
	}
	goto st0
tr2568:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1763
tr2580:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1763
st1763:
	p++
	if p == pe { goto _test_eof1763 }
	fallthrough
case 1763:
// line 51973 "zparse.go"
	switch data[p] {
		case 9: goto st782
		case 10: goto tr2568
		case 32: goto st782
		case 40: goto tr2569
		case 41: goto tr2570
		case 43: goto tr121
		case 47: goto tr121
		case 58: goto tr121
		case 59: goto tr2572
		case 61: goto tr121
		case 65: goto tr5380
		case 67: goto tr5381
		case 68: goto tr5382
		case 72: goto tr5383
		case 73: goto tr5384
		case 77: goto tr5385
		case 78: goto tr5386
		case 82: goto tr5387
		case 83: goto tr5388
		case 92: goto tr5378
		case 95: goto st2
		case 97: goto tr5380
		case 99: goto tr5381
		case 100: goto tr5382
		case 104: goto tr5383
		case 105: goto tr5384
		case 109: goto tr5385
		case 110: goto tr5386
		case 114: goto tr5387
		case 115: goto tr5388
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5378 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr5378 }
		} else if data[p] >= 66 {
			goto tr5378
		}
	} else {
		goto tr5441
	}
	goto st0
tr5441:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st783
st783:
	p++
	if p == pe { goto _test_eof783 }
	fallthrough
case 783:
// line 52029 "zparse.go"
	switch data[p] {
		case 9: goto tr2573
		case 10: goto tr2574
		case 32: goto tr2573
		case 40: goto tr2575
		case 41: goto tr2576
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr2578
		case 61: goto st31
		case 92: goto st193
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st193 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st193 }
		} else if data[p] >= 65 {
			goto st193
		}
	} else {
		goto st783
	}
	goto st0
tr2572:
// line 89 "zparse.rl"
	{ mark = p }
	goto st784
st784:
	p++
	if p == pe { goto _test_eof784 }
	fallthrough
case 784:
// line 52065 "zparse.go"
	if data[p] == 10 { goto tr2580 }
	goto st784
tr5383:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st785
st785:
	p++
	if p == pe { goto _test_eof785 }
	fallthrough
case 785:
// line 52079 "zparse.go"
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 83: goto st201
		case 92: goto st193
		case 95: goto st2
		case 115: goto st201
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
tr5384:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st786
st786:
	p++
	if p == pe { goto _test_eof786 }
	fallthrough
case 786:
// line 52115 "zparse.go"
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 78: goto st201
		case 92: goto st193
		case 95: goto st2
		case 110: goto st201
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
tr5385:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st787
st787:
	p++
	if p == pe { goto _test_eof787 }
	fallthrough
case 787:
// line 52151 "zparse.go"
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 88: goto st788
		case 92: goto st193
		case 95: goto st2
		case 120: goto st788
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st788:
	p++
	if p == pe { goto _test_eof788 }
	fallthrough
case 788:
	switch data[p] {
		case 9: goto tr2582
		case 10: goto tr2583
		case 32: goto tr2582
		case 40: goto tr2584
		case 41: goto tr2585
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr2586
		case 61: goto st31
		case 92: goto st193
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
tr5386:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st789
st789:
	p++
	if p == pe { goto _test_eof789 }
	fallthrough
case 789:
// line 52214 "zparse.go"
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 79: goto st790
		case 83: goto st792
		case 92: goto st193
		case 95: goto st2
		case 111: goto st790
		case 115: goto st792
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st790:
	p++
	if p == pe { goto _test_eof790 }
	fallthrough
case 790:
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 78: goto st791
		case 92: goto st193
		case 95: goto st2
		case 110: goto st791
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st791:
	p++
	if p == pe { goto _test_eof791 }
	fallthrough
case 791:
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 69: goto st201
		case 92: goto st193
		case 95: goto st2
		case 101: goto st201
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st792:
	p++
	if p == pe { goto _test_eof792 }
	fallthrough
case 792:
	switch data[p] {
		case 9: goto tr2590
		case 10: goto tr2591
		case 32: goto tr2590
		case 40: goto tr2592
		case 41: goto tr2593
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr2594
		case 61: goto st31
		case 92: goto st193
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
tr5387:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st793
st793:
	p++
	if p == pe { goto _test_eof793 }
	fallthrough
case 793:
// line 52337 "zparse.go"
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 82: goto st794
		case 92: goto st193
		case 95: goto st2
		case 114: goto st794
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st794:
	p++
	if p == pe { goto _test_eof794 }
	fallthrough
case 794:
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 83: goto st795
		case 92: goto st193
		case 95: goto st2
		case 115: goto st795
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st795:
	p++
	if p == pe { goto _test_eof795 }
	fallthrough
case 795:
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 73: goto st796
		case 92: goto st193
		case 95: goto st2
		case 105: goto st796
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st796:
	p++
	if p == pe { goto _test_eof796 }
	fallthrough
case 796:
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 71: goto st797
		case 92: goto st193
		case 95: goto st2
		case 103: goto st797
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st797:
	p++
	if p == pe { goto _test_eof797 }
	fallthrough
case 797:
	switch data[p] {
		case 9: goto tr2599
		case 10: goto tr2600
		case 32: goto tr2599
		case 40: goto tr2601
		case 41: goto tr2602
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr2603
		case 61: goto st31
		case 92: goto st193
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
tr5388:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st798
st798:
	p++
	if p == pe { goto _test_eof798 }
	fallthrough
case 798:
// line 52487 "zparse.go"
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 79: goto st799
		case 92: goto st193
		case 95: goto st2
		case 111: goto st799
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st799:
	p++
	if p == pe { goto _test_eof799 }
	fallthrough
case 799:
	switch data[p] {
		case 9: goto tr705
		case 10: goto tr706
		case 32: goto tr705
		case 40: goto tr707
		case 41: goto tr708
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr710
		case 61: goto st31
		case 65: goto st800
		case 92: goto st193
		case 95: goto st2
		case 97: goto st800
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st800:
	p++
	if p == pe { goto _test_eof800 }
	fallthrough
case 800:
	switch data[p] {
		case 9: goto tr2606
		case 10: goto tr2607
		case 32: goto tr2606
		case 40: goto tr2608
		case 41: goto tr2609
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr2610
		case 61: goto st31
		case 92: goto st193
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
tr2571:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st801
st801:
	p++
	if p == pe { goto _test_eof801 }
	fallthrough
case 801:
// line 52579 "zparse.go"
	switch data[p] {
		case 9: goto tr2611
		case 10: goto tr2612
		case 32: goto tr2611
		case 40: goto tr2613
		case 41: goto tr2614
		case 43: goto st31
		case 58: goto st31
		case 59: goto tr2616
		case 61: goto st31
		case 92: goto st31
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st31 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st31 }
		} else if data[p] >= 65 {
			goto st31
		}
	} else {
		goto st801
	}
	goto st0
tr581:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st802
st802:
	p++
	if p == pe { goto _test_eof802 }
	fallthrough
case 802:
// line 52615 "zparse.go"
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 72: goto st803
		case 78: goto st804
		case 83: goto st803
		case 92: goto st31
		case 104: goto st803
		case 110: goto st804
		case 115: goto st803
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st803:
	p++
	if p == pe { goto _test_eof803 }
	fallthrough
case 803:
	switch data[p] {
		case 9: goto tr2619
		case 10: goto tr2620
		case 32: goto tr2619
		case 40: goto tr2621
		case 41: goto tr2622
		case 43: goto st31
		case 59: goto tr2623
		case 61: goto st31
		case 92: goto st31
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st804:
	p++
	if p == pe { goto _test_eof804 }
	fallthrough
case 804:
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 65: goto st805
		case 92: goto st31
		case 97: goto st805
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st805:
	p++
	if p == pe { goto _test_eof805 }
	fallthrough
case 805:
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 77: goto st806
		case 92: goto st31
		case 109: goto st806
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st806:
	p++
	if p == pe { goto _test_eof806 }
	fallthrough
case 806:
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 69: goto st807
		case 92: goto st31
		case 101: goto st807
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st807:
	p++
	if p == pe { goto _test_eof807 }
	fallthrough
case 807:
	switch data[p] {
		case 9: goto tr2627
		case 10: goto tr2628
		case 32: goto tr2627
		case 40: goto tr2629
		case 41: goto tr2630
		case 43: goto st31
		case 59: goto tr2631
		case 61: goto st31
		case 92: goto st31
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
tr582:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st808
st808:
	p++
	if p == pe { goto _test_eof808 }
	fallthrough
case 808:
// line 52778 "zparse.go"
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 78: goto st809
		case 83: goto st814
		case 92: goto st31
		case 110: goto st809
		case 115: goto st814
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st809:
	p++
	if p == pe { goto _test_eof809 }
	fallthrough
case 809:
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 83: goto st810
		case 92: goto st31
		case 115: goto st810
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st810:
	p++
	if p == pe { goto _test_eof810 }
	fallthrough
case 810:
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 75: goto st811
		case 92: goto st31
		case 107: goto st811
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st811:
	p++
	if p == pe { goto _test_eof811 }
	fallthrough
case 811:
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 69: goto st812
		case 92: goto st31
		case 101: goto st812
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st812:
	p++
	if p == pe { goto _test_eof812 }
	fallthrough
case 812:
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 89: goto st813
		case 92: goto st31
		case 121: goto st813
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st813:
	p++
	if p == pe { goto _test_eof813 }
	fallthrough
case 813:
	switch data[p] {
		case 9: goto tr2638
		case 10: goto tr2639
		case 32: goto tr2638
		case 40: goto tr2640
		case 41: goto tr2641
		case 43: goto st31
		case 59: goto tr2642
		case 61: goto st31
		case 92: goto st31
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st814:
	p++
	if p == pe { goto _test_eof814 }
	fallthrough
case 814:
	switch data[p] {
		case 9: goto tr2643
		case 10: goto tr2644
		case 32: goto tr2643
		case 40: goto tr2645
		case 41: goto tr2646
		case 43: goto st31
		case 59: goto tr2647
		case 61: goto st31
		case 92: goto st31
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
tr583:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st815
st815:
	p++
	if p == pe { goto _test_eof815 }
	fallthrough
case 815:
// line 52965 "zparse.go"
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 83: goto st803
		case 92: goto st31
		case 115: goto st803
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
tr584:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st816
st816:
	p++
	if p == pe { goto _test_eof816 }
	fallthrough
case 816:
// line 52998 "zparse.go"
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 78: goto st803
		case 92: goto st31
		case 110: goto st803
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
tr585:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st817
st817:
	p++
	if p == pe { goto _test_eof817 }
	fallthrough
case 817:
// line 53031 "zparse.go"
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 88: goto st818
		case 92: goto st31
		case 120: goto st818
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st818:
	p++
	if p == pe { goto _test_eof818 }
	fallthrough
case 818:
	switch data[p] {
		case 9: goto tr2649
		case 10: goto tr2650
		case 32: goto tr2649
		case 40: goto tr2651
		case 41: goto tr2652
		case 43: goto st31
		case 59: goto tr2653
		case 61: goto st31
		case 92: goto st31
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
tr586:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st819
st819:
	p++
	if p == pe { goto _test_eof819 }
	fallthrough
case 819:
// line 53088 "zparse.go"
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 79: goto st820
		case 83: goto st822
		case 92: goto st31
		case 111: goto st820
		case 115: goto st822
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st820:
	p++
	if p == pe { goto _test_eof820 }
	fallthrough
case 820:
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 78: goto st821
		case 92: goto st31
		case 110: goto st821
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st821:
	p++
	if p == pe { goto _test_eof821 }
	fallthrough
case 821:
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 69: goto st803
		case 92: goto st31
		case 101: goto st803
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st822:
	p++
	if p == pe { goto _test_eof822 }
	fallthrough
case 822:
	switch data[p] {
		case 9: goto tr2657
		case 10: goto tr2658
		case 32: goto tr2657
		case 40: goto tr2659
		case 41: goto tr2660
		case 43: goto st31
		case 59: goto tr2661
		case 61: goto st31
		case 92: goto st31
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
tr587:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st823
st823:
	p++
	if p == pe { goto _test_eof823 }
	fallthrough
case 823:
// line 53199 "zparse.go"
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 82: goto st824
		case 92: goto st31
		case 114: goto st824
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st824:
	p++
	if p == pe { goto _test_eof824 }
	fallthrough
case 824:
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 83: goto st825
		case 92: goto st31
		case 115: goto st825
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st825:
	p++
	if p == pe { goto _test_eof825 }
	fallthrough
case 825:
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 73: goto st826
		case 92: goto st31
		case 105: goto st826
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st826:
	p++
	if p == pe { goto _test_eof826 }
	fallthrough
case 826:
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 71: goto st827
		case 92: goto st31
		case 103: goto st827
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st827:
	p++
	if p == pe { goto _test_eof827 }
	fallthrough
case 827:
	switch data[p] {
		case 9: goto tr2666
		case 10: goto tr2667
		case 32: goto tr2666
		case 40: goto tr2668
		case 41: goto tr2669
		case 43: goto st31
		case 59: goto tr2670
		case 61: goto st31
		case 92: goto st31
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
tr588:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st828
st828:
	p++
	if p == pe { goto _test_eof828 }
	fallthrough
case 828:
// line 53334 "zparse.go"
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 79: goto st829
		case 92: goto st31
		case 111: goto st829
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st829:
	p++
	if p == pe { goto _test_eof829 }
	fallthrough
case 829:
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 65: goto st830
		case 92: goto st31
		case 97: goto st830
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st830:
	p++
	if p == pe { goto _test_eof830 }
	fallthrough
case 830:
	switch data[p] {
		case 9: goto tr2673
		case 10: goto tr2674
		case 32: goto tr2673
		case 40: goto tr2675
		case 41: goto tr2676
		case 43: goto st31
		case 59: goto tr2677
		case 61: goto st31
		case 92: goto st31
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
tr5440:
// line 89 "zparse.rl"
	{ mark = p }
	goto st831
st831:
	p++
	if p == pe { goto _test_eof831 }
	fallthrough
case 831:
// line 53415 "zparse.go"
	switch data[p] {
		case 9: goto tr2678
		case 10: goto tr2679
		case 32: goto tr2678
		case 40: goto tr2680
		case 41: goto tr2681
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr2683
		case 61: goto st31
		case 92: goto st193
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st193 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st193 }
		} else if data[p] >= 65 {
			goto st193
		}
	} else {
		goto st831
	}
	goto st0
tr2566:
// line 89 "zparse.rl"
	{ mark = p }
	goto st832
tr3142:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st832
tr3397:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st832
tr2561:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st832
tr5243:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st832
st832:
	p++
	if p == pe { goto _test_eof832 }
	fallthrough
case 832:
// line 53543 "zparse.go"
	if data[p] == 10 { goto tr2685 }
	goto st832
tr2125:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st833
st833:
	p++
	if p == pe { goto _test_eof833 }
	fallthrough
case 833:
// line 53557 "zparse.go"
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 78: goto st834
		case 83: goto st853
		case 92: goto st616
		case 110: goto st834
		case 115: goto st853
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st834:
	p++
	if p == pe { goto _test_eof834 }
	fallthrough
case 834:
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 83: goto st835
		case 92: goto st616
		case 115: goto st835
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st835:
	p++
	if p == pe { goto _test_eof835 }
	fallthrough
case 835:
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 75: goto st836
		case 92: goto st616
		case 107: goto st836
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st836:
	p++
	if p == pe { goto _test_eof836 }
	fallthrough
case 836:
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 69: goto st837
		case 92: goto st616
		case 101: goto st837
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st837:
	p++
	if p == pe { goto _test_eof837 }
	fallthrough
case 837:
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 89: goto st838
		case 92: goto st616
		case 121: goto st838
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st838:
	p++
	if p == pe { goto _test_eof838 }
	fallthrough
case 838:
	switch data[p] {
		case 9: goto tr2692
		case 10: goto tr2693
		case 32: goto tr2692
		case 40: goto tr2694
		case 41: goto tr2695
		case 43: goto st616
		case 59: goto tr2696
		case 61: goto st616
		case 92: goto st616
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
tr2699:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st839
tr2700:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st839
tr3404:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st839
tr2692:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st839
tr5250:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st839
tr3149:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st839
tr2694:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st839
tr2695:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st839
tr3151:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st839
tr3152:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st839
tr3406:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st839
tr3407:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st839
tr5252:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st839
tr5253:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st839
st839:
	p++
	if p == pe { goto _test_eof839 }
	fallthrough
case 839:
// line 54014 "zparse.go"
	switch data[p] {
		case 9: goto st839
		case 10: goto tr2698
		case 32: goto st839
		case 40: goto tr2699
		case 41: goto tr2700
		case 59: goto tr2701
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1287 }
	goto st0
tr2698:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1764
tr2751:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1764
tr2693:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1764
tr3150:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1764
tr3405:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1764
tr5251:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1764
st1764:
	p++
	if p == pe { goto _test_eof1764 }
	fallthrough
case 1764:
// line 54140 "zparse.go"
	switch data[p] {
		case 9: goto st840
		case 10: goto tr2703
		case 32: goto st840
		case 40: goto tr2704
		case 41: goto tr2705
		case 59: goto tr2707
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5442
	}
	goto st0
tr2704:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st840
tr2705:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st840
st840:
	p++
	if p == pe { goto _test_eof840 }
	fallthrough
case 840:
// line 54176 "zparse.go"
	switch data[p] {
		case 9: goto st840
		case 10: goto tr2703
		case 32: goto st840
		case 40: goto tr2704
		case 41: goto tr2705
		case 59: goto tr2707
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2706 }
	goto st0
tr2703:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1765
tr2732:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1765
st1765:
	p++
	if p == pe { goto _test_eof1765 }
	fallthrough
case 1765:
// line 54220 "zparse.go"
	switch data[p] {
		case 9: goto st840
		case 10: goto tr2703
		case 32: goto st840
		case 40: goto tr2704
		case 41: goto tr2705
		case 59: goto tr2707
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5443
	}
	goto st0
tr5443:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st841
st841:
	p++
	if p == pe { goto _test_eof841 }
	fallthrough
case 841:
// line 54272 "zparse.go"
	switch data[p] {
		case 9: goto tr2708
		case 10: goto tr2709
		case 32: goto tr2708
		case 40: goto tr2710
		case 41: goto tr2711
		case 59: goto tr2713
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st841
	}
	goto st0
tr2716:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st842
tr2717:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st842
tr2715:
// line 101 "zparse.rl"
	{ lines++ }
	goto st842
tr2708:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st842
tr2709:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st842
tr2710:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st842
tr2711:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st842
tr2744:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st842
tr2745:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st842
tr2746:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st842
tr2747:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st842
st842:
	p++
	if p == pe { goto _test_eof842 }
	fallthrough
case 842:
// line 54380 "zparse.go"
	switch data[p] {
		case 9: goto st842
		case 10: goto tr2715
		case 32: goto st842
		case 40: goto tr2716
		case 41: goto tr2717
		case 59: goto st846
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2718 }
	goto st0
tr2718:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st843
st843:
	p++
	if p == pe { goto _test_eof843 }
	fallthrough
case 843:
// line 54420 "zparse.go"
	switch data[p] {
		case 9: goto tr2720
		case 10: goto tr2721
		case 32: goto tr2720
		case 40: goto tr2722
		case 41: goto tr2723
		case 59: goto tr2725
	}
	if 48 <= data[p] && data[p] <= 57 { goto st843 }
	goto st0
tr2728:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st844
tr2729:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st844
tr2727:
// line 101 "zparse.rl"
	{ lines++ }
	goto st844
tr2720:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st844
tr2721:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st844
tr2722:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st844
tr2723:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st844
st844:
	p++
	if p == pe { goto _test_eof844 }
	fallthrough
case 844:
// line 54478 "zparse.go"
	switch data[p] {
		case 9: goto st844
		case 10: goto tr2727
		case 32: goto st844
		case 40: goto tr2728
		case 41: goto tr2729
		case 59: goto st845
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1311 }
	goto st0
tr2725:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st845
st845:
	p++
	if p == pe { goto _test_eof845 }
	fallthrough
case 845:
// line 54518 "zparse.go"
	if data[p] == 10 { goto tr2727 }
	goto st845
tr2713:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st846
tr2749:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st846
st846:
	p++
	if p == pe { goto _test_eof846 }
	fallthrough
case 846:
// line 54540 "zparse.go"
	if data[p] == 10 { goto tr2715 }
	goto st846
tr2707:
// line 89 "zparse.rl"
	{ mark = p }
	goto st847
st847:
	p++
	if p == pe { goto _test_eof847 }
	fallthrough
case 847:
// line 54552 "zparse.go"
	if data[p] == 10 { goto tr2732 }
	goto st847
tr2706:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st848
st848:
	p++
	if p == pe { goto _test_eof848 }
	fallthrough
case 848:
// line 54566 "zparse.go"
	switch data[p] {
		case 9: goto tr2733
		case 10: goto tr2734
		case 32: goto tr2733
		case 40: goto tr2735
		case 41: goto tr2736
		case 59: goto tr2738
	}
	if 48 <= data[p] && data[p] <= 57 { goto st848 }
	goto st0
tr2741:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st849
tr2742:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st849
tr2740:
// line 101 "zparse.rl"
	{ lines++ }
	goto st849
tr2733:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st849
tr2734:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st849
tr2735:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st849
tr2736:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st849
st849:
	p++
	if p == pe { goto _test_eof849 }
	fallthrough
case 849:
// line 54624 "zparse.go"
	switch data[p] {
		case 9: goto st849
		case 10: goto tr2740
		case 32: goto st849
		case 40: goto tr2741
		case 41: goto tr2742
		case 59: goto st850
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1299 }
	goto st0
tr2738:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st850
st850:
	p++
	if p == pe { goto _test_eof850 }
	fallthrough
case 850:
// line 54664 "zparse.go"
	if data[p] == 10 { goto tr2740 }
	goto st850
tr5442:
// line 89 "zparse.rl"
	{ mark = p }
	goto st851
st851:
	p++
	if p == pe { goto _test_eof851 }
	fallthrough
case 851:
// line 54676 "zparse.go"
	switch data[p] {
		case 9: goto tr2744
		case 10: goto tr2745
		case 32: goto tr2744
		case 40: goto tr2746
		case 41: goto tr2747
		case 59: goto tr2749
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st851
	}
	goto st0
tr2701:
// line 89 "zparse.rl"
	{ mark = p }
	goto st852
tr3408:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st852
tr2696:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st852
tr5254:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st852
tr3153:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st852
st852:
	p++
	if p == pe { goto _test_eof852 }
	fallthrough
case 852:
// line 54800 "zparse.go"
	if data[p] == 10 { goto tr2751 }
	goto st852
st853:
	p++
	if p == pe { goto _test_eof853 }
	fallthrough
case 853:
	switch data[p] {
		case 9: goto tr2752
		case 10: goto tr2753
		case 32: goto tr2752
		case 40: goto tr2754
		case 41: goto tr2755
		case 43: goto st616
		case 59: goto tr2756
		case 61: goto st616
		case 92: goto st616
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
tr2759:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st854
tr2760:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st854
tr3409:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st854
tr2752:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st854
tr5255:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st854
tr3154:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st854
tr2754:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st854
tr2755:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st854
tr3156:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st854
tr3157:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st854
tr3411:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st854
tr3412:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st854
tr5257:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st854
tr5258:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st854
st854:
	p++
	if p == pe { goto _test_eof854 }
	fallthrough
case 854:
// line 55132 "zparse.go"
	switch data[p] {
		case 9: goto st854
		case 10: goto tr2758
		case 32: goto st854
		case 40: goto tr2759
		case 41: goto tr2760
		case 59: goto tr2761
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1373 }
	goto st0
tr2758:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1766
tr2811:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1766
tr2753:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1766
tr3155:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1766
tr3410:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1766
tr5256:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1766
st1766:
	p++
	if p == pe { goto _test_eof1766 }
	fallthrough
case 1766:
// line 55258 "zparse.go"
	switch data[p] {
		case 9: goto st855
		case 10: goto tr2763
		case 32: goto st855
		case 40: goto tr2764
		case 41: goto tr2765
		case 59: goto tr2767
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5444
	}
	goto st0
tr2764:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st855
tr2765:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st855
st855:
	p++
	if p == pe { goto _test_eof855 }
	fallthrough
case 855:
// line 55294 "zparse.go"
	switch data[p] {
		case 9: goto st855
		case 10: goto tr2763
		case 32: goto st855
		case 40: goto tr2764
		case 41: goto tr2765
		case 59: goto tr2767
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2766 }
	goto st0
tr2763:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1767
tr2792:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1767
st1767:
	p++
	if p == pe { goto _test_eof1767 }
	fallthrough
case 1767:
// line 55338 "zparse.go"
	switch data[p] {
		case 9: goto st855
		case 10: goto tr2763
		case 32: goto st855
		case 40: goto tr2764
		case 41: goto tr2765
		case 59: goto tr2767
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5445
	}
	goto st0
tr5445:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st856
st856:
	p++
	if p == pe { goto _test_eof856 }
	fallthrough
case 856:
// line 55390 "zparse.go"
	switch data[p] {
		case 9: goto tr2768
		case 10: goto tr2769
		case 32: goto tr2768
		case 40: goto tr2770
		case 41: goto tr2771
		case 59: goto tr2773
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st856
	}
	goto st0
tr2776:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st857
tr2777:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st857
tr2775:
// line 101 "zparse.rl"
	{ lines++ }
	goto st857
tr2768:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st857
tr2769:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st857
tr2770:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st857
tr2771:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st857
tr2804:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st857
tr2805:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st857
tr2806:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st857
tr2807:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st857
st857:
	p++
	if p == pe { goto _test_eof857 }
	fallthrough
case 857:
// line 55498 "zparse.go"
	switch data[p] {
		case 9: goto st857
		case 10: goto tr2775
		case 32: goto st857
		case 40: goto tr2776
		case 41: goto tr2777
		case 59: goto st861
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2778 }
	goto st0
tr2778:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st858
st858:
	p++
	if p == pe { goto _test_eof858 }
	fallthrough
case 858:
// line 55538 "zparse.go"
	switch data[p] {
		case 9: goto tr2780
		case 10: goto tr2781
		case 32: goto tr2780
		case 40: goto tr2782
		case 41: goto tr2783
		case 59: goto tr2785
	}
	if 48 <= data[p] && data[p] <= 57 { goto st858 }
	goto st0
tr2788:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st859
tr2789:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st859
tr2787:
// line 101 "zparse.rl"
	{ lines++ }
	goto st859
tr2780:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st859
tr2781:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st859
tr2782:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st859
tr2783:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st859
st859:
	p++
	if p == pe { goto _test_eof859 }
	fallthrough
case 859:
// line 55596 "zparse.go"
	switch data[p] {
		case 9: goto st859
		case 10: goto tr2787
		case 32: goto st859
		case 40: goto tr2788
		case 41: goto tr2789
		case 59: goto st860
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1397 }
	goto st0
tr2785:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st860
st860:
	p++
	if p == pe { goto _test_eof860 }
	fallthrough
case 860:
// line 55636 "zparse.go"
	if data[p] == 10 { goto tr2787 }
	goto st860
tr2773:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st861
tr2809:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st861
st861:
	p++
	if p == pe { goto _test_eof861 }
	fallthrough
case 861:
// line 55658 "zparse.go"
	if data[p] == 10 { goto tr2775 }
	goto st861
tr2767:
// line 89 "zparse.rl"
	{ mark = p }
	goto st862
st862:
	p++
	if p == pe { goto _test_eof862 }
	fallthrough
case 862:
// line 55670 "zparse.go"
	if data[p] == 10 { goto tr2792 }
	goto st862
tr2766:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st863
st863:
	p++
	if p == pe { goto _test_eof863 }
	fallthrough
case 863:
// line 55684 "zparse.go"
	switch data[p] {
		case 9: goto tr2793
		case 10: goto tr2794
		case 32: goto tr2793
		case 40: goto tr2795
		case 41: goto tr2796
		case 59: goto tr2798
	}
	if 48 <= data[p] && data[p] <= 57 { goto st863 }
	goto st0
tr2801:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st864
tr2802:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st864
tr2800:
// line 101 "zparse.rl"
	{ lines++ }
	goto st864
tr2793:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st864
tr2794:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st864
tr2795:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st864
tr2796:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st864
st864:
	p++
	if p == pe { goto _test_eof864 }
	fallthrough
case 864:
// line 55742 "zparse.go"
	switch data[p] {
		case 9: goto st864
		case 10: goto tr2800
		case 32: goto st864
		case 40: goto tr2801
		case 41: goto tr2802
		case 59: goto st865
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1385 }
	goto st0
tr2798:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st865
st865:
	p++
	if p == pe { goto _test_eof865 }
	fallthrough
case 865:
// line 55782 "zparse.go"
	if data[p] == 10 { goto tr2800 }
	goto st865
tr5444:
// line 89 "zparse.rl"
	{ mark = p }
	goto st866
st866:
	p++
	if p == pe { goto _test_eof866 }
	fallthrough
case 866:
// line 55794 "zparse.go"
	switch data[p] {
		case 9: goto tr2804
		case 10: goto tr2805
		case 32: goto tr2804
		case 40: goto tr2806
		case 41: goto tr2807
		case 59: goto tr2809
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st866
	}
	goto st0
tr2761:
// line 89 "zparse.rl"
	{ mark = p }
	goto st867
tr3413:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st867
tr2756:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st867
tr5259:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st867
tr3158:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st867
st867:
	p++
	if p == pe { goto _test_eof867 }
	fallthrough
case 867:
// line 55918 "zparse.go"
	if data[p] == 10 { goto tr2811 }
	goto st867
tr2126:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st868
st868:
	p++
	if p == pe { goto _test_eof868 }
	fallthrough
case 868:
// line 55932 "zparse.go"
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 83: goto st773
		case 92: goto st616
		case 115: goto st773
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
tr2127:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st869
st869:
	p++
	if p == pe { goto _test_eof869 }
	fallthrough
case 869:
// line 55965 "zparse.go"
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 78: goto st773
		case 92: goto st616
		case 110: goto st773
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
tr2128:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st870
st870:
	p++
	if p == pe { goto _test_eof870 }
	fallthrough
case 870:
// line 55998 "zparse.go"
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 88: goto st871
		case 92: goto st616
		case 120: goto st871
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st871:
	p++
	if p == pe { goto _test_eof871 }
	fallthrough
case 871:
	switch data[p] {
		case 9: goto tr2813
		case 10: goto tr2814
		case 32: goto tr2813
		case 40: goto tr2815
		case 41: goto tr2816
		case 43: goto st616
		case 59: goto tr2817
		case 61: goto st616
		case 92: goto st616
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
tr2820:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st872
tr2821:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st872
tr3415:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st872
tr2813:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st872
tr5261:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st872
tr3160:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st872
tr2815:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st872
tr2816:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st872
tr3162:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st872
tr3163:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st872
tr3417:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st872
tr3418:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st872
tr5263:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st872
tr5264:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st872
st872:
	p++
	if p == pe { goto _test_eof872 }
	fallthrough
case 872:
// line 56349 "zparse.go"
	switch data[p] {
		case 9: goto st872
		case 10: goto tr2819
		case 32: goto st872
		case 40: goto tr2820
		case 41: goto tr2821
		case 59: goto tr2822
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1427 }
	goto st0
tr2819:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1768
tr2892:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1768
tr2814:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1768
tr3161:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1768
tr3416:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1768
tr5262:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1768
st1768:
	p++
	if p == pe { goto _test_eof1768 }
	fallthrough
case 1768:
// line 56475 "zparse.go"
	switch data[p] {
		case 9: goto st873
		case 10: goto tr2824
		case 32: goto st873
		case 40: goto tr2825
		case 41: goto tr2826
		case 59: goto tr2828
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5446
	}
	goto st0
tr2825:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st873
tr2826:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st873
st873:
	p++
	if p == pe { goto _test_eof873 }
	fallthrough
case 873:
// line 56511 "zparse.go"
	switch data[p] {
		case 9: goto st873
		case 10: goto tr2824
		case 32: goto st873
		case 40: goto tr2825
		case 41: goto tr2826
		case 59: goto tr2828
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2827 }
	goto st0
tr2824:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1769
tr2871:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1769
st1769:
	p++
	if p == pe { goto _test_eof1769 }
	fallthrough
case 1769:
// line 56555 "zparse.go"
	switch data[p] {
		case 9: goto st873
		case 10: goto tr2824
		case 32: goto st873
		case 40: goto tr2825
		case 41: goto tr2826
		case 59: goto tr2828
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5447
	}
	goto st0
tr5447:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st874
st874:
	p++
	if p == pe { goto _test_eof874 }
	fallthrough
case 874:
// line 56607 "zparse.go"
	switch data[p] {
		case 9: goto tr2829
		case 10: goto tr2830
		case 32: goto tr2829
		case 40: goto tr2831
		case 41: goto tr2832
		case 59: goto tr2834
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st874
	}
	goto st0
tr2837:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st875
tr2838:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st875
tr2836:
// line 101 "zparse.rl"
	{ lines++ }
	goto st875
tr2829:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st875
tr2830:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st875
tr2831:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st875
tr2832:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st875
tr2885:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st875
tr2886:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st875
tr2887:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st875
tr2888:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st875
st875:
	p++
	if p == pe { goto _test_eof875 }
	fallthrough
case 875:
// line 56715 "zparse.go"
	switch data[p] {
		case 9: goto st875
		case 10: goto tr2836
		case 32: goto st875
		case 40: goto tr2837
		case 41: goto tr2838
		case 43: goto tr263
		case 58: goto tr263
		case 59: goto st879
		case 61: goto tr263
		case 65: goto tr1746
		case 67: goto tr1747
		case 68: goto tr1748
		case 72: goto tr1749
		case 73: goto tr1750
		case 77: goto tr1751
		case 78: goto tr1752
		case 82: goto tr1753
		case 83: goto tr1754
		case 92: goto tr263
		case 97: goto tr1746
		case 99: goto tr1747
		case 100: goto tr1748
		case 104: goto tr1749
		case 105: goto tr1750
		case 109: goto tr1751
		case 110: goto tr1752
		case 114: goto tr1753
		case 115: goto tr1754
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr263 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr263 }
		} else if data[p] >= 66 {
			goto tr263
		}
	} else {
		goto tr2839
	}
	goto st0
tr2839:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st876
st876:
	p++
	if p == pe { goto _test_eof876 }
	fallthrough
case 876:
// line 56769 "zparse.go"
	switch data[p] {
		case 9: goto tr2841
		case 10: goto tr2842
		case 32: goto tr2841
		case 40: goto tr2843
		case 41: goto tr2844
		case 43: goto st69
		case 58: goto st69
		case 59: goto tr2846
		case 61: goto st69
		case 92: goto st69
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st69 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st69 }
		} else if data[p] >= 65 {
			goto st69
		}
	} else {
		goto st876
	}
	goto st0
tr2849:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st877
tr2850:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st877
tr2841:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st877
tr2843:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st877
tr2844:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st877
st877:
	p++
	if p == pe { goto _test_eof877 }
	fallthrough
case 877:
// line 56862 "zparse.go"
	switch data[p] {
		case 9: goto st877
		case 10: goto tr2848
		case 32: goto st877
		case 40: goto tr2849
		case 41: goto tr2850
		case 59: goto tr2851
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr465 }
	goto st0
tr2848:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1770
tr2853:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1770
tr2842:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1770
st1770:
	p++
	if p == pe { goto _test_eof1770 }
	fallthrough
case 1770:
// line 56925 "zparse.go"
	switch data[p] {
		case 9: goto st413
		case 10: goto tr1453
		case 32: goto st413
		case 40: goto tr1454
		case 41: goto tr1455
		case 59: goto tr1456
		case 65: goto tr5347
		case 67: goto tr5348
		case 68: goto tr5349
		case 72: goto tr5350
		case 73: goto tr5351
		case 77: goto tr5352
		case 78: goto tr5353
		case 82: goto tr5354
		case 83: goto tr5355
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5347
		case 99: goto tr5348
		case 100: goto tr5349
		case 104: goto tr5350
		case 105: goto tr5351
		case 109: goto tr5352
		case 110: goto tr5353
		case 114: goto tr5354
		case 115: goto tr5355
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5401
	}
	goto st0
tr2851:
// line 89 "zparse.rl"
	{ mark = p }
	goto st878
tr2846:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st878
st878:
	p++
	if p == pe { goto _test_eof878 }
	fallthrough
case 878:
// line 56992 "zparse.go"
	if data[p] == 10 { goto tr2853 }
	goto st878
tr2834:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st879
tr2890:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st879
st879:
	p++
	if p == pe { goto _test_eof879 }
	fallthrough
case 879:
// line 57014 "zparse.go"
	if data[p] == 10 { goto tr2836 }
	goto st879
tr1753:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st880
tr869:
// line 89 "zparse.rl"
	{ mark = p }
	goto st880
st880:
	p++
	if p == pe { goto _test_eof880 }
	fallthrough
case 880:
// line 57032 "zparse.go"
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 82: goto st881
		case 92: goto st69
		case 114: goto st881
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st881:
	p++
	if p == pe { goto _test_eof881 }
	fallthrough
case 881:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 83: goto st882
		case 92: goto st69
		case 115: goto st882
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st882:
	p++
	if p == pe { goto _test_eof882 }
	fallthrough
case 882:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 73: goto st883
		case 92: goto st69
		case 105: goto st883
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st883:
	p++
	if p == pe { goto _test_eof883 }
	fallthrough
case 883:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 71: goto st884
		case 92: goto st69
		case 103: goto st884
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st884:
	p++
	if p == pe { goto _test_eof884 }
	fallthrough
case 884:
	switch data[p] {
		case 9: goto tr2858
		case 10: goto tr2859
		case 32: goto tr2858
		case 40: goto tr2860
		case 41: goto tr2861
		case 43: goto st69
		case 59: goto tr2862
		case 61: goto st69
		case 92: goto st69
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr1754:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st885
tr870:
// line 89 "zparse.rl"
	{ mark = p }
	goto st885
st885:
	p++
	if p == pe { goto _test_eof885 }
	fallthrough
case 885:
// line 57171 "zparse.go"
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 79: goto st886
		case 92: goto st69
		case 111: goto st886
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st886:
	p++
	if p == pe { goto _test_eof886 }
	fallthrough
case 886:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 65: goto st887
		case 92: goto st69
		case 97: goto st887
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st887:
	p++
	if p == pe { goto _test_eof887 }
	fallthrough
case 887:
	switch data[p] {
		case 9: goto tr2865
		case 10: goto tr2866
		case 32: goto tr2865
		case 40: goto tr2867
		case 41: goto tr2868
		case 43: goto st69
		case 59: goto tr2869
		case 61: goto st69
		case 92: goto st69
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr2828:
// line 89 "zparse.rl"
	{ mark = p }
	goto st888
st888:
	p++
	if p == pe { goto _test_eof888 }
	fallthrough
case 888:
// line 57252 "zparse.go"
	if data[p] == 10 { goto tr2871 }
	goto st888
tr2827:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st889
st889:
	p++
	if p == pe { goto _test_eof889 }
	fallthrough
case 889:
// line 57266 "zparse.go"
	switch data[p] {
		case 9: goto tr2872
		case 10: goto tr2873
		case 32: goto tr2872
		case 40: goto tr2874
		case 41: goto tr2875
		case 59: goto tr2877
	}
	if 48 <= data[p] && data[p] <= 57 { goto st889 }
	goto st0
tr2880:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st890
tr2881:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st890
tr2879:
// line 101 "zparse.rl"
	{ lines++ }
	goto st890
tr2872:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st890
tr2873:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st890
tr2874:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st890
tr2875:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st890
st890:
	p++
	if p == pe { goto _test_eof890 }
	fallthrough
case 890:
// line 57324 "zparse.go"
	switch data[p] {
		case 9: goto st890
		case 10: goto tr2879
		case 32: goto st890
		case 40: goto tr2880
		case 41: goto tr2881
		case 43: goto tr263
		case 58: goto tr263
		case 59: goto st891
		case 61: goto tr263
		case 65: goto tr862
		case 67: goto tr863
		case 68: goto tr864
		case 72: goto tr865
		case 73: goto tr866
		case 77: goto tr867
		case 78: goto tr868
		case 82: goto tr869
		case 83: goto tr870
		case 92: goto tr263
		case 97: goto tr862
		case 99: goto tr863
		case 100: goto tr864
		case 104: goto tr865
		case 105: goto tr866
		case 109: goto tr867
		case 110: goto tr868
		case 114: goto tr869
		case 115: goto tr870
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr263 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr263 }
		} else if data[p] >= 66 {
			goto tr263
		}
	} else {
		goto tr1439
	}
	goto st0
tr2877:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st891
st891:
	p++
	if p == pe { goto _test_eof891 }
	fallthrough
case 891:
// line 57378 "zparse.go"
	if data[p] == 10 { goto tr2879 }
	goto st891
tr863:
// line 89 "zparse.rl"
	{ mark = p }
	goto st892
st892:
	p++
	if p == pe { goto _test_eof892 }
	fallthrough
case 892:
// line 57390 "zparse.go"
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 72: goto st254
		case 78: goto st497
		case 83: goto st254
		case 92: goto st69
		case 104: goto st254
		case 110: goto st497
		case 115: goto st254
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr865:
// line 89 "zparse.rl"
	{ mark = p }
	goto st893
st893:
	p++
	if p == pe { goto _test_eof893 }
	fallthrough
case 893:
// line 57425 "zparse.go"
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 83: goto st254
		case 92: goto st69
		case 115: goto st254
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr866:
// line 89 "zparse.rl"
	{ mark = p }
	goto st894
st894:
	p++
	if p == pe { goto _test_eof894 }
	fallthrough
case 894:
// line 57456 "zparse.go"
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 78: goto st254
		case 92: goto st69
		case 110: goto st254
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr868:
// line 89 "zparse.rl"
	{ mark = p }
	goto st895
st895:
	p++
	if p == pe { goto _test_eof895 }
	fallthrough
case 895:
// line 57487 "zparse.go"
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 79: goto st896
		case 83: goto st516
		case 92: goto st69
		case 111: goto st896
		case 115: goto st516
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st896:
	p++
	if p == pe { goto _test_eof896 }
	fallthrough
case 896:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 78: goto st897
		case 92: goto st69
		case 110: goto st897
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
st897:
	p++
	if p == pe { goto _test_eof897 }
	fallthrough
case 897:
	switch data[p] {
		case 9: goto tr265
		case 10: goto tr266
		case 32: goto tr265
		case 40: goto tr267
		case 41: goto tr268
		case 43: goto st69
		case 59: goto tr270
		case 61: goto st69
		case 69: goto st254
		case 92: goto st69
		case 101: goto st254
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st69 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st69 }
	} else {
		goto st69
	}
	goto st0
tr5446:
// line 89 "zparse.rl"
	{ mark = p }
	goto st898
st898:
	p++
	if p == pe { goto _test_eof898 }
	fallthrough
case 898:
// line 57572 "zparse.go"
	switch data[p] {
		case 9: goto tr2885
		case 10: goto tr2886
		case 32: goto tr2885
		case 40: goto tr2887
		case 41: goto tr2888
		case 59: goto tr2890
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st898
	}
	goto st0
tr2822:
// line 89 "zparse.rl"
	{ mark = p }
	goto st899
tr3419:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st899
tr2817:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st899
tr5265:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st899
tr3164:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st899
st899:
	p++
	if p == pe { goto _test_eof899 }
	fallthrough
case 899:
// line 57696 "zparse.go"
	if data[p] == 10 { goto tr2892 }
	goto st899
tr2129:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st900
st900:
	p++
	if p == pe { goto _test_eof900 }
	fallthrough
case 900:
// line 57710 "zparse.go"
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 79: goto st901
		case 83: goto st903
		case 92: goto st616
		case 111: goto st901
		case 115: goto st903
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st901:
	p++
	if p == pe { goto _test_eof901 }
	fallthrough
case 901:
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 78: goto st902
		case 92: goto st616
		case 110: goto st902
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st902:
	p++
	if p == pe { goto _test_eof902 }
	fallthrough
case 902:
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 69: goto st773
		case 92: goto st616
		case 101: goto st773
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st903:
	p++
	if p == pe { goto _test_eof903 }
	fallthrough
case 903:
	switch data[p] {
		case 9: goto tr2896
		case 10: goto tr2897
		case 32: goto tr2896
		case 40: goto tr2898
		case 41: goto tr2899
		case 43: goto st616
		case 59: goto tr2900
		case 61: goto st616
		case 92: goto st616
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
tr2903:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st904
tr2904:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st904
tr3168:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st904
tr3170:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st904
tr3171:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st904
tr3423:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st904
tr3425:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st904
tr3426:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st904
tr2896:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st904
tr2898:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st904
tr2899:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st904
tr5269:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st904
tr5271:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st904
tr5272:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st904
st904:
	p++
	if p == pe { goto _test_eof904 }
	fallthrough
case 904:
// line 58115 "zparse.go"
	switch data[p] {
		case 9: goto st904
		case 10: goto tr2902
		case 32: goto st904
		case 40: goto tr2903
		case 41: goto tr2904
		case 43: goto tr281
		case 58: goto tr281
		case 59: goto tr2905
		case 61: goto tr281
		case 92: goto tr281
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr281 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr281 }
		} else if data[p] >= 65 {
			goto tr281
		}
	} else {
		goto tr1502
	}
	goto st0
tr2902:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1771
tr2963:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1771
tr3169:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1771
tr3424:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1771
tr2897:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1771
tr5270:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1771
st1771:
	p++
	if p == pe { goto _test_eof1771 }
	fallthrough
case 1771:
// line 58255 "zparse.go"
	switch data[p] {
		case 9: goto st905
		case 10: goto tr2907
		case 32: goto st905
		case 40: goto tr2908
		case 41: goto tr2909
		case 43: goto tr281
		case 47: goto tr281
		case 58: goto tr281
		case 59: goto tr2911
		case 61: goto tr281
		case 92: goto tr5407
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5407 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr5407 }
		} else if data[p] >= 65 {
			goto tr5407
		}
	} else {
		goto tr5448
	}
	goto st0
tr2908:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st905
tr2909:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st905
st905:
	p++
	if p == pe { goto _test_eof905 }
	fallthrough
case 905:
// line 58295 "zparse.go"
	switch data[p] {
		case 9: goto st905
		case 10: goto tr2907
		case 32: goto st905
		case 40: goto tr2908
		case 41: goto tr2909
		case 43: goto tr281
		case 58: goto tr281
		case 59: goto tr2911
		case 61: goto tr281
		case 65: goto tr960
		case 67: goto tr961
		case 68: goto tr962
		case 72: goto tr963
		case 73: goto tr964
		case 77: goto tr965
		case 78: goto tr966
		case 82: goto tr967
		case 83: goto tr968
		case 92: goto tr281
		case 97: goto tr960
		case 99: goto tr961
		case 100: goto tr962
		case 104: goto tr963
		case 105: goto tr964
		case 109: goto tr965
		case 110: goto tr966
		case 114: goto tr967
		case 115: goto tr968
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr281 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr281 }
		} else if data[p] >= 66 {
			goto tr281
		}
	} else {
		goto tr2910
	}
	goto st0
tr2907:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1772
tr2919:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1772
st1772:
	p++
	if p == pe { goto _test_eof1772 }
	fallthrough
case 1772:
// line 58353 "zparse.go"
	switch data[p] {
		case 9: goto st905
		case 10: goto tr2907
		case 32: goto st905
		case 40: goto tr2908
		case 41: goto tr2909
		case 43: goto tr281
		case 47: goto tr281
		case 58: goto tr281
		case 59: goto tr2911
		case 61: goto tr281
		case 65: goto tr5409
		case 67: goto tr5410
		case 68: goto tr5411
		case 72: goto tr5412
		case 73: goto tr5413
		case 77: goto tr5414
		case 78: goto tr5415
		case 82: goto tr5416
		case 83: goto tr5417
		case 92: goto tr5407
		case 95: goto st2
		case 97: goto tr5409
		case 99: goto tr5410
		case 100: goto tr5411
		case 104: goto tr5412
		case 105: goto tr5413
		case 109: goto tr5414
		case 110: goto tr5415
		case 114: goto tr5416
		case 115: goto tr5417
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5407 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr5407 }
		} else if data[p] >= 66 {
			goto tr5407
		}
	} else {
		goto tr5449
	}
	goto st0
tr5449:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st906
st906:
	p++
	if p == pe { goto _test_eof906 }
	fallthrough
case 906:
// line 58409 "zparse.go"
	switch data[p] {
		case 9: goto tr2912
		case 10: goto tr2913
		case 32: goto tr2912
		case 40: goto tr2914
		case 41: goto tr2915
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr2917
		case 61: goto st75
		case 92: goto st519
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st519 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st519 }
		} else if data[p] >= 65 {
			goto st519
		}
	} else {
		goto st906
	}
	goto st0
tr2911:
// line 89 "zparse.rl"
	{ mark = p }
	goto st907
st907:
	p++
	if p == pe { goto _test_eof907 }
	fallthrough
case 907:
// line 58445 "zparse.go"
	if data[p] == 10 { goto tr2919 }
	goto st907
tr2910:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st908
st908:
	p++
	if p == pe { goto _test_eof908 }
	fallthrough
case 908:
// line 58459 "zparse.go"
	switch data[p] {
		case 9: goto tr2920
		case 10: goto tr2921
		case 32: goto tr2920
		case 40: goto tr2922
		case 41: goto tr2923
		case 43: goto st75
		case 58: goto st75
		case 59: goto tr2925
		case 61: goto st75
		case 92: goto st75
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st75 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st75 }
		} else if data[p] >= 65 {
			goto st75
		}
	} else {
		goto st908
	}
	goto st0
tr963:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st909
st909:
	p++
	if p == pe { goto _test_eof909 }
	fallthrough
case 909:
// line 58495 "zparse.go"
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 83: goto st282
		case 92: goto st75
		case 115: goto st282
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
tr964:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st910
st910:
	p++
	if p == pe { goto _test_eof910 }
	fallthrough
case 910:
// line 58528 "zparse.go"
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 78: goto st282
		case 92: goto st75
		case 110: goto st282
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
tr965:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st911
st911:
	p++
	if p == pe { goto _test_eof911 }
	fallthrough
case 911:
// line 58561 "zparse.go"
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 88: goto st912
		case 92: goto st75
		case 120: goto st912
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st912:
	p++
	if p == pe { goto _test_eof912 }
	fallthrough
case 912:
	switch data[p] {
		case 9: goto tr2927
		case 10: goto tr2928
		case 32: goto tr2927
		case 40: goto tr2929
		case 41: goto tr2930
		case 43: goto st75
		case 59: goto tr2931
		case 61: goto st75
		case 92: goto st75
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
tr966:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st913
st913:
	p++
	if p == pe { goto _test_eof913 }
	fallthrough
case 913:
// line 58618 "zparse.go"
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 79: goto st914
		case 83: goto st916
		case 92: goto st75
		case 111: goto st914
		case 115: goto st916
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st914:
	p++
	if p == pe { goto _test_eof914 }
	fallthrough
case 914:
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 78: goto st915
		case 92: goto st75
		case 110: goto st915
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st915:
	p++
	if p == pe { goto _test_eof915 }
	fallthrough
case 915:
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 69: goto st282
		case 92: goto st75
		case 101: goto st282
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st916:
	p++
	if p == pe { goto _test_eof916 }
	fallthrough
case 916:
	switch data[p] {
		case 9: goto tr2935
		case 10: goto tr2936
		case 32: goto tr2935
		case 40: goto tr2937
		case 41: goto tr2938
		case 43: goto st75
		case 59: goto tr2939
		case 61: goto st75
		case 92: goto st75
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
tr967:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st917
st917:
	p++
	if p == pe { goto _test_eof917 }
	fallthrough
case 917:
// line 58729 "zparse.go"
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 82: goto st918
		case 92: goto st75
		case 114: goto st918
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st918:
	p++
	if p == pe { goto _test_eof918 }
	fallthrough
case 918:
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 83: goto st919
		case 92: goto st75
		case 115: goto st919
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st919:
	p++
	if p == pe { goto _test_eof919 }
	fallthrough
case 919:
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 73: goto st920
		case 92: goto st75
		case 105: goto st920
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st920:
	p++
	if p == pe { goto _test_eof920 }
	fallthrough
case 920:
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 71: goto st921
		case 92: goto st75
		case 103: goto st921
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st921:
	p++
	if p == pe { goto _test_eof921 }
	fallthrough
case 921:
	switch data[p] {
		case 9: goto tr2944
		case 10: goto tr2945
		case 32: goto tr2944
		case 40: goto tr2946
		case 41: goto tr2947
		case 43: goto st75
		case 59: goto tr2948
		case 61: goto st75
		case 92: goto st75
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
tr968:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st922
st922:
	p++
	if p == pe { goto _test_eof922 }
	fallthrough
case 922:
// line 58864 "zparse.go"
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 79: goto st923
		case 92: goto st75
		case 111: goto st923
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st923:
	p++
	if p == pe { goto _test_eof923 }
	fallthrough
case 923:
	switch data[p] {
		case 9: goto tr283
		case 10: goto tr284
		case 32: goto tr283
		case 40: goto tr285
		case 41: goto tr286
		case 43: goto st75
		case 59: goto tr288
		case 61: goto st75
		case 65: goto st924
		case 92: goto st75
		case 97: goto st924
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
st924:
	p++
	if p == pe { goto _test_eof924 }
	fallthrough
case 924:
	switch data[p] {
		case 9: goto tr2951
		case 10: goto tr2952
		case 32: goto tr2951
		case 40: goto tr2953
		case 41: goto tr2954
		case 43: goto st75
		case 59: goto tr2955
		case 61: goto st75
		case 92: goto st75
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st75 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st75 }
	} else {
		goto st75
	}
	goto st0
tr5448:
// line 89 "zparse.rl"
	{ mark = p }
	goto st925
st925:
	p++
	if p == pe { goto _test_eof925 }
	fallthrough
case 925:
// line 58945 "zparse.go"
	switch data[p] {
		case 9: goto tr2956
		case 10: goto tr2957
		case 32: goto tr2956
		case 40: goto tr2958
		case 41: goto tr2959
		case 43: goto st75
		case 47: goto st75
		case 58: goto st75
		case 59: goto tr2961
		case 61: goto st75
		case 92: goto st519
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st519 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st519 }
		} else if data[p] >= 65 {
			goto st519
		}
	} else {
		goto st925
	}
	goto st0
tr2905:
// line 89 "zparse.rl"
	{ mark = p }
	goto st926
tr3172:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st926
tr3427:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st926
tr2900:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st926
tr5273:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st926
st926:
	p++
	if p == pe { goto _test_eof926 }
	fallthrough
case 926:
// line 59073 "zparse.go"
	if data[p] == 10 { goto tr2963 }
	goto st926
tr2130:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st927
st927:
	p++
	if p == pe { goto _test_eof927 }
	fallthrough
case 927:
// line 59087 "zparse.go"
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 82: goto st928
		case 92: goto st616
		case 114: goto st928
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st928:
	p++
	if p == pe { goto _test_eof928 }
	fallthrough
case 928:
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 83: goto st929
		case 92: goto st616
		case 115: goto st929
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st929:
	p++
	if p == pe { goto _test_eof929 }
	fallthrough
case 929:
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 73: goto st930
		case 92: goto st616
		case 105: goto st930
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st930:
	p++
	if p == pe { goto _test_eof930 }
	fallthrough
case 930:
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 71: goto st931
		case 92: goto st616
		case 103: goto st931
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st931:
	p++
	if p == pe { goto _test_eof931 }
	fallthrough
case 931:
	switch data[p] {
		case 9: goto tr2968
		case 10: goto tr2969
		case 32: goto tr2968
		case 40: goto tr2970
		case 41: goto tr2971
		case 43: goto st616
		case 59: goto tr2972
		case 61: goto st616
		case 92: goto st616
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
tr2975:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st932
tr2976:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st932
tr3432:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st932
tr2968:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st932
tr5278:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st932
tr3177:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st932
tr2970:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st932
tr2971:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st932
tr3179:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st932
tr3180:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st932
tr3434:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st932
tr3435:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st932
tr5280:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st932
tr5281:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st932
st932:
	p++
	if p == pe { goto _test_eof932 }
	fallthrough
case 932:
// line 59516 "zparse.go"
	switch data[p] {
		case 9: goto st932
		case 10: goto tr2974
		case 32: goto st932
		case 40: goto tr2975
		case 41: goto tr2976
		case 59: goto tr2977
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1523 }
	goto st0
tr2974:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1773
tr3027:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1773
tr2969:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1773
tr3178:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1773
tr3433:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1773
tr5279:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1773
st1773:
	p++
	if p == pe { goto _test_eof1773 }
	fallthrough
case 1773:
// line 59642 "zparse.go"
	switch data[p] {
		case 9: goto st933
		case 10: goto tr2979
		case 32: goto st933
		case 40: goto tr2980
		case 41: goto tr2981
		case 59: goto tr2983
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5450
	}
	goto st0
tr2980:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st933
tr2981:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st933
st933:
	p++
	if p == pe { goto _test_eof933 }
	fallthrough
case 933:
// line 59678 "zparse.go"
	switch data[p] {
		case 9: goto st933
		case 10: goto tr2979
		case 32: goto st933
		case 40: goto tr2980
		case 41: goto tr2981
		case 59: goto tr2983
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2982 }
	goto st0
tr2979:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1774
tr3008:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1774
st1774:
	p++
	if p == pe { goto _test_eof1774 }
	fallthrough
case 1774:
// line 59722 "zparse.go"
	switch data[p] {
		case 9: goto st933
		case 10: goto tr2979
		case 32: goto st933
		case 40: goto tr2980
		case 41: goto tr2981
		case 59: goto tr2983
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5451
	}
	goto st0
tr5451:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st934
st934:
	p++
	if p == pe { goto _test_eof934 }
	fallthrough
case 934:
// line 59774 "zparse.go"
	switch data[p] {
		case 9: goto tr2984
		case 10: goto tr2985
		case 32: goto tr2984
		case 40: goto tr2986
		case 41: goto tr2987
		case 59: goto tr2989
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st934
	}
	goto st0
tr2992:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st935
tr2993:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st935
tr2991:
// line 101 "zparse.rl"
	{ lines++ }
	goto st935
tr2984:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st935
tr2985:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st935
tr2986:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st935
tr2987:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st935
tr3020:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st935
tr3021:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st935
tr3022:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st935
tr3023:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st935
st935:
	p++
	if p == pe { goto _test_eof935 }
	fallthrough
case 935:
// line 59882 "zparse.go"
	switch data[p] {
		case 9: goto st935
		case 10: goto tr2991
		case 32: goto st935
		case 40: goto tr2992
		case 41: goto tr2993
		case 59: goto st939
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2994 }
	goto st0
tr2994:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st936
st936:
	p++
	if p == pe { goto _test_eof936 }
	fallthrough
case 936:
// line 59922 "zparse.go"
	switch data[p] {
		case 9: goto tr2996
		case 10: goto tr2997
		case 32: goto tr2996
		case 40: goto tr2998
		case 41: goto tr2999
		case 59: goto tr3001
	}
	if 48 <= data[p] && data[p] <= 57 { goto st936 }
	goto st0
tr3004:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st937
tr3005:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st937
tr3003:
// line 101 "zparse.rl"
	{ lines++ }
	goto st937
tr2996:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st937
tr2997:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st937
tr2998:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st937
tr2999:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st937
st937:
	p++
	if p == pe { goto _test_eof937 }
	fallthrough
case 937:
// line 59980 "zparse.go"
	switch data[p] {
		case 9: goto st937
		case 10: goto tr3003
		case 32: goto st937
		case 40: goto tr3004
		case 41: goto tr3005
		case 59: goto st938
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1547 }
	goto st0
tr3001:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st938
st938:
	p++
	if p == pe { goto _test_eof938 }
	fallthrough
case 938:
// line 60020 "zparse.go"
	if data[p] == 10 { goto tr3003 }
	goto st938
tr2989:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st939
tr3025:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st939
st939:
	p++
	if p == pe { goto _test_eof939 }
	fallthrough
case 939:
// line 60042 "zparse.go"
	if data[p] == 10 { goto tr2991 }
	goto st939
tr2983:
// line 89 "zparse.rl"
	{ mark = p }
	goto st940
st940:
	p++
	if p == pe { goto _test_eof940 }
	fallthrough
case 940:
// line 60054 "zparse.go"
	if data[p] == 10 { goto tr3008 }
	goto st940
tr2982:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st941
st941:
	p++
	if p == pe { goto _test_eof941 }
	fallthrough
case 941:
// line 60068 "zparse.go"
	switch data[p] {
		case 9: goto tr3009
		case 10: goto tr3010
		case 32: goto tr3009
		case 40: goto tr3011
		case 41: goto tr3012
		case 59: goto tr3014
	}
	if 48 <= data[p] && data[p] <= 57 { goto st941 }
	goto st0
tr3017:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st942
tr3018:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st942
tr3016:
// line 101 "zparse.rl"
	{ lines++ }
	goto st942
tr3009:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st942
tr3010:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st942
tr3011:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st942
tr3012:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st942
st942:
	p++
	if p == pe { goto _test_eof942 }
	fallthrough
case 942:
// line 60126 "zparse.go"
	switch data[p] {
		case 9: goto st942
		case 10: goto tr3016
		case 32: goto st942
		case 40: goto tr3017
		case 41: goto tr3018
		case 59: goto st943
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1535 }
	goto st0
tr3014:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st943
st943:
	p++
	if p == pe { goto _test_eof943 }
	fallthrough
case 943:
// line 60166 "zparse.go"
	if data[p] == 10 { goto tr3016 }
	goto st943
tr5450:
// line 89 "zparse.rl"
	{ mark = p }
	goto st944
st944:
	p++
	if p == pe { goto _test_eof944 }
	fallthrough
case 944:
// line 60178 "zparse.go"
	switch data[p] {
		case 9: goto tr3020
		case 10: goto tr3021
		case 32: goto tr3020
		case 40: goto tr3022
		case 41: goto tr3023
		case 59: goto tr3025
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st944
	}
	goto st0
tr2977:
// line 89 "zparse.rl"
	{ mark = p }
	goto st945
tr3436:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st945
tr2972:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st945
tr5282:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st945
tr3181:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st945
st945:
	p++
	if p == pe { goto _test_eof945 }
	fallthrough
case 945:
// line 60302 "zparse.go"
	if data[p] == 10 { goto tr3027 }
	goto st945
tr2131:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st946
st946:
	p++
	if p == pe { goto _test_eof946 }
	fallthrough
case 946:
// line 60316 "zparse.go"
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 79: goto st947
		case 92: goto st616
		case 111: goto st947
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st947:
	p++
	if p == pe { goto _test_eof947 }
	fallthrough
case 947:
	switch data[p] {
		case 9: goto tr2132
		case 10: goto tr2133
		case 32: goto tr2132
		case 40: goto tr2134
		case 41: goto tr2135
		case 43: goto st616
		case 59: goto tr2137
		case 61: goto st616
		case 65: goto st948
		case 92: goto st616
		case 97: goto st948
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
st948:
	p++
	if p == pe { goto _test_eof948 }
	fallthrough
case 948:
	switch data[p] {
		case 9: goto tr3030
		case 10: goto tr3031
		case 32: goto tr3030
		case 40: goto tr3032
		case 41: goto tr3033
		case 43: goto st616
		case 59: goto tr3034
		case 61: goto st616
		case 92: goto st616
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st616 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st616 }
	} else {
		goto st616
	}
	goto st0
tr3037:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st949
tr3038:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st949
tr3439:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st949
tr3441:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st949
tr3442:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st949
tr3030:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st949
tr3032:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st949
tr3033:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st949
tr5285:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st949
tr5287:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st949
tr5288:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st949
tr3184:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st949
tr3186:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st949
tr3187:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st949
st949:
	p++
	if p == pe { goto _test_eof949 }
	fallthrough
case 949:
// line 60693 "zparse.go"
	switch data[p] {
		case 9: goto st949
		case 10: goto tr3036
		case 32: goto st949
		case 40: goto tr3037
		case 41: goto tr3038
		case 43: goto tr417
		case 58: goto tr417
		case 59: goto tr3039
		case 61: goto tr417
		case 92: goto tr417
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr417 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr417 }
		} else if data[p] >= 65 {
			goto tr417
		}
	} else {
		goto tr2014
	}
	goto st0
tr3036:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1775
tr3190:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1775
tr3440:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1775
tr3031:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1775
tr5286:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1775
tr3185:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1775
st1775:
	p++
	if p == pe { goto _test_eof1775 }
	fallthrough
case 1775:
// line 60833 "zparse.go"
	switch data[p] {
		case 9: goto st950
		case 10: goto tr3041
		case 32: goto st950
		case 40: goto tr3042
		case 41: goto tr3043
		case 43: goto tr417
		case 47: goto tr417
		case 58: goto tr417
		case 59: goto tr3045
		case 61: goto tr417
		case 92: goto tr5419
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5419 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr5419 }
		} else if data[p] >= 65 {
			goto tr5419
		}
	} else {
		goto tr5452
	}
	goto st0
tr3042:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st950
tr3043:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st950
st950:
	p++
	if p == pe { goto _test_eof950 }
	fallthrough
case 950:
// line 60873 "zparse.go"
	switch data[p] {
		case 9: goto st950
		case 10: goto tr3041
		case 32: goto st950
		case 40: goto tr3042
		case 41: goto tr3043
		case 43: goto tr417
		case 58: goto tr417
		case 59: goto tr3045
		case 61: goto tr417
		case 65: goto tr1118
		case 67: goto tr1119
		case 68: goto tr1120
		case 72: goto tr1121
		case 73: goto tr1122
		case 77: goto tr1123
		case 78: goto tr1124
		case 82: goto tr1125
		case 83: goto tr1126
		case 92: goto tr417
		case 97: goto tr1118
		case 99: goto tr1119
		case 100: goto tr1120
		case 104: goto tr1121
		case 105: goto tr1122
		case 109: goto tr1123
		case 110: goto tr1124
		case 114: goto tr1125
		case 115: goto tr1126
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr417 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr417 }
		} else if data[p] >= 66 {
			goto tr417
		}
	} else {
		goto tr3044
	}
	goto st0
tr3041:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1776
tr3070:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1776
st1776:
	p++
	if p == pe { goto _test_eof1776 }
	fallthrough
case 1776:
// line 60931 "zparse.go"
	switch data[p] {
		case 9: goto st950
		case 10: goto tr3041
		case 32: goto st950
		case 40: goto tr3042
		case 41: goto tr3043
		case 43: goto tr417
		case 47: goto tr417
		case 58: goto tr417
		case 59: goto tr3045
		case 61: goto tr417
		case 65: goto tr5421
		case 67: goto tr5422
		case 68: goto tr5423
		case 72: goto tr5424
		case 73: goto tr5425
		case 77: goto tr5426
		case 78: goto tr5427
		case 82: goto tr5428
		case 83: goto tr5429
		case 92: goto tr5419
		case 95: goto st2
		case 97: goto tr5421
		case 99: goto tr5422
		case 100: goto tr5423
		case 104: goto tr5424
		case 105: goto tr5425
		case 109: goto tr5426
		case 110: goto tr5427
		case 114: goto tr5428
		case 115: goto tr5429
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5419 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr5419 }
		} else if data[p] >= 66 {
			goto tr5419
		}
	} else {
		goto tr5453
	}
	goto st0
tr5453:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st951
st951:
	p++
	if p == pe { goto _test_eof951 }
	fallthrough
case 951:
// line 60987 "zparse.go"
	switch data[p] {
		case 9: goto tr3046
		case 10: goto tr3047
		case 32: goto tr3046
		case 40: goto tr3048
		case 41: goto tr3049
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr3051
		case 61: goto st113
		case 92: goto st566
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st566 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st566 }
		} else if data[p] >= 65 {
			goto st566
		}
	} else {
		goto st951
	}
	goto st0
tr3054:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st952
tr3055:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st952
tr3053:
// line 101 "zparse.rl"
	{ lines++ }
	goto st952
tr3046:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st952
tr3047:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st952
tr3048:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st952
tr3049:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st952
tr5181:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st952
tr5182:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st952
tr5183:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st952
tr5184:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st952
st952:
	p++
	if p == pe { goto _test_eof952 }
	fallthrough
case 952:
// line 61115 "zparse.go"
	switch data[p] {
		case 9: goto st952
		case 10: goto tr3053
		case 32: goto st952
		case 40: goto tr3054
		case 41: goto tr3055
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st956
		case 61: goto tr429
		case 65: goto tr1957
		case 67: goto tr1958
		case 68: goto tr1959
		case 72: goto tr1960
		case 73: goto tr1961
		case 77: goto tr1962
		case 78: goto tr1963
		case 82: goto tr1964
		case 83: goto tr1965
		case 92: goto tr429
		case 97: goto tr1957
		case 99: goto tr1958
		case 100: goto tr1959
		case 104: goto tr1960
		case 105: goto tr1961
		case 109: goto tr1962
		case 110: goto tr1963
		case 114: goto tr1964
		case 115: goto tr1965
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 66 {
			goto tr429
		}
	} else {
		goto tr3056
	}
	goto st0
tr3056:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st953
st953:
	p++
	if p == pe { goto _test_eof953 }
	fallthrough
case 953:
// line 61169 "zparse.go"
	switch data[p] {
		case 9: goto tr3058
		case 10: goto tr3059
		case 32: goto tr3058
		case 40: goto tr3060
		case 41: goto tr3061
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr3063
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st953
	}
	goto st0
tr3066:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st954
tr3067:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st954
tr3065:
// line 101 "zparse.rl"
	{ lines++ }
	goto st954
tr3058:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st954
tr3059:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st954
tr3060:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st954
tr3061:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st954
st954:
	p++
	if p == pe { goto _test_eof954 }
	fallthrough
case 954:
// line 61249 "zparse.go"
	switch data[p] {
		case 9: goto st954
		case 10: goto tr3065
		case 32: goto st954
		case 40: goto tr3066
		case 41: goto tr3067
		case 59: goto st955
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2038 }
	goto st0
tr3063:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st955
st955:
	p++
	if p == pe { goto _test_eof955 }
	fallthrough
case 955:
// line 61291 "zparse.go"
	if data[p] == 10 { goto tr3065 }
	goto st955
tr3051:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st956
tr5186:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st956
st956:
	p++
	if p == pe { goto _test_eof956 }
	fallthrough
case 956:
// line 61317 "zparse.go"
	if data[p] == 10 { goto tr3053 }
	goto st956
tr3045:
// line 89 "zparse.rl"
	{ mark = p }
	goto st957
st957:
	p++
	if p == pe { goto _test_eof957 }
	fallthrough
case 957:
// line 61329 "zparse.go"
	if data[p] == 10 { goto tr3070 }
	goto st957
tr5422:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st958
st958:
	p++
	if p == pe { goto _test_eof958 }
	fallthrough
case 958:
// line 61343 "zparse.go"
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 72: goto st959
		case 78: goto st960
		case 83: goto st959
		case 92: goto st566
		case 95: goto st2
		case 104: goto st959
		case 110: goto st960
		case 115: goto st959
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st959:
	p++
	if p == pe { goto _test_eof959 }
	fallthrough
case 959:
	switch data[p] {
		case 9: goto tr3073
		case 10: goto tr3074
		case 32: goto tr3073
		case 40: goto tr3075
		case 41: goto tr3076
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr3077
		case 61: goto st113
		case 92: goto st566
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st960:
	p++
	if p == pe { goto _test_eof960 }
	fallthrough
case 960:
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 65: goto st961
		case 92: goto st566
		case 95: goto st2
		case 97: goto st961
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st961:
	p++
	if p == pe { goto _test_eof961 }
	fallthrough
case 961:
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 77: goto st962
		case 92: goto st566
		case 95: goto st2
		case 109: goto st962
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st962:
	p++
	if p == pe { goto _test_eof962 }
	fallthrough
case 962:
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 69: goto st963
		case 92: goto st566
		case 95: goto st2
		case 101: goto st963
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st963:
	p++
	if p == pe { goto _test_eof963 }
	fallthrough
case 963:
	switch data[p] {
		case 9: goto tr3081
		case 10: goto tr3082
		case 32: goto tr3081
		case 40: goto tr3083
		case 41: goto tr3084
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr3085
		case 61: goto st113
		case 92: goto st566
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
tr3088:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st964
tr3089:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st964
tr3087:
// line 101 "zparse.rl"
	{ lines++ }
	goto st964
tr3081:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st964
tr3082:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st964
tr3083:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st964
tr3084:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st964
st964:
	p++
	if p == pe { goto _test_eof964 }
	fallthrough
case 964:
// line 61604 "zparse.go"
	switch data[p] {
		case 9: goto st964
		case 10: goto tr3087
		case 32: goto st964
		case 40: goto tr3088
		case 41: goto tr3089
		case 43: goto tr3090
		case 58: goto tr3090
		case 59: goto st967
		case 61: goto tr3090
		case 65: goto tr3093
		case 67: goto tr3094
		case 68: goto tr3095
		case 72: goto tr3096
		case 73: goto tr3097
		case 77: goto tr3098
		case 78: goto tr3099
		case 82: goto tr3100
		case 83: goto tr3101
		case 92: goto tr3090
		case 97: goto tr3093
		case 99: goto tr3094
		case 100: goto tr3095
		case 104: goto tr3096
		case 105: goto tr3097
		case 109: goto tr3098
		case 110: goto tr3099
		case 114: goto tr3100
		case 115: goto tr3101
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr3090 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr3090 }
		} else if data[p] >= 66 {
			goto tr3090
		}
	} else {
		goto tr3091
	}
	goto st0
tr3090:
// line 89 "zparse.rl"
	{ mark = p }
	goto st965
st965:
	p++
	if p == pe { goto _test_eof965 }
	fallthrough
case 965:
// line 61656 "zparse.go"
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 92: goto st965
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
tr3091:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st966
st966:
	p++
	if p == pe { goto _test_eof966 }
	fallthrough
case 966:
// line 61687 "zparse.go"
	switch data[p] {
		case 9: goto tr3108
		case 10: goto tr3109
		case 32: goto tr3108
		case 40: goto tr3110
		case 41: goto tr3111
		case 43: goto st965
		case 58: goto st965
		case 59: goto tr3113
		case 61: goto st965
		case 92: goto st965
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st965 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st965 }
		} else if data[p] >= 65 {
			goto st965
		}
	} else {
		goto st966
	}
	goto st0
tr3085:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st967
st967:
	p++
	if p == pe { goto _test_eof967 }
	fallthrough
case 967:
// line 61734 "zparse.go"
	if data[p] == 10 { goto tr3087 }
	goto st967
tr3093:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st968
st968:
	p++
	if p == pe { goto _test_eof968 }
	fallthrough
case 968:
// line 61748 "zparse.go"
	switch data[p] {
		case 9: goto tr3114
		case 10: goto tr3115
		case 32: goto tr3114
		case 40: goto tr3116
		case 41: goto tr3117
		case 43: goto st965
		case 59: goto tr3118
		case 61: goto st965
		case 65: goto st969
		case 78: goto st972
		case 92: goto st965
		case 97: goto st969
		case 110: goto st972
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st969:
	p++
	if p == pe { goto _test_eof969 }
	fallthrough
case 969:
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 65: goto st970
		case 92: goto st965
		case 97: goto st970
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st970:
	p++
	if p == pe { goto _test_eof970 }
	fallthrough
case 970:
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 65: goto st971
		case 92: goto st965
		case 97: goto st971
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st971:
	p++
	if p == pe { goto _test_eof971 }
	fallthrough
case 971:
	switch data[p] {
		case 9: goto tr3123
		case 10: goto tr3124
		case 32: goto tr3123
		case 40: goto tr3125
		case 41: goto tr3126
		case 43: goto st965
		case 59: goto tr3127
		case 61: goto st965
		case 92: goto st965
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st972:
	p++
	if p == pe { goto _test_eof972 }
	fallthrough
case 972:
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 89: goto st973
		case 92: goto st965
		case 121: goto st973
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st973:
	p++
	if p == pe { goto _test_eof973 }
	fallthrough
case 973:
	switch data[p] {
		case 9: goto tr3129
		case 10: goto tr3130
		case 32: goto tr3129
		case 40: goto tr3131
		case 41: goto tr3132
		case 43: goto st965
		case 59: goto tr3133
		case 61: goto st965
		case 92: goto st965
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
tr3094:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st974
st974:
	p++
	if p == pe { goto _test_eof974 }
	fallthrough
case 974:
// line 61909 "zparse.go"
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 72: goto st973
		case 78: goto st975
		case 83: goto st973
		case 92: goto st965
		case 104: goto st973
		case 110: goto st975
		case 115: goto st973
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st975:
	p++
	if p == pe { goto _test_eof975 }
	fallthrough
case 975:
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 65: goto st976
		case 92: goto st965
		case 97: goto st976
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st976:
	p++
	if p == pe { goto _test_eof976 }
	fallthrough
case 976:
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 77: goto st977
		case 92: goto st965
		case 109: goto st977
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st977:
	p++
	if p == pe { goto _test_eof977 }
	fallthrough
case 977:
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 69: goto st978
		case 92: goto st965
		case 101: goto st978
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st978:
	p++
	if p == pe { goto _test_eof978 }
	fallthrough
case 978:
	switch data[p] {
		case 9: goto tr3138
		case 10: goto tr3139
		case 32: goto tr3138
		case 40: goto tr3140
		case 41: goto tr3141
		case 43: goto st965
		case 59: goto tr3142
		case 61: goto st965
		case 92: goto st965
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
tr3095:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st979
st979:
	p++
	if p == pe { goto _test_eof979 }
	fallthrough
case 979:
// line 62048 "zparse.go"
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 78: goto st980
		case 83: goto st985
		case 92: goto st965
		case 110: goto st980
		case 115: goto st985
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st980:
	p++
	if p == pe { goto _test_eof980 }
	fallthrough
case 980:
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 83: goto st981
		case 92: goto st965
		case 115: goto st981
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st981:
	p++
	if p == pe { goto _test_eof981 }
	fallthrough
case 981:
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 75: goto st982
		case 92: goto st965
		case 107: goto st982
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st982:
	p++
	if p == pe { goto _test_eof982 }
	fallthrough
case 982:
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 69: goto st983
		case 92: goto st965
		case 101: goto st983
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st983:
	p++
	if p == pe { goto _test_eof983 }
	fallthrough
case 983:
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 89: goto st984
		case 92: goto st965
		case 121: goto st984
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st984:
	p++
	if p == pe { goto _test_eof984 }
	fallthrough
case 984:
	switch data[p] {
		case 9: goto tr3149
		case 10: goto tr3150
		case 32: goto tr3149
		case 40: goto tr3151
		case 41: goto tr3152
		case 43: goto st965
		case 59: goto tr3153
		case 61: goto st965
		case 92: goto st965
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st985:
	p++
	if p == pe { goto _test_eof985 }
	fallthrough
case 985:
	switch data[p] {
		case 9: goto tr3154
		case 10: goto tr3155
		case 32: goto tr3154
		case 40: goto tr3156
		case 41: goto tr3157
		case 43: goto st965
		case 59: goto tr3158
		case 61: goto st965
		case 92: goto st965
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
tr3096:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st986
st986:
	p++
	if p == pe { goto _test_eof986 }
	fallthrough
case 986:
// line 62235 "zparse.go"
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 83: goto st973
		case 92: goto st965
		case 115: goto st973
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
tr3097:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st987
st987:
	p++
	if p == pe { goto _test_eof987 }
	fallthrough
case 987:
// line 62268 "zparse.go"
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 78: goto st973
		case 92: goto st965
		case 110: goto st973
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
tr3098:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st988
st988:
	p++
	if p == pe { goto _test_eof988 }
	fallthrough
case 988:
// line 62301 "zparse.go"
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 88: goto st989
		case 92: goto st965
		case 120: goto st989
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st989:
	p++
	if p == pe { goto _test_eof989 }
	fallthrough
case 989:
	switch data[p] {
		case 9: goto tr3160
		case 10: goto tr3161
		case 32: goto tr3160
		case 40: goto tr3162
		case 41: goto tr3163
		case 43: goto st965
		case 59: goto tr3164
		case 61: goto st965
		case 92: goto st965
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
tr3099:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st990
st990:
	p++
	if p == pe { goto _test_eof990 }
	fallthrough
case 990:
// line 62358 "zparse.go"
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 79: goto st991
		case 83: goto st993
		case 92: goto st965
		case 111: goto st991
		case 115: goto st993
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st991:
	p++
	if p == pe { goto _test_eof991 }
	fallthrough
case 991:
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 78: goto st992
		case 92: goto st965
		case 110: goto st992
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st992:
	p++
	if p == pe { goto _test_eof992 }
	fallthrough
case 992:
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 69: goto st973
		case 92: goto st965
		case 101: goto st973
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st993:
	p++
	if p == pe { goto _test_eof993 }
	fallthrough
case 993:
	switch data[p] {
		case 9: goto tr3168
		case 10: goto tr3169
		case 32: goto tr3168
		case 40: goto tr3170
		case 41: goto tr3171
		case 43: goto st965
		case 59: goto tr3172
		case 61: goto st965
		case 92: goto st965
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
tr3100:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st994
st994:
	p++
	if p == pe { goto _test_eof994 }
	fallthrough
case 994:
// line 62469 "zparse.go"
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 82: goto st995
		case 92: goto st965
		case 114: goto st995
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st995:
	p++
	if p == pe { goto _test_eof995 }
	fallthrough
case 995:
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 83: goto st996
		case 92: goto st965
		case 115: goto st996
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st996:
	p++
	if p == pe { goto _test_eof996 }
	fallthrough
case 996:
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 73: goto st997
		case 92: goto st965
		case 105: goto st997
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st997:
	p++
	if p == pe { goto _test_eof997 }
	fallthrough
case 997:
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 71: goto st998
		case 92: goto st965
		case 103: goto st998
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st998:
	p++
	if p == pe { goto _test_eof998 }
	fallthrough
case 998:
	switch data[p] {
		case 9: goto tr3177
		case 10: goto tr3178
		case 32: goto tr3177
		case 40: goto tr3179
		case 41: goto tr3180
		case 43: goto st965
		case 59: goto tr3181
		case 61: goto st965
		case 92: goto st965
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
tr3101:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st999
st999:
	p++
	if p == pe { goto _test_eof999 }
	fallthrough
case 999:
// line 62604 "zparse.go"
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 79: goto st1000
		case 92: goto st965
		case 111: goto st1000
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st1000:
	p++
	if p == pe { goto _test_eof1000 }
	fallthrough
case 1000:
	switch data[p] {
		case 9: goto tr3102
		case 10: goto tr3103
		case 32: goto tr3102
		case 40: goto tr3104
		case 41: goto tr3105
		case 43: goto st965
		case 59: goto tr3107
		case 61: goto st965
		case 65: goto st1001
		case 92: goto st965
		case 97: goto st1001
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
st1001:
	p++
	if p == pe { goto _test_eof1001 }
	fallthrough
case 1001:
	switch data[p] {
		case 9: goto tr3184
		case 10: goto tr3185
		case 32: goto tr3184
		case 40: goto tr3186
		case 41: goto tr3187
		case 43: goto st965
		case 59: goto tr3188
		case 61: goto st965
		case 92: goto st965
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st965 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st965 }
	} else {
		goto st965
	}
	goto st0
tr3039:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1002
tr3443:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1002
tr3034:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1002
tr5289:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1002
tr3188:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1002
st1002:
	p++
	if p == pe { goto _test_eof1002 }
	fallthrough
case 1002:
// line 62777 "zparse.go"
	if data[p] == 10 { goto tr3190 }
	goto st1002
tr5423:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1003
st1003:
	p++
	if p == pe { goto _test_eof1003 }
	fallthrough
case 1003:
// line 62791 "zparse.go"
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 78: goto st1004
		case 83: goto st1021
		case 92: goto st566
		case 95: goto st2
		case 110: goto st1004
		case 115: goto st1021
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1004:
	p++
	if p == pe { goto _test_eof1004 }
	fallthrough
case 1004:
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 83: goto st1005
		case 92: goto st566
		case 95: goto st2
		case 115: goto st1005
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1005:
	p++
	if p == pe { goto _test_eof1005 }
	fallthrough
case 1005:
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 75: goto st1006
		case 92: goto st566
		case 95: goto st2
		case 107: goto st1006
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1006:
	p++
	if p == pe { goto _test_eof1006 }
	fallthrough
case 1006:
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 69: goto st1007
		case 92: goto st566
		case 95: goto st2
		case 101: goto st1007
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1007:
	p++
	if p == pe { goto _test_eof1007 }
	fallthrough
case 1007:
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 89: goto st1008
		case 92: goto st566
		case 95: goto st2
		case 121: goto st1008
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1008:
	p++
	if p == pe { goto _test_eof1008 }
	fallthrough
case 1008:
	switch data[p] {
		case 9: goto tr3197
		case 10: goto tr3198
		case 32: goto tr3197
		case 40: goto tr3199
		case 41: goto tr3200
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr3201
		case 61: goto st113
		case 92: goto st566
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
tr3204:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1009
tr3205:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1009
tr3203:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1009
tr3197:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1009
tr3198:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1009
tr3199:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1009
tr3200:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1009
st1009:
	p++
	if p == pe { goto _test_eof1009 }
	fallthrough
case 1009:
// line 63052 "zparse.go"
	switch data[p] {
		case 9: goto st1009
		case 10: goto tr3203
		case 32: goto st1009
		case 40: goto tr3204
		case 41: goto tr3205
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1020
		case 61: goto tr429
		case 65: goto tr1957
		case 67: goto tr1958
		case 68: goto tr1959
		case 72: goto tr1960
		case 73: goto tr1961
		case 77: goto tr1962
		case 78: goto tr1963
		case 82: goto tr1964
		case 83: goto tr1965
		case 92: goto tr429
		case 97: goto tr1957
		case 99: goto tr1958
		case 100: goto tr1959
		case 104: goto tr1960
		case 105: goto tr1961
		case 109: goto tr1962
		case 110: goto tr1963
		case 114: goto tr1964
		case 115: goto tr1965
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 66 {
			goto tr429
		}
	} else {
		goto tr3206
	}
	goto st0
tr3206:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1010
st1010:
	p++
	if p == pe { goto _test_eof1010 }
	fallthrough
case 1010:
// line 63106 "zparse.go"
	switch data[p] {
		case 9: goto tr3208
		case 10: goto tr3209
		case 32: goto tr3208
		case 40: goto tr3210
		case 41: goto tr3211
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr3213
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st1010
	}
	goto st0
tr3216:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1011
tr3217:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1011
tr3215:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1011
tr3208:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1011
tr3209:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1011
tr3210:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1011
tr3211:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1011
st1011:
	p++
	if p == pe { goto _test_eof1011 }
	fallthrough
case 1011:
// line 63186 "zparse.go"
	switch data[p] {
		case 9: goto st1011
		case 10: goto tr3215
		case 32: goto st1011
		case 40: goto tr3216
		case 41: goto tr3217
		case 59: goto st1019
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr3218 }
	goto st0
tr3218:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1012
st1012:
	p++
	if p == pe { goto _test_eof1012 }
	fallthrough
case 1012:
// line 63224 "zparse.go"
	switch data[p] {
		case 9: goto tr3220
		case 10: goto tr3221
		case 32: goto tr3220
		case 40: goto tr3222
		case 41: goto tr3223
		case 59: goto tr3225
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1012 }
	goto st0
tr3228:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1013
tr3229:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1013
tr3227:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1013
tr3220:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1013
tr3221:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1013
tr3222:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1013
tr3223:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1013
st1013:
	p++
	if p == pe { goto _test_eof1013 }
	fallthrough
case 1013:
// line 63274 "zparse.go"
	switch data[p] {
		case 9: goto st1013
		case 10: goto tr3227
		case 32: goto st1013
		case 40: goto tr3228
		case 41: goto tr3229
		case 59: goto st1018
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr3230 }
	goto st0
tr3230:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1014
st1014:
	p++
	if p == pe { goto _test_eof1014 }
	fallthrough
case 1014:
// line 63294 "zparse.go"
	switch data[p] {
		case 9: goto tr3232
		case 10: goto tr3233
		case 32: goto tr3232
		case 40: goto tr3234
		case 41: goto tr3235
		case 59: goto tr3237
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1014 }
	goto st0
tr3240:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1015
tr3241:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1015
tr3239:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1015
tr3232:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1015
tr3233:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1015
tr3234:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1015
tr3235:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1015
st1015:
	p++
	if p == pe { goto _test_eof1015 }
	fallthrough
case 1015:
// line 63344 "zparse.go"
	switch data[p] {
		case 9: goto st1015
		case 10: goto tr3239
		case 32: goto st1015
		case 40: goto tr3240
		case 41: goto tr3241
		case 43: goto tr180
		case 58: goto tr180
		case 59: goto st1017
		case 61: goto tr180
		case 92: goto tr180
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr180 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr180 }
		} else if data[p] >= 65 {
			goto tr180
		}
	} else {
		goto tr3242
	}
	goto st0
tr3242:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1016
st1016:
	p++
	if p == pe { goto _test_eof1016 }
	fallthrough
case 1016:
// line 63378 "zparse.go"
	switch data[p] {
		case 9: goto tr3244
		case 10: goto tr3245
		case 32: goto tr3244
		case 40: goto tr3246
		case 41: goto tr3247
		case 43: goto st46
		case 58: goto st46
		case 59: goto tr3249
		case 61: goto st46
		case 92: goto st46
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st46 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st46 }
		} else if data[p] >= 65 {
			goto st46
		}
	} else {
		goto st1016
	}
	goto st0
tr3237:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1017
st1017:
	p++
	if p == pe { goto _test_eof1017 }
	fallthrough
case 1017:
// line 63412 "zparse.go"
	if data[p] == 10 { goto tr3239 }
	goto st1017
tr3225:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1018
st1018:
	p++
	if p == pe { goto _test_eof1018 }
	fallthrough
case 1018:
// line 63424 "zparse.go"
	if data[p] == 10 { goto tr3227 }
	goto st1018
tr3213:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1019
st1019:
	p++
	if p == pe { goto _test_eof1019 }
	fallthrough
case 1019:
// line 63440 "zparse.go"
	if data[p] == 10 { goto tr3215 }
	goto st1019
tr3201:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1020
st1020:
	p++
	if p == pe { goto _test_eof1020 }
	fallthrough
case 1020:
// line 63465 "zparse.go"
	if data[p] == 10 { goto tr3203 }
	goto st1020
st1021:
	p++
	if p == pe { goto _test_eof1021 }
	fallthrough
case 1021:
	switch data[p] {
		case 9: goto tr3250
		case 10: goto tr3251
		case 32: goto tr3250
		case 40: goto tr3252
		case 41: goto tr3253
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr3254
		case 61: goto st113
		case 92: goto st566
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
tr3257:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1022
tr3258:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1022
tr3256:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1022
tr3250:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1022
tr3251:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1022
tr3252:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1022
tr3253:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1022
st1022:
	p++
	if p == pe { goto _test_eof1022 }
	fallthrough
case 1022:
// line 63586 "zparse.go"
	switch data[p] {
		case 9: goto st1022
		case 10: goto tr3256
		case 32: goto st1022
		case 40: goto tr3257
		case 41: goto tr3258
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1033
		case 61: goto tr429
		case 65: goto tr1957
		case 67: goto tr1958
		case 68: goto tr1959
		case 72: goto tr1960
		case 73: goto tr1961
		case 77: goto tr1962
		case 78: goto tr1963
		case 82: goto tr1964
		case 83: goto tr1965
		case 92: goto tr429
		case 97: goto tr1957
		case 99: goto tr1958
		case 100: goto tr1959
		case 104: goto tr1960
		case 105: goto tr1961
		case 109: goto tr1962
		case 110: goto tr1963
		case 114: goto tr1964
		case 115: goto tr1965
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 66 {
			goto tr429
		}
	} else {
		goto tr3259
	}
	goto st0
tr3259:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1023
st1023:
	p++
	if p == pe { goto _test_eof1023 }
	fallthrough
case 1023:
// line 63640 "zparse.go"
	switch data[p] {
		case 9: goto tr3261
		case 10: goto tr3262
		case 32: goto tr3261
		case 40: goto tr3263
		case 41: goto tr3264
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr3266
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st1023
	}
	goto st0
tr3269:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1024
tr3270:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1024
tr3268:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1024
tr3261:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1024
tr3262:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1024
tr3263:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1024
tr3264:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1024
st1024:
	p++
	if p == pe { goto _test_eof1024 }
	fallthrough
case 1024:
// line 63720 "zparse.go"
	switch data[p] {
		case 9: goto st1024
		case 10: goto tr3268
		case 32: goto st1024
		case 40: goto tr3269
		case 41: goto tr3270
		case 59: goto st1032
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr3271 }
	goto st0
tr3271:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1025
st1025:
	p++
	if p == pe { goto _test_eof1025 }
	fallthrough
case 1025:
// line 63758 "zparse.go"
	switch data[p] {
		case 9: goto tr3273
		case 10: goto tr3274
		case 32: goto tr3273
		case 40: goto tr3275
		case 41: goto tr3276
		case 59: goto tr3278
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1025 }
	goto st0
tr3281:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1026
tr3282:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1026
tr3280:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1026
tr3273:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1026
tr3274:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1026
tr3275:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1026
tr3276:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1026
st1026:
	p++
	if p == pe { goto _test_eof1026 }
	fallthrough
case 1026:
// line 63808 "zparse.go"
	switch data[p] {
		case 9: goto st1026
		case 10: goto tr3280
		case 32: goto st1026
		case 40: goto tr3281
		case 41: goto tr3282
		case 59: goto st1031
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr3283 }
	goto st0
tr3283:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1027
st1027:
	p++
	if p == pe { goto _test_eof1027 }
	fallthrough
case 1027:
// line 63828 "zparse.go"
	switch data[p] {
		case 9: goto tr3285
		case 10: goto tr3286
		case 32: goto tr3285
		case 40: goto tr3287
		case 41: goto tr3288
		case 59: goto tr3290
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1027 }
	goto st0
tr3293:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1028
tr3294:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1028
tr3292:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1028
tr3285:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1028
tr3286:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1028
tr3287:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1028
tr3288:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1028
st1028:
	p++
	if p == pe { goto _test_eof1028 }
	fallthrough
case 1028:
// line 63878 "zparse.go"
	switch data[p] {
		case 9: goto st1028
		case 10: goto tr3292
		case 32: goto st1028
		case 40: goto tr3293
		case 41: goto tr3294
		case 43: goto tr233
		case 58: goto tr233
		case 59: goto st1030
		case 61: goto tr233
		case 92: goto tr233
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr233 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr233 }
		} else if data[p] >= 65 {
			goto tr233
		}
	} else {
		goto tr3295
	}
	goto st0
tr3295:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1029
st1029:
	p++
	if p == pe { goto _test_eof1029 }
	fallthrough
case 1029:
// line 63912 "zparse.go"
	switch data[p] {
		case 9: goto tr3297
		case 10: goto tr3298
		case 32: goto tr3297
		case 40: goto tr3299
		case 41: goto tr3300
		case 43: goto st59
		case 58: goto st59
		case 59: goto tr3302
		case 61: goto st59
		case 92: goto st59
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st59 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st59 }
		} else if data[p] >= 65 {
			goto st59
		}
	} else {
		goto st1029
	}
	goto st0
tr3290:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1030
st1030:
	p++
	if p == pe { goto _test_eof1030 }
	fallthrough
case 1030:
// line 63946 "zparse.go"
	if data[p] == 10 { goto tr3292 }
	goto st1030
tr3278:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1031
st1031:
	p++
	if p == pe { goto _test_eof1031 }
	fallthrough
case 1031:
// line 63958 "zparse.go"
	if data[p] == 10 { goto tr3280 }
	goto st1031
tr3266:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1032
st1032:
	p++
	if p == pe { goto _test_eof1032 }
	fallthrough
case 1032:
// line 63974 "zparse.go"
	if data[p] == 10 { goto tr3268 }
	goto st1032
tr3254:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1033
st1033:
	p++
	if p == pe { goto _test_eof1033 }
	fallthrough
case 1033:
// line 63999 "zparse.go"
	if data[p] == 10 { goto tr3256 }
	goto st1033
tr5424:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1034
st1034:
	p++
	if p == pe { goto _test_eof1034 }
	fallthrough
case 1034:
// line 64013 "zparse.go"
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 83: goto st959
		case 92: goto st566
		case 95: goto st2
		case 115: goto st959
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
tr5425:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1035
st1035:
	p++
	if p == pe { goto _test_eof1035 }
	fallthrough
case 1035:
// line 64049 "zparse.go"
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 78: goto st959
		case 92: goto st566
		case 95: goto st2
		case 110: goto st959
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
tr5426:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1036
st1036:
	p++
	if p == pe { goto _test_eof1036 }
	fallthrough
case 1036:
// line 64085 "zparse.go"
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 88: goto st1037
		case 92: goto st566
		case 95: goto st2
		case 120: goto st1037
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1037:
	p++
	if p == pe { goto _test_eof1037 }
	fallthrough
case 1037:
	switch data[p] {
		case 9: goto tr3304
		case 10: goto tr3305
		case 32: goto tr3304
		case 40: goto tr3306
		case 41: goto tr3307
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr3308
		case 61: goto st113
		case 92: goto st566
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
tr3311:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1038
tr3312:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1038
tr3310:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1038
tr3304:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1038
tr3305:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1038
tr3306:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1038
tr3307:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1038
st1038:
	p++
	if p == pe { goto _test_eof1038 }
	fallthrough
case 1038:
// line 64228 "zparse.go"
	switch data[p] {
		case 9: goto st1038
		case 10: goto tr3310
		case 32: goto st1038
		case 40: goto tr3311
		case 41: goto tr3312
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1043
		case 61: goto tr429
		case 65: goto tr1957
		case 67: goto tr1958
		case 68: goto tr1959
		case 72: goto tr1960
		case 73: goto tr1961
		case 77: goto tr1962
		case 78: goto tr1963
		case 82: goto tr1964
		case 83: goto tr1965
		case 92: goto tr429
		case 97: goto tr1957
		case 99: goto tr1958
		case 100: goto tr1959
		case 104: goto tr1960
		case 105: goto tr1961
		case 109: goto tr1962
		case 110: goto tr1963
		case 114: goto tr1964
		case 115: goto tr1965
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 66 {
			goto tr429
		}
	} else {
		goto tr3313
	}
	goto st0
tr3313:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1039
st1039:
	p++
	if p == pe { goto _test_eof1039 }
	fallthrough
case 1039:
// line 64282 "zparse.go"
	switch data[p] {
		case 9: goto tr3315
		case 10: goto tr3316
		case 32: goto tr3315
		case 40: goto tr3317
		case 41: goto tr3318
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr3320
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st1039
	}
	goto st0
tr3323:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1040
tr3324:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1040
tr3322:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1040
tr3315:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1040
tr3316:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1040
tr3317:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1040
tr3318:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1040
st1040:
	p++
	if p == pe { goto _test_eof1040 }
	fallthrough
case 1040:
// line 64362 "zparse.go"
	switch data[p] {
		case 9: goto st1040
		case 10: goto tr3322
		case 32: goto st1040
		case 40: goto tr3323
		case 41: goto tr3324
		case 43: goto tr263
		case 58: goto tr263
		case 59: goto st1042
		case 61: goto tr263
		case 65: goto tr862
		case 67: goto tr863
		case 68: goto tr864
		case 72: goto tr865
		case 73: goto tr866
		case 77: goto tr867
		case 78: goto tr868
		case 82: goto tr869
		case 83: goto tr870
		case 92: goto tr263
		case 97: goto tr862
		case 99: goto tr863
		case 100: goto tr864
		case 104: goto tr865
		case 105: goto tr866
		case 109: goto tr867
		case 110: goto tr868
		case 114: goto tr869
		case 115: goto tr870
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr263 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr263 }
		} else if data[p] >= 66 {
			goto tr263
		}
	} else {
		goto tr3325
	}
	goto st0
tr3325:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1041
st1041:
	p++
	if p == pe { goto _test_eof1041 }
	fallthrough
case 1041:
// line 64414 "zparse.go"
	switch data[p] {
		case 9: goto tr3327
		case 10: goto tr3328
		case 32: goto tr3327
		case 40: goto tr3329
		case 41: goto tr3330
		case 43: goto st69
		case 58: goto st69
		case 59: goto tr3332
		case 61: goto st69
		case 92: goto st69
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st69 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st69 }
		} else if data[p] >= 65 {
			goto st69
		}
	} else {
		goto st1041
	}
	goto st0
tr3320:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1042
st1042:
	p++
	if p == pe { goto _test_eof1042 }
	fallthrough
case 1042:
// line 64452 "zparse.go"
	if data[p] == 10 { goto tr3322 }
	goto st1042
tr3308:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1043
st1043:
	p++
	if p == pe { goto _test_eof1043 }
	fallthrough
case 1043:
// line 64477 "zparse.go"
	if data[p] == 10 { goto tr3310 }
	goto st1043
tr5427:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1044
st1044:
	p++
	if p == pe { goto _test_eof1044 }
	fallthrough
case 1044:
// line 64491 "zparse.go"
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 79: goto st1045
		case 83: goto st1047
		case 92: goto st566
		case 95: goto st2
		case 111: goto st1045
		case 115: goto st1047
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1045:
	p++
	if p == pe { goto _test_eof1045 }
	fallthrough
case 1045:
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 78: goto st1046
		case 92: goto st566
		case 95: goto st2
		case 110: goto st1046
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1046:
	p++
	if p == pe { goto _test_eof1046 }
	fallthrough
case 1046:
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 69: goto st959
		case 92: goto st566
		case 95: goto st2
		case 101: goto st959
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1047:
	p++
	if p == pe { goto _test_eof1047 }
	fallthrough
case 1047:
	switch data[p] {
		case 9: goto tr3336
		case 10: goto tr3337
		case 32: goto tr3336
		case 40: goto tr3338
		case 41: goto tr3339
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr3340
		case 61: goto st113
		case 92: goto st566
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
tr3343:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1048
tr3344:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1048
tr3342:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1048
tr3336:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1048
tr3337:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1048
tr3338:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1048
tr3339:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1048
st1048:
	p++
	if p == pe { goto _test_eof1048 }
	fallthrough
case 1048:
// line 64694 "zparse.go"
	switch data[p] {
		case 9: goto st1048
		case 10: goto tr3342
		case 32: goto st1048
		case 40: goto tr3343
		case 41: goto tr3344
		case 43: goto tr3345
		case 58: goto tr3345
		case 59: goto st1051
		case 61: goto tr3345
		case 65: goto tr3348
		case 67: goto tr3349
		case 68: goto tr3350
		case 72: goto tr3351
		case 73: goto tr3352
		case 77: goto tr3353
		case 78: goto tr3354
		case 82: goto tr3355
		case 83: goto tr3356
		case 92: goto tr3345
		case 97: goto tr3348
		case 99: goto tr3349
		case 100: goto tr3350
		case 104: goto tr3351
		case 105: goto tr3352
		case 109: goto tr3353
		case 110: goto tr3354
		case 114: goto tr3355
		case 115: goto tr3356
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr3345 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr3345 }
		} else if data[p] >= 66 {
			goto tr3345
		}
	} else {
		goto tr3346
	}
	goto st0
tr3345:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1049
st1049:
	p++
	if p == pe { goto _test_eof1049 }
	fallthrough
case 1049:
// line 64746 "zparse.go"
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 92: goto st1049
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
tr3346:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1050
st1050:
	p++
	if p == pe { goto _test_eof1050 }
	fallthrough
case 1050:
// line 64777 "zparse.go"
	switch data[p] {
		case 9: goto tr3363
		case 10: goto tr3364
		case 32: goto tr3363
		case 40: goto tr3365
		case 41: goto tr3366
		case 43: goto st1049
		case 58: goto st1049
		case 59: goto tr3368
		case 61: goto st1049
		case 92: goto st1049
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st1049 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st1049 }
		} else if data[p] >= 65 {
			goto st1049
		}
	} else {
		goto st1050
	}
	goto st0
tr3340:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1051
st1051:
	p++
	if p == pe { goto _test_eof1051 }
	fallthrough
case 1051:
// line 64824 "zparse.go"
	if data[p] == 10 { goto tr3342 }
	goto st1051
tr3348:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1052
st1052:
	p++
	if p == pe { goto _test_eof1052 }
	fallthrough
case 1052:
// line 64838 "zparse.go"
	switch data[p] {
		case 9: goto tr3369
		case 10: goto tr3370
		case 32: goto tr3369
		case 40: goto tr3371
		case 41: goto tr3372
		case 43: goto st1049
		case 59: goto tr3373
		case 61: goto st1049
		case 65: goto st1053
		case 78: goto st1056
		case 92: goto st1049
		case 97: goto st1053
		case 110: goto st1056
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1053:
	p++
	if p == pe { goto _test_eof1053 }
	fallthrough
case 1053:
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 65: goto st1054
		case 92: goto st1049
		case 97: goto st1054
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1054:
	p++
	if p == pe { goto _test_eof1054 }
	fallthrough
case 1054:
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 65: goto st1055
		case 92: goto st1049
		case 97: goto st1055
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1055:
	p++
	if p == pe { goto _test_eof1055 }
	fallthrough
case 1055:
	switch data[p] {
		case 9: goto tr3378
		case 10: goto tr3379
		case 32: goto tr3378
		case 40: goto tr3380
		case 41: goto tr3381
		case 43: goto st1049
		case 59: goto tr3382
		case 61: goto st1049
		case 92: goto st1049
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1056:
	p++
	if p == pe { goto _test_eof1056 }
	fallthrough
case 1056:
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 89: goto st1057
		case 92: goto st1049
		case 121: goto st1057
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1057:
	p++
	if p == pe { goto _test_eof1057 }
	fallthrough
case 1057:
	switch data[p] {
		case 9: goto tr3384
		case 10: goto tr3385
		case 32: goto tr3384
		case 40: goto tr3386
		case 41: goto tr3387
		case 43: goto st1049
		case 59: goto tr3388
		case 61: goto st1049
		case 92: goto st1049
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
tr3349:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1058
st1058:
	p++
	if p == pe { goto _test_eof1058 }
	fallthrough
case 1058:
// line 64999 "zparse.go"
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 72: goto st1057
		case 78: goto st1059
		case 83: goto st1057
		case 92: goto st1049
		case 104: goto st1057
		case 110: goto st1059
		case 115: goto st1057
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1059:
	p++
	if p == pe { goto _test_eof1059 }
	fallthrough
case 1059:
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 65: goto st1060
		case 92: goto st1049
		case 97: goto st1060
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1060:
	p++
	if p == pe { goto _test_eof1060 }
	fallthrough
case 1060:
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 77: goto st1061
		case 92: goto st1049
		case 109: goto st1061
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1061:
	p++
	if p == pe { goto _test_eof1061 }
	fallthrough
case 1061:
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 69: goto st1062
		case 92: goto st1049
		case 101: goto st1062
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1062:
	p++
	if p == pe { goto _test_eof1062 }
	fallthrough
case 1062:
	switch data[p] {
		case 9: goto tr3393
		case 10: goto tr3394
		case 32: goto tr3393
		case 40: goto tr3395
		case 41: goto tr3396
		case 43: goto st1049
		case 59: goto tr3397
		case 61: goto st1049
		case 92: goto st1049
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
tr3350:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1063
st1063:
	p++
	if p == pe { goto _test_eof1063 }
	fallthrough
case 1063:
// line 65138 "zparse.go"
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 78: goto st1064
		case 83: goto st1069
		case 92: goto st1049
		case 110: goto st1064
		case 115: goto st1069
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1064:
	p++
	if p == pe { goto _test_eof1064 }
	fallthrough
case 1064:
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 83: goto st1065
		case 92: goto st1049
		case 115: goto st1065
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1065:
	p++
	if p == pe { goto _test_eof1065 }
	fallthrough
case 1065:
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 75: goto st1066
		case 92: goto st1049
		case 107: goto st1066
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1066:
	p++
	if p == pe { goto _test_eof1066 }
	fallthrough
case 1066:
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 69: goto st1067
		case 92: goto st1049
		case 101: goto st1067
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1067:
	p++
	if p == pe { goto _test_eof1067 }
	fallthrough
case 1067:
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 89: goto st1068
		case 92: goto st1049
		case 121: goto st1068
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1068:
	p++
	if p == pe { goto _test_eof1068 }
	fallthrough
case 1068:
	switch data[p] {
		case 9: goto tr3404
		case 10: goto tr3405
		case 32: goto tr3404
		case 40: goto tr3406
		case 41: goto tr3407
		case 43: goto st1049
		case 59: goto tr3408
		case 61: goto st1049
		case 92: goto st1049
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1069:
	p++
	if p == pe { goto _test_eof1069 }
	fallthrough
case 1069:
	switch data[p] {
		case 9: goto tr3409
		case 10: goto tr3410
		case 32: goto tr3409
		case 40: goto tr3411
		case 41: goto tr3412
		case 43: goto st1049
		case 59: goto tr3413
		case 61: goto st1049
		case 92: goto st1049
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
tr3351:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1070
st1070:
	p++
	if p == pe { goto _test_eof1070 }
	fallthrough
case 1070:
// line 65325 "zparse.go"
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 83: goto st1057
		case 92: goto st1049
		case 115: goto st1057
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
tr3352:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1071
st1071:
	p++
	if p == pe { goto _test_eof1071 }
	fallthrough
case 1071:
// line 65358 "zparse.go"
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 78: goto st1057
		case 92: goto st1049
		case 110: goto st1057
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
tr3353:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1072
st1072:
	p++
	if p == pe { goto _test_eof1072 }
	fallthrough
case 1072:
// line 65391 "zparse.go"
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 88: goto st1073
		case 92: goto st1049
		case 120: goto st1073
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1073:
	p++
	if p == pe { goto _test_eof1073 }
	fallthrough
case 1073:
	switch data[p] {
		case 9: goto tr3415
		case 10: goto tr3416
		case 32: goto tr3415
		case 40: goto tr3417
		case 41: goto tr3418
		case 43: goto st1049
		case 59: goto tr3419
		case 61: goto st1049
		case 92: goto st1049
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
tr3354:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1074
st1074:
	p++
	if p == pe { goto _test_eof1074 }
	fallthrough
case 1074:
// line 65448 "zparse.go"
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 79: goto st1075
		case 83: goto st1077
		case 92: goto st1049
		case 111: goto st1075
		case 115: goto st1077
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1075:
	p++
	if p == pe { goto _test_eof1075 }
	fallthrough
case 1075:
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 78: goto st1076
		case 92: goto st1049
		case 110: goto st1076
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1076:
	p++
	if p == pe { goto _test_eof1076 }
	fallthrough
case 1076:
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 69: goto st1057
		case 92: goto st1049
		case 101: goto st1057
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1077:
	p++
	if p == pe { goto _test_eof1077 }
	fallthrough
case 1077:
	switch data[p] {
		case 9: goto tr3423
		case 10: goto tr3424
		case 32: goto tr3423
		case 40: goto tr3425
		case 41: goto tr3426
		case 43: goto st1049
		case 59: goto tr3427
		case 61: goto st1049
		case 92: goto st1049
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
tr3355:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1078
st1078:
	p++
	if p == pe { goto _test_eof1078 }
	fallthrough
case 1078:
// line 65559 "zparse.go"
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 82: goto st1079
		case 92: goto st1049
		case 114: goto st1079
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1079:
	p++
	if p == pe { goto _test_eof1079 }
	fallthrough
case 1079:
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 83: goto st1080
		case 92: goto st1049
		case 115: goto st1080
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1080:
	p++
	if p == pe { goto _test_eof1080 }
	fallthrough
case 1080:
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 73: goto st1081
		case 92: goto st1049
		case 105: goto st1081
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1081:
	p++
	if p == pe { goto _test_eof1081 }
	fallthrough
case 1081:
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 71: goto st1082
		case 92: goto st1049
		case 103: goto st1082
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1082:
	p++
	if p == pe { goto _test_eof1082 }
	fallthrough
case 1082:
	switch data[p] {
		case 9: goto tr3432
		case 10: goto tr3433
		case 32: goto tr3432
		case 40: goto tr3434
		case 41: goto tr3435
		case 43: goto st1049
		case 59: goto tr3436
		case 61: goto st1049
		case 92: goto st1049
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
tr3356:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1083
st1083:
	p++
	if p == pe { goto _test_eof1083 }
	fallthrough
case 1083:
// line 65694 "zparse.go"
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 79: goto st1084
		case 92: goto st1049
		case 111: goto st1084
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1084:
	p++
	if p == pe { goto _test_eof1084 }
	fallthrough
case 1084:
	switch data[p] {
		case 9: goto tr3357
		case 10: goto tr3358
		case 32: goto tr3357
		case 40: goto tr3359
		case 41: goto tr3360
		case 43: goto st1049
		case 59: goto tr3362
		case 61: goto st1049
		case 65: goto st1085
		case 92: goto st1049
		case 97: goto st1085
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
st1085:
	p++
	if p == pe { goto _test_eof1085 }
	fallthrough
case 1085:
	switch data[p] {
		case 9: goto tr3439
		case 10: goto tr3440
		case 32: goto tr3439
		case 40: goto tr3441
		case 41: goto tr3442
		case 43: goto st1049
		case 59: goto tr3443
		case 61: goto st1049
		case 92: goto st1049
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1049 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1049 }
	} else {
		goto st1049
	}
	goto st0
tr5428:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1086
st1086:
	p++
	if p == pe { goto _test_eof1086 }
	fallthrough
case 1086:
// line 65777 "zparse.go"
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 82: goto st1087
		case 92: goto st566
		case 95: goto st2
		case 114: goto st1087
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1087:
	p++
	if p == pe { goto _test_eof1087 }
	fallthrough
case 1087:
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 83: goto st1088
		case 92: goto st566
		case 95: goto st2
		case 115: goto st1088
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1088:
	p++
	if p == pe { goto _test_eof1088 }
	fallthrough
case 1088:
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 73: goto st1089
		case 92: goto st566
		case 95: goto st2
		case 105: goto st1089
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1089:
	p++
	if p == pe { goto _test_eof1089 }
	fallthrough
case 1089:
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 71: goto st1090
		case 92: goto st566
		case 95: goto st2
		case 103: goto st1090
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1090:
	p++
	if p == pe { goto _test_eof1090 }
	fallthrough
case 1090:
	switch data[p] {
		case 9: goto tr3448
		case 10: goto tr3449
		case 32: goto tr3448
		case 40: goto tr3450
		case 41: goto tr3451
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr3452
		case 61: goto st113
		case 92: goto st566
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
tr3455:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1091
tr3456:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1091
tr3454:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1091
tr3448:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1091
tr3449:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1091
tr3450:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1091
tr3451:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1091
st1091:
	p++
	if p == pe { goto _test_eof1091 }
	fallthrough
case 1091:
// line 66007 "zparse.go"
	switch data[p] {
		case 9: goto st1091
		case 10: goto tr3454
		case 32: goto st1091
		case 40: goto tr3455
		case 41: goto tr3456
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1485
		case 61: goto tr429
		case 65: goto tr1957
		case 67: goto tr1958
		case 68: goto tr1959
		case 72: goto tr1960
		case 73: goto tr1961
		case 77: goto tr1962
		case 78: goto tr1963
		case 82: goto tr1964
		case 83: goto tr1965
		case 92: goto tr429
		case 97: goto tr1957
		case 99: goto tr1958
		case 100: goto tr1959
		case 104: goto tr1960
		case 105: goto tr1961
		case 109: goto tr1962
		case 110: goto tr1963
		case 114: goto tr1964
		case 115: goto tr1965
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 66 {
			goto tr429
		}
	} else {
		goto tr3457
	}
	goto st0
tr3457:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1092
st1092:
	p++
	if p == pe { goto _test_eof1092 }
	fallthrough
case 1092:
// line 66061 "zparse.go"
	switch data[p] {
		case 9: goto tr3459
		case 10: goto tr3460
		case 32: goto tr3459
		case 40: goto tr3461
		case 41: goto tr3462
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr3464
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st1092
	}
	goto st0
tr3467:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1093
tr3468:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1093
tr3466:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1093
tr3459:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1093
tr3460:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1093
tr3461:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1093
tr3462:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1093
st1093:
	p++
	if p == pe { goto _test_eof1093 }
	fallthrough
case 1093:
// line 66141 "zparse.go"
	switch data[p] {
		case 9: goto st1093
		case 10: goto tr3466
		case 32: goto st1093
		case 40: goto tr3467
		case 41: goto tr3468
		case 59: goto st1484
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr3469 }
	goto st0
tr3469:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1094
st1094:
	p++
	if p == pe { goto _test_eof1094 }
	fallthrough
case 1094:
// line 66179 "zparse.go"
	switch data[p] {
		case 9: goto tr3471
		case 10: goto tr3472
		case 32: goto tr3471
		case 40: goto tr3473
		case 41: goto tr3474
		case 59: goto tr3476
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1094 }
	goto st0
tr3479:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1095
tr3480:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1095
tr3478:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1095
tr3471:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1095
tr3472:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1095
tr3473:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1095
tr3474:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1095
st1095:
	p++
	if p == pe { goto _test_eof1095 }
	fallthrough
case 1095:
// line 66229 "zparse.go"
	switch data[p] {
		case 9: goto st1095
		case 10: goto tr3478
		case 32: goto st1095
		case 40: goto tr3479
		case 41: goto tr3480
		case 59: goto st1483
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr3481 }
	goto st0
tr3481:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1096
st1096:
	p++
	if p == pe { goto _test_eof1096 }
	fallthrough
case 1096:
// line 66249 "zparse.go"
	switch data[p] {
		case 9: goto tr3483
		case 10: goto tr3484
		case 32: goto tr3483
		case 40: goto tr3485
		case 41: goto tr3486
		case 59: goto tr3488
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1096 }
	goto st0
tr3491:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1097
tr3492:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1097
tr3490:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1097
tr3483:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1097
tr3484:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1097
tr3485:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1097
tr3486:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1097
st1097:
	p++
	if p == pe { goto _test_eof1097 }
	fallthrough
case 1097:
// line 66299 "zparse.go"
	switch data[p] {
		case 9: goto st1097
		case 10: goto tr3490
		case 32: goto st1097
		case 40: goto tr3491
		case 41: goto tr3492
		case 59: goto st1482
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr3493 }
	goto st0
tr3493:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1098
st1098:
	p++
	if p == pe { goto _test_eof1098 }
	fallthrough
case 1098:
// line 66319 "zparse.go"
	switch data[p] {
		case 9: goto tr3495
		case 10: goto tr3496
		case 32: goto tr3495
		case 40: goto tr3497
		case 41: goto tr3498
		case 59: goto tr3500
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1098 }
	goto st0
tr3503:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1099
tr3504:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1099
tr3502:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1099
tr3495:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1099
tr3496:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1099
tr3497:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1099
tr3498:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1099
st1099:
	p++
	if p == pe { goto _test_eof1099 }
	fallthrough
case 1099:
// line 66369 "zparse.go"
	switch data[p] {
		case 9: goto st1099
		case 10: goto tr3502
		case 32: goto st1099
		case 40: goto tr3503
		case 41: goto tr3504
		case 59: goto st1481
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr3505 }
	goto st0
tr3505:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1100
st1100:
	p++
	if p == pe { goto _test_eof1100 }
	fallthrough
case 1100:
// line 66389 "zparse.go"
	switch data[p] {
		case 9: goto tr3507
		case 10: goto tr3508
		case 32: goto tr3507
		case 40: goto tr3509
		case 41: goto tr3510
		case 59: goto tr3512
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1100 }
	goto st0
tr3515:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1101
tr3516:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1101
tr3514:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1101
tr3507:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1101
tr3508:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1101
tr3509:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1101
tr3510:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1101
st1101:
	p++
	if p == pe { goto _test_eof1101 }
	fallthrough
case 1101:
// line 66439 "zparse.go"
	switch data[p] {
		case 9: goto st1101
		case 10: goto tr3514
		case 32: goto st1101
		case 40: goto tr3515
		case 41: goto tr3516
		case 59: goto st1480
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr3517 }
	goto st0
tr3517:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1102
st1102:
	p++
	if p == pe { goto _test_eof1102 }
	fallthrough
case 1102:
// line 66459 "zparse.go"
	switch data[p] {
		case 9: goto tr3519
		case 10: goto tr3520
		case 32: goto tr3519
		case 40: goto tr3521
		case 41: goto tr3522
		case 59: goto tr3524
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1102 }
	goto st0
tr3527:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1103
tr3528:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1103
tr3519:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1103
tr3521:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1103
tr3522:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1103
st1103:
	p++
	if p == pe { goto _test_eof1103 }
	fallthrough
case 1103:
// line 66541 "zparse.go"
	switch data[p] {
		case 9: goto st1103
		case 10: goto tr3526
		case 32: goto st1103
		case 40: goto tr3527
		case 41: goto tr3528
		case 59: goto tr3529
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr374 }
	goto st0
tr3526:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1777
tr4589:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1777
tr3520:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1777
st1777:
	p++
	if p == pe { goto _test_eof1777 }
	fallthrough
case 1777:
// line 66587 "zparse.go"
	switch data[p] {
		case 9: goto st1104
		case 10: goto tr3531
		case 32: goto st1104
		case 40: goto tr3532
		case 41: goto tr3533
		case 59: goto tr3534
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5454
	}
	goto st0
tr3532:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1104
tr3533:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1104
tr5085:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1104
tr5087:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1104
tr5088:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1104
tr5106:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1104
tr5108:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1104
tr5109:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1104
st1104:
	p++
	if p == pe { goto _test_eof1104 }
	fallthrough
case 1104:
// line 66757 "zparse.go"
	switch data[p] {
		case 9: goto st1104
		case 10: goto tr3531
		case 32: goto st1104
		case 40: goto tr3532
		case 41: goto tr3533
		case 59: goto tr3534
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1600 }
	goto st0
tr3531:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1778
tr4581:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1778
tr5086:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1778
tr5107:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1778
st1778:
	p++
	if p == pe { goto _test_eof1778 }
	fallthrough
case 1778:
// line 66847 "zparse.go"
	switch data[p] {
		case 9: goto st1104
		case 10: goto tr3531
		case 32: goto st1104
		case 40: goto tr3532
		case 41: goto tr3533
		case 59: goto tr3534
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5455
	}
	goto st0
tr5455:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1105
st1105:
	p++
	if p == pe { goto _test_eof1105 }
	fallthrough
case 1105:
// line 66899 "zparse.go"
	switch data[p] {
		case 9: goto tr3535
		case 10: goto tr3536
		case 32: goto tr3535
		case 40: goto tr3537
		case 41: goto tr3538
		case 59: goto tr3540
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1105
	}
	goto st0
tr3543:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1106
tr3544:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1106
tr3542:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1106
tr3535:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1106
tr3536:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1106
tr3537:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1106
tr3538:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1106
tr4582:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1106
tr4583:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1106
tr4584:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1106
tr4585:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1106
st1106:
	p++
	if p == pe { goto _test_eof1106 }
	fallthrough
case 1106:
// line 67007 "zparse.go"
	switch data[p] {
		case 9: goto st1106
		case 10: goto tr3542
		case 32: goto st1106
		case 40: goto tr3543
		case 41: goto tr3544
		case 43: goto tr386
		case 58: goto tr386
		case 59: goto st1129
		case 61: goto tr386
		case 65: goto tr3547
		case 67: goto tr3548
		case 68: goto tr3549
		case 72: goto tr3550
		case 73: goto tr3551
		case 77: goto tr3552
		case 78: goto tr3553
		case 82: goto tr3554
		case 83: goto tr3555
		case 92: goto tr386
		case 97: goto tr3547
		case 99: goto tr3548
		case 100: goto tr3549
		case 104: goto tr3550
		case 105: goto tr3551
		case 109: goto tr3552
		case 110: goto tr3553
		case 114: goto tr3554
		case 115: goto tr3555
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr386 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr386 }
		} else if data[p] >= 66 {
			goto tr386
		}
	} else {
		goto tr3545
	}
	goto st0
tr3545:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1107
st1107:
	p++
	if p == pe { goto _test_eof1107 }
	fallthrough
case 1107:
// line 67061 "zparse.go"
	switch data[p] {
		case 9: goto tr3556
		case 10: goto tr3557
		case 32: goto tr3556
		case 40: goto tr3558
		case 41: goto tr3559
		case 43: goto st97
		case 58: goto st97
		case 59: goto tr3561
		case 61: goto st97
		case 92: goto st97
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st97 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st97 }
		} else if data[p] >= 65 {
			goto st97
		}
	} else {
		goto st1107
	}
	goto st0
tr3564:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1108
tr3565:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1108
tr3563:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1108
tr3556:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1108
tr3557:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1108
tr3558:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1108
tr3559:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1108
st1108:
	p++
	if p == pe { goto _test_eof1108 }
	fallthrough
case 1108:
// line 67133 "zparse.go"
	switch data[p] {
		case 9: goto st1108
		case 10: goto tr3563
		case 32: goto st1108
		case 40: goto tr3564
		case 41: goto tr3565
		case 43: goto tr398
		case 59: goto st1109
		case 61: goto tr398
		case 65: goto tr3567
		case 67: goto tr3568
		case 68: goto tr1673
		case 72: goto tr3569
		case 73: goto tr3570
		case 77: goto tr1674
		case 78: goto tr3571
		case 82: goto tr1676
		case 83: goto tr1677
		case 92: goto tr398
		case 97: goto tr3567
		case 99: goto tr3568
		case 100: goto tr1673
		case 104: goto tr3569
		case 105: goto tr3570
		case 109: goto tr1674
		case 110: goto tr3571
		case 114: goto tr1676
		case 115: goto tr1677
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto tr398 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto tr398 }
	} else {
		goto tr398
	}
	goto st0
tr3561:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1109
st1109:
	p++
	if p == pe { goto _test_eof1109 }
	fallthrough
case 1109:
// line 67182 "zparse.go"
	if data[p] == 10 { goto tr3563 }
	goto st1109
tr3567:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1110
st1110:
	p++
	if p == pe { goto _test_eof1110 }
	fallthrough
case 1110:
// line 67194 "zparse.go"
	switch data[p] {
		case 9: goto tr1678
		case 10: goto tr1679
		case 32: goto tr1678
		case 40: goto tr1680
		case 41: goto tr1681
		case 43: goto st99
		case 59: goto tr1682
		case 61: goto st99
		case 65: goto st469
		case 78: goto st1111
		case 92: goto st99
		case 97: goto st469
		case 110: goto st1111
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st1111:
	p++
	if p == pe { goto _test_eof1111 }
	fallthrough
case 1111:
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 89: goto st1112
		case 92: goto st99
		case 121: goto st1112
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st1112:
	p++
	if p == pe { goto _test_eof1112 }
	fallthrough
case 1112:
	switch data[p] {
		case 9: goto tr3574
		case 10: goto tr3575
		case 32: goto tr3574
		case 40: goto tr3576
		case 41: goto tr3577
		case 43: goto st99
		case 59: goto tr3578
		case 61: goto st99
		case 92: goto st99
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
tr904:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1113
tr899:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1113
tr3578:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1113
tr3623:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1113
tr3729:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1113
tr3873:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1113
st1113:
	p++
	if p == pe { goto _test_eof1113 }
	fallthrough
case 1113:
// line 67370 "zparse.go"
	if data[p] == 10 { goto tr3580 }
	goto st1113
tr3568:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1114
st1114:
	p++
	if p == pe { goto _test_eof1114 }
	fallthrough
case 1114:
// line 67382 "zparse.go"
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 72: goto st1112
		case 78: goto st473
		case 83: goto st1112
		case 92: goto st99
		case 104: goto st1112
		case 110: goto st473
		case 115: goto st1112
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
tr3569:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1115
st1115:
	p++
	if p == pe { goto _test_eof1115 }
	fallthrough
case 1115:
// line 67417 "zparse.go"
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 83: goto st1112
		case 92: goto st99
		case 115: goto st1112
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
tr3570:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1116
st1116:
	p++
	if p == pe { goto _test_eof1116 }
	fallthrough
case 1116:
// line 67448 "zparse.go"
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 78: goto st1112
		case 92: goto st99
		case 110: goto st1112
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
tr3571:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1117
st1117:
	p++
	if p == pe { goto _test_eof1117 }
	fallthrough
case 1117:
// line 67479 "zparse.go"
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 79: goto st1118
		case 83: goto st1120
		case 92: goto st99
		case 111: goto st1118
		case 115: goto st1120
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st1118:
	p++
	if p == pe { goto _test_eof1118 }
	fallthrough
case 1118:
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 78: goto st1119
		case 92: goto st99
		case 110: goto st1119
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st1119:
	p++
	if p == pe { goto _test_eof1119 }
	fallthrough
case 1119:
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 69: goto st1112
		case 92: goto st99
		case 101: goto st1112
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st1120:
	p++
	if p == pe { goto _test_eof1120 }
	fallthrough
case 1120:
	switch data[p] {
		case 9: goto tr3584
		case 10: goto tr3585
		case 32: goto tr3584
		case 40: goto tr3586
		case 41: goto tr3587
		case 43: goto st99
		case 59: goto tr3588
		case 61: goto st99
		case 92: goto st99
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
tr1676:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1121
st1121:
	p++
	if p == pe { goto _test_eof1121 }
	fallthrough
case 1121:
// line 67588 "zparse.go"
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 82: goto st1122
		case 92: goto st99
		case 114: goto st1122
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st1122:
	p++
	if p == pe { goto _test_eof1122 }
	fallthrough
case 1122:
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 83: goto st1123
		case 92: goto st99
		case 115: goto st1123
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st1123:
	p++
	if p == pe { goto _test_eof1123 }
	fallthrough
case 1123:
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 73: goto st1124
		case 92: goto st99
		case 105: goto st1124
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st1124:
	p++
	if p == pe { goto _test_eof1124 }
	fallthrough
case 1124:
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 71: goto st1125
		case 92: goto st99
		case 103: goto st1125
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st1125:
	p++
	if p == pe { goto _test_eof1125 }
	fallthrough
case 1125:
	switch data[p] {
		case 9: goto tr3593
		case 10: goto tr3594
		case 32: goto tr3593
		case 40: goto tr3595
		case 41: goto tr3596
		case 43: goto st99
		case 59: goto tr3597
		case 61: goto st99
		case 92: goto st99
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
tr1677:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1126
st1126:
	p++
	if p == pe { goto _test_eof1126 }
	fallthrough
case 1126:
// line 67721 "zparse.go"
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 79: goto st1127
		case 92: goto st99
		case 111: goto st1127
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st1127:
	p++
	if p == pe { goto _test_eof1127 }
	fallthrough
case 1127:
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 65: goto st1128
		case 92: goto st99
		case 97: goto st1128
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
st1128:
	p++
	if p == pe { goto _test_eof1128 }
	fallthrough
case 1128:
	switch data[p] {
		case 9: goto tr3600
		case 10: goto tr3601
		case 32: goto tr3600
		case 40: goto tr3602
		case 41: goto tr3603
		case 43: goto st99
		case 59: goto tr3604
		case 61: goto st99
		case 92: goto st99
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
tr3540:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1129
tr4587:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1129
st1129:
	p++
	if p == pe { goto _test_eof1129 }
	fallthrough
case 1129:
// line 67812 "zparse.go"
	if data[p] == 10 { goto tr3542 }
	goto st1129
tr3547:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1130
st1130:
	p++
	if p == pe { goto _test_eof1130 }
	fallthrough
case 1130:
// line 67826 "zparse.go"
	switch data[p] {
		case 9: goto tr1622
		case 10: goto tr1623
		case 32: goto tr1622
		case 40: goto tr1624
		case 41: goto tr1625
		case 43: goto st97
		case 59: goto tr1626
		case 61: goto st97
		case 65: goto st458
		case 78: goto st1131
		case 92: goto st97
		case 97: goto st458
		case 110: goto st1131
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1131:
	p++
	if p == pe { goto _test_eof1131 }
	fallthrough
case 1131:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 89: goto st1132
		case 92: goto st97
		case 121: goto st1132
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1132:
	p++
	if p == pe { goto _test_eof1132 }
	fallthrough
case 1132:
	switch data[p] {
		case 9: goto tr3607
		case 10: goto tr3608
		case 32: goto tr3607
		case 40: goto tr3609
		case 41: goto tr3610
		case 43: goto st97
		case 59: goto tr3611
		case 61: goto st97
		case 92: goto st97
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr3614:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1133
tr3615:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1133
tr3613:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1133
tr3607:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1133
tr3608:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1133
tr3609:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1133
tr3610:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1133
st1133:
	p++
	if p == pe { goto _test_eof1133 }
	fallthrough
case 1133:
// line 67947 "zparse.go"
	switch data[p] {
		case 9: goto st1133
		case 10: goto tr3613
		case 32: goto st1133
		case 40: goto tr3614
		case 41: goto tr3615
		case 43: goto tr398
		case 58: goto tr398
		case 59: goto st1135
		case 61: goto tr398
		case 65: goto tr1671
		case 67: goto tr1672
		case 68: goto tr1673
		case 77: goto tr1674
		case 78: goto tr1675
		case 82: goto tr1676
		case 83: goto tr1677
		case 92: goto tr398
		case 97: goto tr1671
		case 99: goto tr1672
		case 100: goto tr1673
		case 109: goto tr1674
		case 110: goto tr1675
		case 114: goto tr1676
		case 115: goto tr1677
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr398 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr398 }
		} else if data[p] >= 66 {
			goto tr398
		}
	} else {
		goto tr3616
	}
	goto st0
tr3616:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1134
st1134:
	p++
	if p == pe { goto _test_eof1134 }
	fallthrough
case 1134:
// line 67995 "zparse.go"
	switch data[p] {
		case 9: goto tr3618
		case 10: goto tr3619
		case 32: goto tr3618
		case 40: goto tr3620
		case 41: goto tr3621
		case 43: goto st99
		case 58: goto st99
		case 59: goto tr3623
		case 61: goto st99
		case 92: goto st99
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st99 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st99 }
		} else if data[p] >= 65 {
			goto st99
		}
	} else {
		goto st1134
	}
	goto st0
tr3611:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1135
st1135:
	p++
	if p == pe { goto _test_eof1135 }
	fallthrough
case 1135:
// line 68031 "zparse.go"
	if data[p] == 10 { goto tr3613 }
	goto st1135
tr1675:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1136
st1136:
	p++
	if p == pe { goto _test_eof1136 }
	fallthrough
case 1136:
// line 68043 "zparse.go"
	switch data[p] {
		case 9: goto tr400
		case 10: goto tr401
		case 32: goto tr400
		case 40: goto tr402
		case 41: goto tr403
		case 43: goto st99
		case 59: goto tr405
		case 61: goto st99
		case 83: goto st1120
		case 92: goto st99
		case 115: goto st1120
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st99 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st99 }
	} else {
		goto st99
	}
	goto st0
tr3548:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1137
st1137:
	p++
	if p == pe { goto _test_eof1137 }
	fallthrough
case 1137:
// line 68076 "zparse.go"
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 72: goto st1132
		case 78: goto st1138
		case 83: goto st1132
		case 92: goto st97
		case 104: goto st1132
		case 110: goto st1138
		case 115: goto st1132
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1138:
	p++
	if p == pe { goto _test_eof1138 }
	fallthrough
case 1138:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 65: goto st1139
		case 92: goto st97
		case 97: goto st1139
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1139:
	p++
	if p == pe { goto _test_eof1139 }
	fallthrough
case 1139:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 77: goto st1140
		case 92: goto st97
		case 109: goto st1140
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1140:
	p++
	if p == pe { goto _test_eof1140 }
	fallthrough
case 1140:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 69: goto st1141
		case 92: goto st97
		case 101: goto st1141
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1141:
	p++
	if p == pe { goto _test_eof1141 }
	fallthrough
case 1141:
	switch data[p] {
		case 9: goto tr3628
		case 10: goto tr3629
		case 32: goto tr3628
		case 40: goto tr3630
		case 41: goto tr3631
		case 43: goto st97
		case 59: goto tr3632
		case 61: goto st97
		case 92: goto st97
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr3635:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1142
tr3636:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1142
tr3634:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1142
tr3628:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1142
tr3629:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1142
tr3630:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1142
tr3631:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1142
st1142:
	p++
	if p == pe { goto _test_eof1142 }
	fallthrough
case 1142:
// line 68287 "zparse.go"
	switch data[p] {
		case 9: goto st1142
		case 10: goto tr3634
		case 32: goto st1142
		case 40: goto tr3635
		case 41: goto tr3636
		case 43: goto tr3637
		case 59: goto st1144
		case 61: goto tr3637
		case 92: goto tr3637
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr3637 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr3637 }
	} else {
		goto tr3637
	}
	goto st0
tr3637:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1143
st1143:
	p++
	if p == pe { goto _test_eof1143 }
	fallthrough
case 1143:
// line 68316 "zparse.go"
	switch data[p] {
		case 9: goto tr3639
		case 10: goto tr3640
		case 32: goto tr3639
		case 40: goto tr3641
		case 41: goto tr3642
		case 43: goto st1143
		case 59: goto tr3644
		case 61: goto st1143
		case 92: goto st1143
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1143 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1143 }
	} else {
		goto st1143
	}
	goto st0
tr3632:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1144
st1144:
	p++
	if p == pe { goto _test_eof1144 }
	fallthrough
case 1144:
// line 68356 "zparse.go"
	if data[p] == 10 { goto tr3634 }
	goto st1144
tr3549:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1145
tr1615:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1145
st1145:
	p++
	if p == pe { goto _test_eof1145 }
	fallthrough
case 1145:
// line 68374 "zparse.go"
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 78: goto st1146
		case 83: goto st1199
		case 92: goto st97
		case 110: goto st1146
		case 115: goto st1199
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1146:
	p++
	if p == pe { goto _test_eof1146 }
	fallthrough
case 1146:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 83: goto st1147
		case 92: goto st97
		case 115: goto st1147
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1147:
	p++
	if p == pe { goto _test_eof1147 }
	fallthrough
case 1147:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 75: goto st1148
		case 92: goto st97
		case 107: goto st1148
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1148:
	p++
	if p == pe { goto _test_eof1148 }
	fallthrough
case 1148:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 69: goto st1149
		case 92: goto st97
		case 101: goto st1149
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1149:
	p++
	if p == pe { goto _test_eof1149 }
	fallthrough
case 1149:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 89: goto st1150
		case 92: goto st97
		case 121: goto st1150
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1150:
	p++
	if p == pe { goto _test_eof1150 }
	fallthrough
case 1150:
	switch data[p] {
		case 9: goto tr3651
		case 10: goto tr3652
		case 32: goto tr3651
		case 40: goto tr3653
		case 41: goto tr3654
		case 43: goto st97
		case 59: goto tr3655
		case 61: goto st97
		case 92: goto st97
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr3658:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1151
tr3659:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1151
tr3657:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1151
tr3651:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1151
tr3652:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1151
tr3653:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1151
tr3654:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1151
st1151:
	p++
	if p == pe { goto _test_eof1151 }
	fallthrough
case 1151:
// line 68609 "zparse.go"
	switch data[p] {
		case 9: goto st1151
		case 10: goto tr3657
		case 32: goto st1151
		case 40: goto tr3658
		case 41: goto tr3659
		case 43: goto tr398
		case 58: goto tr398
		case 59: goto st1198
		case 61: goto tr398
		case 92: goto tr398
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr398 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr398 }
		} else if data[p] >= 65 {
			goto tr398
		}
	} else {
		goto tr3660
	}
	goto st0
tr3660:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1152
st1152:
	p++
	if p == pe { goto _test_eof1152 }
	fallthrough
case 1152:
// line 68643 "zparse.go"
	switch data[p] {
		case 9: goto tr3662
		case 10: goto tr3663
		case 32: goto tr3662
		case 40: goto tr3664
		case 41: goto tr3665
		case 43: goto st99
		case 58: goto st99
		case 59: goto tr3667
		case 61: goto st99
		case 92: goto st99
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st99 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st99 }
		} else if data[p] >= 65 {
			goto st99
		}
	} else {
		goto st1152
	}
	goto st0
tr3670:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1153
tr3671:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1153
tr3662:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1153
tr3664:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1153
tr3665:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1153
st1153:
	p++
	if p == pe { goto _test_eof1153 }
	fallthrough
case 1153:
// line 68751 "zparse.go"
	switch data[p] {
		case 9: goto st1153
		case 10: goto tr3669
		case 32: goto st1153
		case 40: goto tr3670
		case 41: goto tr3671
		case 59: goto tr3672
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr156 }
	goto st0
tr3669:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1779
tr3794:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1779
tr3663:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1779
st1779:
	p++
	if p == pe { goto _test_eof1779 }
	fallthrough
case 1779:
// line 68801 "zparse.go"
	switch data[p] {
		case 9: goto st1154
		case 10: goto tr3674
		case 32: goto st1154
		case 40: goto tr3675
		case 41: goto tr3676
		case 59: goto tr3677
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5456
	}
	goto st0
tr3675:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1154
tr3676:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1154
st1154:
	p++
	if p == pe { goto _test_eof1154 }
	fallthrough
case 1154:
// line 68837 "zparse.go"
	switch data[p] {
		case 9: goto st1154
		case 10: goto tr3674
		case 32: goto st1154
		case 40: goto tr3675
		case 41: goto tr3676
		case 59: goto tr3677
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr775 }
	goto st0
tr3674:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1780
tr3786:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1780
st1780:
	p++
	if p == pe { goto _test_eof1780 }
	fallthrough
case 1780:
// line 68881 "zparse.go"
	switch data[p] {
		case 9: goto st1154
		case 10: goto tr3674
		case 32: goto st1154
		case 40: goto tr3675
		case 41: goto tr3676
		case 59: goto tr3677
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5457
	}
	goto st0
tr5457:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1155
st1155:
	p++
	if p == pe { goto _test_eof1155 }
	fallthrough
case 1155:
// line 68933 "zparse.go"
	switch data[p] {
		case 9: goto tr3678
		case 10: goto tr3679
		case 32: goto tr3678
		case 40: goto tr3680
		case 41: goto tr3681
		case 59: goto tr3683
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1155
	}
	goto st0
tr3686:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1156
tr3687:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1156
tr3685:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1156
tr3678:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1156
tr3679:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1156
tr3680:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1156
tr3681:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1156
tr3787:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1156
tr3788:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1156
tr3789:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1156
tr3790:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1156
st1156:
	p++
	if p == pe { goto _test_eof1156 }
	fallthrough
case 1156:
// line 69041 "zparse.go"
	switch data[p] {
		case 9: goto st1156
		case 10: goto tr3685
		case 32: goto st1156
		case 40: goto tr3686
		case 41: goto tr3687
		case 59: goto st1194
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr3688 }
	goto st0
tr3688:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1157
st1157:
	p++
	if p == pe { goto _test_eof1157 }
	fallthrough
case 1157:
// line 69081 "zparse.go"
	switch data[p] {
		case 9: goto tr3690
		case 10: goto tr3691
		case 32: goto tr3690
		case 40: goto tr3692
		case 41: goto tr3693
		case 59: goto tr3695
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1157 }
	goto st0
tr3698:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1158
tr3699:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1158
tr3697:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1158
tr3690:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1158
tr3691:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1158
tr3692:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1158
tr3693:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1158
st1158:
	p++
	if p == pe { goto _test_eof1158 }
	fallthrough
case 1158:
// line 69139 "zparse.go"
	switch data[p] {
		case 9: goto st1158
		case 10: goto tr3697
		case 32: goto st1158
		case 40: goto tr3698
		case 41: goto tr3699
		case 43: goto tr180
		case 59: goto st1159
		case 61: goto tr180
		case 65: goto tr3701
		case 67: goto tr3702
		case 68: goto tr3703
		case 72: goto tr3704
		case 73: goto tr3705
		case 77: goto tr3706
		case 78: goto tr3707
		case 82: goto tr3708
		case 83: goto tr3709
		case 92: goto tr180
		case 97: goto tr3701
		case 99: goto tr3702
		case 100: goto tr3703
		case 104: goto tr3704
		case 105: goto tr3705
		case 109: goto tr3706
		case 110: goto tr3707
		case 114: goto tr3708
		case 115: goto tr3709
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto tr180 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto tr180 }
	} else {
		goto tr180
	}
	goto st0
tr3695:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1159
st1159:
	p++
	if p == pe { goto _test_eof1159 }
	fallthrough
case 1159:
// line 69188 "zparse.go"
	if data[p] == 10 { goto tr3697 }
	goto st1159
tr3701:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1160
st1160:
	p++
	if p == pe { goto _test_eof1160 }
	fallthrough
case 1160:
// line 69200 "zparse.go"
	switch data[p] {
		case 9: goto tr3710
		case 10: goto tr3711
		case 32: goto tr3710
		case 40: goto tr3712
		case 41: goto tr3713
		case 43: goto st46
		case 59: goto tr3714
		case 61: goto st46
		case 65: goto st1161
		case 78: goto st1164
		case 92: goto st46
		case 97: goto st1161
		case 110: goto st1164
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1161:
	p++
	if p == pe { goto _test_eof1161 }
	fallthrough
case 1161:
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 65: goto st1162
		case 92: goto st46
		case 97: goto st1162
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1162:
	p++
	if p == pe { goto _test_eof1162 }
	fallthrough
case 1162:
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 65: goto st1163
		case 92: goto st46
		case 97: goto st1163
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1163:
	p++
	if p == pe { goto _test_eof1163 }
	fallthrough
case 1163:
	switch data[p] {
		case 9: goto tr3719
		case 10: goto tr3720
		case 32: goto tr3719
		case 40: goto tr3721
		case 41: goto tr3722
		case 43: goto st46
		case 59: goto tr3723
		case 61: goto st46
		case 92: goto st46
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1164:
	p++
	if p == pe { goto _test_eof1164 }
	fallthrough
case 1164:
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 89: goto st1165
		case 92: goto st46
		case 121: goto st1165
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1165:
	p++
	if p == pe { goto _test_eof1165 }
	fallthrough
case 1165:
	switch data[p] {
		case 9: goto tr3725
		case 10: goto tr3726
		case 32: goto tr3725
		case 40: goto tr3727
		case 41: goto tr3728
		case 43: goto st46
		case 59: goto tr3729
		case 61: goto st46
		case 92: goto st46
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
tr3702:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1166
st1166:
	p++
	if p == pe { goto _test_eof1166 }
	fallthrough
case 1166:
// line 69359 "zparse.go"
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 72: goto st1165
		case 78: goto st1167
		case 83: goto st1165
		case 92: goto st46
		case 104: goto st1165
		case 110: goto st1167
		case 115: goto st1165
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1167:
	p++
	if p == pe { goto _test_eof1167 }
	fallthrough
case 1167:
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 65: goto st1168
		case 92: goto st46
		case 97: goto st1168
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1168:
	p++
	if p == pe { goto _test_eof1168 }
	fallthrough
case 1168:
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 77: goto st1169
		case 92: goto st46
		case 109: goto st1169
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1169:
	p++
	if p == pe { goto _test_eof1169 }
	fallthrough
case 1169:
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 69: goto st1170
		case 92: goto st46
		case 101: goto st1170
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1170:
	p++
	if p == pe { goto _test_eof1170 }
	fallthrough
case 1170:
	switch data[p] {
		case 9: goto tr3734
		case 10: goto tr3735
		case 32: goto tr3734
		case 40: goto tr3736
		case 41: goto tr3737
		case 43: goto st46
		case 59: goto tr3738
		case 61: goto st46
		case 92: goto st46
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
tr3703:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1171
st1171:
	p++
	if p == pe { goto _test_eof1171 }
	fallthrough
case 1171:
// line 69496 "zparse.go"
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 78: goto st1172
		case 83: goto st1177
		case 92: goto st46
		case 110: goto st1172
		case 115: goto st1177
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1172:
	p++
	if p == pe { goto _test_eof1172 }
	fallthrough
case 1172:
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 83: goto st1173
		case 92: goto st46
		case 115: goto st1173
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1173:
	p++
	if p == pe { goto _test_eof1173 }
	fallthrough
case 1173:
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 75: goto st1174
		case 92: goto st46
		case 107: goto st1174
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1174:
	p++
	if p == pe { goto _test_eof1174 }
	fallthrough
case 1174:
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 69: goto st1175
		case 92: goto st46
		case 101: goto st1175
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1175:
	p++
	if p == pe { goto _test_eof1175 }
	fallthrough
case 1175:
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 89: goto st1176
		case 92: goto st46
		case 121: goto st1176
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1176:
	p++
	if p == pe { goto _test_eof1176 }
	fallthrough
case 1176:
	switch data[p] {
		case 9: goto tr3745
		case 10: goto tr3746
		case 32: goto tr3745
		case 40: goto tr3747
		case 41: goto tr3748
		case 43: goto st46
		case 59: goto tr3749
		case 61: goto st46
		case 92: goto st46
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1177:
	p++
	if p == pe { goto _test_eof1177 }
	fallthrough
case 1177:
	switch data[p] {
		case 9: goto tr3750
		case 10: goto tr3751
		case 32: goto tr3750
		case 40: goto tr3752
		case 41: goto tr3753
		case 43: goto st46
		case 59: goto tr3754
		case 61: goto st46
		case 92: goto st46
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
tr3704:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1178
st1178:
	p++
	if p == pe { goto _test_eof1178 }
	fallthrough
case 1178:
// line 69681 "zparse.go"
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 83: goto st1165
		case 92: goto st46
		case 115: goto st1165
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
tr3705:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1179
st1179:
	p++
	if p == pe { goto _test_eof1179 }
	fallthrough
case 1179:
// line 69712 "zparse.go"
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 78: goto st1165
		case 92: goto st46
		case 110: goto st1165
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
tr3706:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1180
st1180:
	p++
	if p == pe { goto _test_eof1180 }
	fallthrough
case 1180:
// line 69743 "zparse.go"
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 88: goto st1181
		case 92: goto st46
		case 120: goto st1181
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1181:
	p++
	if p == pe { goto _test_eof1181 }
	fallthrough
case 1181:
	switch data[p] {
		case 9: goto tr3756
		case 10: goto tr3757
		case 32: goto tr3756
		case 40: goto tr3758
		case 41: goto tr3759
		case 43: goto st46
		case 59: goto tr3760
		case 61: goto st46
		case 92: goto st46
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
tr3707:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1182
st1182:
	p++
	if p == pe { goto _test_eof1182 }
	fallthrough
case 1182:
// line 69798 "zparse.go"
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 79: goto st1183
		case 83: goto st1185
		case 92: goto st46
		case 111: goto st1183
		case 115: goto st1185
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1183:
	p++
	if p == pe { goto _test_eof1183 }
	fallthrough
case 1183:
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 78: goto st1184
		case 92: goto st46
		case 110: goto st1184
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1184:
	p++
	if p == pe { goto _test_eof1184 }
	fallthrough
case 1184:
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 69: goto st1165
		case 92: goto st46
		case 101: goto st1165
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1185:
	p++
	if p == pe { goto _test_eof1185 }
	fallthrough
case 1185:
	switch data[p] {
		case 9: goto tr3764
		case 10: goto tr3765
		case 32: goto tr3764
		case 40: goto tr3766
		case 41: goto tr3767
		case 43: goto st46
		case 59: goto tr3768
		case 61: goto st46
		case 92: goto st46
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
tr3708:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1186
st1186:
	p++
	if p == pe { goto _test_eof1186 }
	fallthrough
case 1186:
// line 69907 "zparse.go"
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 82: goto st1187
		case 92: goto st46
		case 114: goto st1187
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1187:
	p++
	if p == pe { goto _test_eof1187 }
	fallthrough
case 1187:
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 83: goto st1188
		case 92: goto st46
		case 115: goto st1188
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1188:
	p++
	if p == pe { goto _test_eof1188 }
	fallthrough
case 1188:
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 73: goto st1189
		case 92: goto st46
		case 105: goto st1189
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1189:
	p++
	if p == pe { goto _test_eof1189 }
	fallthrough
case 1189:
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 71: goto st1190
		case 92: goto st46
		case 103: goto st1190
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1190:
	p++
	if p == pe { goto _test_eof1190 }
	fallthrough
case 1190:
	switch data[p] {
		case 9: goto tr3773
		case 10: goto tr3774
		case 32: goto tr3773
		case 40: goto tr3775
		case 41: goto tr3776
		case 43: goto st46
		case 59: goto tr3777
		case 61: goto st46
		case 92: goto st46
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
tr3709:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1191
st1191:
	p++
	if p == pe { goto _test_eof1191 }
	fallthrough
case 1191:
// line 70040 "zparse.go"
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 79: goto st1192
		case 92: goto st46
		case 111: goto st1192
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1192:
	p++
	if p == pe { goto _test_eof1192 }
	fallthrough
case 1192:
	switch data[p] {
		case 9: goto tr182
		case 10: goto tr183
		case 32: goto tr182
		case 40: goto tr184
		case 41: goto tr185
		case 43: goto st46
		case 59: goto tr187
		case 61: goto st46
		case 65: goto st1193
		case 92: goto st46
		case 97: goto st1193
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
st1193:
	p++
	if p == pe { goto _test_eof1193 }
	fallthrough
case 1193:
	switch data[p] {
		case 9: goto tr3780
		case 10: goto tr3781
		case 32: goto tr3780
		case 40: goto tr3782
		case 41: goto tr3783
		case 43: goto st46
		case 59: goto tr3784
		case 61: goto st46
		case 92: goto st46
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st46 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st46 }
	} else {
		goto st46
	}
	goto st0
tr3683:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1194
tr3792:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1194
st1194:
	p++
	if p == pe { goto _test_eof1194 }
	fallthrough
case 1194:
// line 70131 "zparse.go"
	if data[p] == 10 { goto tr3685 }
	goto st1194
tr3677:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1195
st1195:
	p++
	if p == pe { goto _test_eof1195 }
	fallthrough
case 1195:
// line 70143 "zparse.go"
	if data[p] == 10 { goto tr3786 }
	goto st1195
tr5456:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1196
st1196:
	p++
	if p == pe { goto _test_eof1196 }
	fallthrough
case 1196:
// line 70155 "zparse.go"
	switch data[p] {
		case 9: goto tr3787
		case 10: goto tr3788
		case 32: goto tr3787
		case 40: goto tr3789
		case 41: goto tr3790
		case 59: goto tr3792
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1196
	}
	goto st0
tr3672:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1197
tr3667:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1197
st1197:
	p++
	if p == pe { goto _test_eof1197 }
	fallthrough
case 1197:
// line 70209 "zparse.go"
	if data[p] == 10 { goto tr3794 }
	goto st1197
tr3655:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1198
st1198:
	p++
	if p == pe { goto _test_eof1198 }
	fallthrough
case 1198:
// line 70232 "zparse.go"
	if data[p] == 10 { goto tr3657 }
	goto st1198
st1199:
	p++
	if p == pe { goto _test_eof1199 }
	fallthrough
case 1199:
	switch data[p] {
		case 9: goto tr3795
		case 10: goto tr3796
		case 32: goto tr3795
		case 40: goto tr3797
		case 41: goto tr3798
		case 43: goto st97
		case 59: goto tr3799
		case 61: goto st97
		case 92: goto st97
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr3802:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1200
tr3803:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1200
tr3801:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1200
tr3795:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1200
tr3796:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1200
tr3797:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1200
tr3798:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1200
st1200:
	p++
	if p == pe { goto _test_eof1200 }
	fallthrough
case 1200:
// line 70342 "zparse.go"
	switch data[p] {
		case 9: goto st1200
		case 10: goto tr3801
		case 32: goto st1200
		case 40: goto tr3802
		case 41: goto tr3803
		case 43: goto tr398
		case 58: goto tr398
		case 59: goto st1247
		case 61: goto tr398
		case 92: goto tr398
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr398 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr398 }
		} else if data[p] >= 65 {
			goto tr398
		}
	} else {
		goto tr3804
	}
	goto st0
tr3804:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1201
st1201:
	p++
	if p == pe { goto _test_eof1201 }
	fallthrough
case 1201:
// line 70376 "zparse.go"
	switch data[p] {
		case 9: goto tr3806
		case 10: goto tr3807
		case 32: goto tr3806
		case 40: goto tr3808
		case 41: goto tr3809
		case 43: goto st99
		case 58: goto st99
		case 59: goto tr3811
		case 61: goto st99
		case 92: goto st99
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st99 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st99 }
		} else if data[p] >= 65 {
			goto st99
		}
	} else {
		goto st1201
	}
	goto st0
tr3814:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1202
tr3815:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1202
tr3806:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1202
tr3808:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1202
tr3809:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1202
st1202:
	p++
	if p == pe { goto _test_eof1202 }
	fallthrough
case 1202:
// line 70484 "zparse.go"
	switch data[p] {
		case 9: goto st1202
		case 10: goto tr3813
		case 32: goto st1202
		case 40: goto tr3814
		case 41: goto tr3815
		case 59: goto tr3816
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr209 }
	goto st0
tr3813:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1781
tr3938:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1781
tr3807:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1781
st1781:
	p++
	if p == pe { goto _test_eof1781 }
	fallthrough
case 1781:
// line 70534 "zparse.go"
	switch data[p] {
		case 9: goto st1203
		case 10: goto tr3818
		case 32: goto st1203
		case 40: goto tr3819
		case 41: goto tr3820
		case 59: goto tr3821
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5458
	}
	goto st0
tr3819:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1203
tr3820:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1203
st1203:
	p++
	if p == pe { goto _test_eof1203 }
	fallthrough
case 1203:
// line 70570 "zparse.go"
	switch data[p] {
		case 9: goto st1203
		case 10: goto tr3818
		case 32: goto st1203
		case 40: goto tr3819
		case 41: goto tr3820
		case 59: goto tr3821
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1062 }
	goto st0
tr3818:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1782
tr3930:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1782
st1782:
	p++
	if p == pe { goto _test_eof1782 }
	fallthrough
case 1782:
// line 70614 "zparse.go"
	switch data[p] {
		case 9: goto st1203
		case 10: goto tr3818
		case 32: goto st1203
		case 40: goto tr3819
		case 41: goto tr3820
		case 59: goto tr3821
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5459
	}
	goto st0
tr5459:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1204
st1204:
	p++
	if p == pe { goto _test_eof1204 }
	fallthrough
case 1204:
// line 70666 "zparse.go"
	switch data[p] {
		case 9: goto tr3822
		case 10: goto tr3823
		case 32: goto tr3822
		case 40: goto tr3824
		case 41: goto tr3825
		case 59: goto tr3827
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1204
	}
	goto st0
tr3830:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1205
tr3831:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1205
tr3829:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1205
tr3822:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1205
tr3823:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1205
tr3824:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1205
tr3825:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1205
tr3931:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1205
tr3932:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1205
tr3933:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1205
tr3934:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1205
st1205:
	p++
	if p == pe { goto _test_eof1205 }
	fallthrough
case 1205:
// line 70774 "zparse.go"
	switch data[p] {
		case 9: goto st1205
		case 10: goto tr3829
		case 32: goto st1205
		case 40: goto tr3830
		case 41: goto tr3831
		case 59: goto st1243
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr3832 }
	goto st0
tr3832:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1206
st1206:
	p++
	if p == pe { goto _test_eof1206 }
	fallthrough
case 1206:
// line 70814 "zparse.go"
	switch data[p] {
		case 9: goto tr3834
		case 10: goto tr3835
		case 32: goto tr3834
		case 40: goto tr3836
		case 41: goto tr3837
		case 59: goto tr3839
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1206 }
	goto st0
tr3842:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1207
tr3843:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1207
tr3841:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1207
tr3834:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1207
tr3835:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1207
tr3836:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1207
tr3837:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1207
st1207:
	p++
	if p == pe { goto _test_eof1207 }
	fallthrough
case 1207:
// line 70872 "zparse.go"
	switch data[p] {
		case 9: goto st1207
		case 10: goto tr3841
		case 32: goto st1207
		case 40: goto tr3842
		case 41: goto tr3843
		case 43: goto tr233
		case 59: goto st1208
		case 61: goto tr233
		case 65: goto tr3845
		case 67: goto tr3846
		case 68: goto tr3847
		case 72: goto tr3848
		case 73: goto tr3849
		case 77: goto tr3850
		case 78: goto tr3851
		case 82: goto tr3852
		case 83: goto tr3853
		case 92: goto tr233
		case 97: goto tr3845
		case 99: goto tr3846
		case 100: goto tr3847
		case 104: goto tr3848
		case 105: goto tr3849
		case 109: goto tr3850
		case 110: goto tr3851
		case 114: goto tr3852
		case 115: goto tr3853
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto tr233 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto tr233 }
	} else {
		goto tr233
	}
	goto st0
tr3839:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1208
st1208:
	p++
	if p == pe { goto _test_eof1208 }
	fallthrough
case 1208:
// line 70921 "zparse.go"
	if data[p] == 10 { goto tr3841 }
	goto st1208
tr3845:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1209
st1209:
	p++
	if p == pe { goto _test_eof1209 }
	fallthrough
case 1209:
// line 70933 "zparse.go"
	switch data[p] {
		case 9: goto tr3854
		case 10: goto tr3855
		case 32: goto tr3854
		case 40: goto tr3856
		case 41: goto tr3857
		case 43: goto st59
		case 59: goto tr3858
		case 61: goto st59
		case 65: goto st1210
		case 78: goto st1213
		case 92: goto st59
		case 97: goto st1210
		case 110: goto st1213
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1210:
	p++
	if p == pe { goto _test_eof1210 }
	fallthrough
case 1210:
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 65: goto st1211
		case 92: goto st59
		case 97: goto st1211
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1211:
	p++
	if p == pe { goto _test_eof1211 }
	fallthrough
case 1211:
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 65: goto st1212
		case 92: goto st59
		case 97: goto st1212
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1212:
	p++
	if p == pe { goto _test_eof1212 }
	fallthrough
case 1212:
	switch data[p] {
		case 9: goto tr3863
		case 10: goto tr3864
		case 32: goto tr3863
		case 40: goto tr3865
		case 41: goto tr3866
		case 43: goto st59
		case 59: goto tr3867
		case 61: goto st59
		case 92: goto st59
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1213:
	p++
	if p == pe { goto _test_eof1213 }
	fallthrough
case 1213:
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 89: goto st1214
		case 92: goto st59
		case 121: goto st1214
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1214:
	p++
	if p == pe { goto _test_eof1214 }
	fallthrough
case 1214:
	switch data[p] {
		case 9: goto tr3869
		case 10: goto tr3870
		case 32: goto tr3869
		case 40: goto tr3871
		case 41: goto tr3872
		case 43: goto st59
		case 59: goto tr3873
		case 61: goto st59
		case 92: goto st59
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
tr3846:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1215
st1215:
	p++
	if p == pe { goto _test_eof1215 }
	fallthrough
case 1215:
// line 71092 "zparse.go"
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 72: goto st1214
		case 78: goto st1216
		case 83: goto st1214
		case 92: goto st59
		case 104: goto st1214
		case 110: goto st1216
		case 115: goto st1214
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1216:
	p++
	if p == pe { goto _test_eof1216 }
	fallthrough
case 1216:
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 65: goto st1217
		case 92: goto st59
		case 97: goto st1217
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1217:
	p++
	if p == pe { goto _test_eof1217 }
	fallthrough
case 1217:
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 77: goto st1218
		case 92: goto st59
		case 109: goto st1218
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1218:
	p++
	if p == pe { goto _test_eof1218 }
	fallthrough
case 1218:
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 69: goto st1219
		case 92: goto st59
		case 101: goto st1219
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1219:
	p++
	if p == pe { goto _test_eof1219 }
	fallthrough
case 1219:
	switch data[p] {
		case 9: goto tr3878
		case 10: goto tr3879
		case 32: goto tr3878
		case 40: goto tr3880
		case 41: goto tr3881
		case 43: goto st59
		case 59: goto tr3882
		case 61: goto st59
		case 92: goto st59
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
tr3847:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1220
st1220:
	p++
	if p == pe { goto _test_eof1220 }
	fallthrough
case 1220:
// line 71229 "zparse.go"
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 78: goto st1221
		case 83: goto st1226
		case 92: goto st59
		case 110: goto st1221
		case 115: goto st1226
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1221:
	p++
	if p == pe { goto _test_eof1221 }
	fallthrough
case 1221:
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 83: goto st1222
		case 92: goto st59
		case 115: goto st1222
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1222:
	p++
	if p == pe { goto _test_eof1222 }
	fallthrough
case 1222:
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 75: goto st1223
		case 92: goto st59
		case 107: goto st1223
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1223:
	p++
	if p == pe { goto _test_eof1223 }
	fallthrough
case 1223:
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 69: goto st1224
		case 92: goto st59
		case 101: goto st1224
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1224:
	p++
	if p == pe { goto _test_eof1224 }
	fallthrough
case 1224:
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 89: goto st1225
		case 92: goto st59
		case 121: goto st1225
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1225:
	p++
	if p == pe { goto _test_eof1225 }
	fallthrough
case 1225:
	switch data[p] {
		case 9: goto tr3889
		case 10: goto tr3890
		case 32: goto tr3889
		case 40: goto tr3891
		case 41: goto tr3892
		case 43: goto st59
		case 59: goto tr3893
		case 61: goto st59
		case 92: goto st59
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1226:
	p++
	if p == pe { goto _test_eof1226 }
	fallthrough
case 1226:
	switch data[p] {
		case 9: goto tr3894
		case 10: goto tr3895
		case 32: goto tr3894
		case 40: goto tr3896
		case 41: goto tr3897
		case 43: goto st59
		case 59: goto tr3898
		case 61: goto st59
		case 92: goto st59
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
tr3848:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1227
st1227:
	p++
	if p == pe { goto _test_eof1227 }
	fallthrough
case 1227:
// line 71414 "zparse.go"
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 83: goto st1214
		case 92: goto st59
		case 115: goto st1214
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
tr3849:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1228
st1228:
	p++
	if p == pe { goto _test_eof1228 }
	fallthrough
case 1228:
// line 71445 "zparse.go"
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 78: goto st1214
		case 92: goto st59
		case 110: goto st1214
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
tr3850:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1229
st1229:
	p++
	if p == pe { goto _test_eof1229 }
	fallthrough
case 1229:
// line 71476 "zparse.go"
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 88: goto st1230
		case 92: goto st59
		case 120: goto st1230
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1230:
	p++
	if p == pe { goto _test_eof1230 }
	fallthrough
case 1230:
	switch data[p] {
		case 9: goto tr3900
		case 10: goto tr3901
		case 32: goto tr3900
		case 40: goto tr3902
		case 41: goto tr3903
		case 43: goto st59
		case 59: goto tr3904
		case 61: goto st59
		case 92: goto st59
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
tr3851:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1231
st1231:
	p++
	if p == pe { goto _test_eof1231 }
	fallthrough
case 1231:
// line 71531 "zparse.go"
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 79: goto st1232
		case 83: goto st1234
		case 92: goto st59
		case 111: goto st1232
		case 115: goto st1234
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1232:
	p++
	if p == pe { goto _test_eof1232 }
	fallthrough
case 1232:
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 78: goto st1233
		case 92: goto st59
		case 110: goto st1233
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1233:
	p++
	if p == pe { goto _test_eof1233 }
	fallthrough
case 1233:
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 69: goto st1214
		case 92: goto st59
		case 101: goto st1214
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1234:
	p++
	if p == pe { goto _test_eof1234 }
	fallthrough
case 1234:
	switch data[p] {
		case 9: goto tr3908
		case 10: goto tr3909
		case 32: goto tr3908
		case 40: goto tr3910
		case 41: goto tr3911
		case 43: goto st59
		case 59: goto tr3912
		case 61: goto st59
		case 92: goto st59
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
tr3852:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1235
st1235:
	p++
	if p == pe { goto _test_eof1235 }
	fallthrough
case 1235:
// line 71640 "zparse.go"
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 82: goto st1236
		case 92: goto st59
		case 114: goto st1236
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1236:
	p++
	if p == pe { goto _test_eof1236 }
	fallthrough
case 1236:
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 83: goto st1237
		case 92: goto st59
		case 115: goto st1237
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1237:
	p++
	if p == pe { goto _test_eof1237 }
	fallthrough
case 1237:
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 73: goto st1238
		case 92: goto st59
		case 105: goto st1238
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1238:
	p++
	if p == pe { goto _test_eof1238 }
	fallthrough
case 1238:
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 71: goto st1239
		case 92: goto st59
		case 103: goto st1239
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1239:
	p++
	if p == pe { goto _test_eof1239 }
	fallthrough
case 1239:
	switch data[p] {
		case 9: goto tr3917
		case 10: goto tr3918
		case 32: goto tr3917
		case 40: goto tr3919
		case 41: goto tr3920
		case 43: goto st59
		case 59: goto tr3921
		case 61: goto st59
		case 92: goto st59
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
tr3853:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1240
st1240:
	p++
	if p == pe { goto _test_eof1240 }
	fallthrough
case 1240:
// line 71773 "zparse.go"
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 79: goto st1241
		case 92: goto st59
		case 111: goto st1241
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1241:
	p++
	if p == pe { goto _test_eof1241 }
	fallthrough
case 1241:
	switch data[p] {
		case 9: goto tr235
		case 10: goto tr236
		case 32: goto tr235
		case 40: goto tr237
		case 41: goto tr238
		case 43: goto st59
		case 59: goto tr240
		case 61: goto st59
		case 65: goto st1242
		case 92: goto st59
		case 97: goto st1242
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
st1242:
	p++
	if p == pe { goto _test_eof1242 }
	fallthrough
case 1242:
	switch data[p] {
		case 9: goto tr3924
		case 10: goto tr3925
		case 32: goto tr3924
		case 40: goto tr3926
		case 41: goto tr3927
		case 43: goto st59
		case 59: goto tr3928
		case 61: goto st59
		case 92: goto st59
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st59 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st59 }
	} else {
		goto st59
	}
	goto st0
tr3827:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1243
tr3936:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1243
st1243:
	p++
	if p == pe { goto _test_eof1243 }
	fallthrough
case 1243:
// line 71864 "zparse.go"
	if data[p] == 10 { goto tr3829 }
	goto st1243
tr3821:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1244
st1244:
	p++
	if p == pe { goto _test_eof1244 }
	fallthrough
case 1244:
// line 71876 "zparse.go"
	if data[p] == 10 { goto tr3930 }
	goto st1244
tr5458:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1245
st1245:
	p++
	if p == pe { goto _test_eof1245 }
	fallthrough
case 1245:
// line 71888 "zparse.go"
	switch data[p] {
		case 9: goto tr3931
		case 10: goto tr3932
		case 32: goto tr3931
		case 40: goto tr3933
		case 41: goto tr3934
		case 59: goto tr3936
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1245
	}
	goto st0
tr3816:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1246
tr3811:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1246
st1246:
	p++
	if p == pe { goto _test_eof1246 }
	fallthrough
case 1246:
// line 71942 "zparse.go"
	if data[p] == 10 { goto tr3938 }
	goto st1246
tr3799:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1247
st1247:
	p++
	if p == pe { goto _test_eof1247 }
	fallthrough
case 1247:
// line 71965 "zparse.go"
	if data[p] == 10 { goto tr3801 }
	goto st1247
tr3550:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1248
st1248:
	p++
	if p == pe { goto _test_eof1248 }
	fallthrough
case 1248:
// line 71979 "zparse.go"
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 83: goto st1132
		case 92: goto st97
		case 115: goto st1132
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr3551:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1249
st1249:
	p++
	if p == pe { goto _test_eof1249 }
	fallthrough
case 1249:
// line 72012 "zparse.go"
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 78: goto st1132
		case 92: goto st97
		case 110: goto st1132
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr3552:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1250
tr1618:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1250
st1250:
	p++
	if p == pe { goto _test_eof1250 }
	fallthrough
case 1250:
// line 72049 "zparse.go"
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 88: goto st1251
		case 92: goto st97
		case 120: goto st1251
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1251:
	p++
	if p == pe { goto _test_eof1251 }
	fallthrough
case 1251:
	switch data[p] {
		case 9: goto tr3940
		case 10: goto tr3941
		case 32: goto tr3940
		case 40: goto tr3942
		case 41: goto tr3943
		case 43: goto st97
		case 59: goto tr3944
		case 61: goto st97
		case 92: goto st97
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr3947:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1252
tr3948:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1252
tr3946:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1252
tr3940:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1252
tr3941:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1252
tr3942:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1252
tr3943:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1252
st1252:
	p++
	if p == pe { goto _test_eof1252 }
	fallthrough
case 1252:
// line 72178 "zparse.go"
	switch data[p] {
		case 9: goto st1252
		case 10: goto tr3946
		case 32: goto st1252
		case 40: goto tr3947
		case 41: goto tr3948
		case 43: goto tr398
		case 58: goto tr398
		case 59: goto st1294
		case 61: goto tr398
		case 92: goto tr398
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr398 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr398 }
		} else if data[p] >= 65 {
			goto tr398
		}
	} else {
		goto tr3949
	}
	goto st0
tr3949:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1253
st1253:
	p++
	if p == pe { goto _test_eof1253 }
	fallthrough
case 1253:
// line 72212 "zparse.go"
	switch data[p] {
		case 9: goto tr3951
		case 10: goto tr3952
		case 32: goto tr3951
		case 40: goto tr3953
		case 41: goto tr3954
		case 43: goto st99
		case 58: goto st99
		case 59: goto tr3956
		case 61: goto st99
		case 92: goto st99
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st99 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st99 }
		} else if data[p] >= 65 {
			goto st99
		}
	} else {
		goto st1253
	}
	goto st0
tr3959:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1254
tr3960:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1254
tr3951:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1254
tr3953:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1254
tr3954:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1254
st1254:
	p++
	if p == pe { goto _test_eof1254 }
	fallthrough
case 1254:
// line 72320 "zparse.go"
	switch data[p] {
		case 9: goto st1254
		case 10: goto tr3958
		case 32: goto st1254
		case 40: goto tr3959
		case 41: goto tr3960
		case 43: goto tr263
		case 59: goto tr3961
		case 61: goto tr263
		case 92: goto tr263
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr263 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr263 }
	} else {
		goto tr263
	}
	goto st0
tr3958:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1783
tr4057:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1783
tr3952:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1783
st1783:
	p++
	if p == pe { goto _test_eof1783 }
	fallthrough
case 1783:
// line 72379 "zparse.go"
	switch data[p] {
		case 9: goto st1255
		case 10: goto tr3963
		case 32: goto st1255
		case 40: goto tr3964
		case 41: goto tr3965
		case 43: goto tr263
		case 47: goto tr263
		case 58: goto tr263
		case 59: goto tr3966
		case 61: goto tr263
		case 92: goto tr5460
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto tr5460 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr5460 }
	} else {
		goto tr5460
	}
	goto st0
tr3964:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1255
tr3965:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1255
st1255:
	p++
	if p == pe { goto _test_eof1255 }
	fallthrough
case 1255:
// line 72415 "zparse.go"
	switch data[p] {
		case 9: goto st1255
		case 10: goto tr3963
		case 32: goto st1255
		case 40: goto tr3964
		case 41: goto tr3965
		case 43: goto tr263
		case 58: goto tr263
		case 59: goto tr3966
		case 61: goto tr263
		case 65: goto tr1746
		case 67: goto tr1747
		case 68: goto tr1748
		case 72: goto tr1749
		case 73: goto tr1750
		case 77: goto tr1751
		case 78: goto tr1752
		case 82: goto tr1753
		case 83: goto tr1754
		case 92: goto tr263
		case 97: goto tr1746
		case 99: goto tr1747
		case 100: goto tr1748
		case 104: goto tr1749
		case 105: goto tr1750
		case 109: goto tr1751
		case 110: goto tr1752
		case 114: goto tr1753
		case 115: goto tr1754
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr263 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr263 }
		} else if data[p] >= 66 {
			goto tr263
		}
	} else {
		goto tr1744
	}
	goto st0
tr3963:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1784
tr3980:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1784
st1784:
	p++
	if p == pe { goto _test_eof1784 }
	fallthrough
case 1784:
// line 72473 "zparse.go"
	switch data[p] {
		case 9: goto st1255
		case 10: goto tr3963
		case 32: goto st1255
		case 40: goto tr3964
		case 41: goto tr3965
		case 43: goto tr263
		case 47: goto tr263
		case 58: goto tr263
		case 59: goto tr3966
		case 61: goto tr263
		case 65: goto tr5462
		case 67: goto tr5463
		case 68: goto tr5464
		case 72: goto tr5465
		case 73: goto tr5466
		case 77: goto tr5467
		case 78: goto tr5468
		case 82: goto tr5469
		case 83: goto tr5470
		case 92: goto tr5460
		case 95: goto st2
		case 97: goto tr5462
		case 99: goto tr5463
		case 100: goto tr5464
		case 104: goto tr5465
		case 105: goto tr5466
		case 109: goto tr5467
		case 110: goto tr5468
		case 114: goto tr5469
		case 115: goto tr5470
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5460 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr5460 }
		} else if data[p] >= 66 {
			goto tr5460
		}
	} else {
		goto tr5461
	}
	goto st0
tr5460:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1256
st1256:
	p++
	if p == pe { goto _test_eof1256 }
	fallthrough
case 1256:
// line 72527 "zparse.go"
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 92: goto st1256
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
tr5461:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1257
st1257:
	p++
	if p == pe { goto _test_eof1257 }
	fallthrough
case 1257:
// line 72561 "zparse.go"
	switch data[p] {
		case 9: goto tr3973
		case 10: goto tr3974
		case 32: goto tr3973
		case 40: goto tr3975
		case 41: goto tr3976
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3978
		case 61: goto st69
		case 92: goto st1256
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st1256 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st1256 }
		} else if data[p] >= 65 {
			goto st1256
		}
	} else {
		goto st1257
	}
	goto st0
tr3966:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1258
st1258:
	p++
	if p == pe { goto _test_eof1258 }
	fallthrough
case 1258:
// line 72597 "zparse.go"
	if data[p] == 10 { goto tr3980 }
	goto st1258
tr5462:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1259
st1259:
	p++
	if p == pe { goto _test_eof1259 }
	fallthrough
case 1259:
// line 72611 "zparse.go"
	switch data[p] {
		case 9: goto tr3981
		case 10: goto tr3982
		case 32: goto tr3981
		case 40: goto tr3983
		case 41: goto tr3984
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3985
		case 61: goto st69
		case 65: goto st1260
		case 78: goto st1263
		case 92: goto st1256
		case 95: goto st2
		case 97: goto st1260
		case 110: goto st1263
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1260:
	p++
	if p == pe { goto _test_eof1260 }
	fallthrough
case 1260:
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 65: goto st1261
		case 92: goto st1256
		case 95: goto st2
		case 97: goto st1261
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1261:
	p++
	if p == pe { goto _test_eof1261 }
	fallthrough
case 1261:
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 65: goto st1262
		case 92: goto st1256
		case 95: goto st2
		case 97: goto st1262
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1262:
	p++
	if p == pe { goto _test_eof1262 }
	fallthrough
case 1262:
	switch data[p] {
		case 9: goto tr3990
		case 10: goto tr3991
		case 32: goto tr3990
		case 40: goto tr3992
		case 41: goto tr3993
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3994
		case 61: goto st69
		case 92: goto st1256
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1263:
	p++
	if p == pe { goto _test_eof1263 }
	fallthrough
case 1263:
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 89: goto st1264
		case 92: goto st1256
		case 95: goto st2
		case 121: goto st1264
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1264:
	p++
	if p == pe { goto _test_eof1264 }
	fallthrough
case 1264:
	switch data[p] {
		case 9: goto tr3996
		case 10: goto tr3997
		case 32: goto tr3996
		case 40: goto tr3998
		case 41: goto tr3999
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr4000
		case 61: goto st69
		case 92: goto st1256
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
tr5463:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1265
st1265:
	p++
	if p == pe { goto _test_eof1265 }
	fallthrough
case 1265:
// line 72790 "zparse.go"
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 72: goto st1264
		case 78: goto st1266
		case 83: goto st1264
		case 92: goto st1256
		case 95: goto st2
		case 104: goto st1264
		case 110: goto st1266
		case 115: goto st1264
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1266:
	p++
	if p == pe { goto _test_eof1266 }
	fallthrough
case 1266:
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 65: goto st1267
		case 92: goto st1256
		case 95: goto st2
		case 97: goto st1267
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1267:
	p++
	if p == pe { goto _test_eof1267 }
	fallthrough
case 1267:
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 77: goto st1268
		case 92: goto st1256
		case 95: goto st2
		case 109: goto st1268
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1268:
	p++
	if p == pe { goto _test_eof1268 }
	fallthrough
case 1268:
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 69: goto st1269
		case 92: goto st1256
		case 95: goto st2
		case 101: goto st1269
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1269:
	p++
	if p == pe { goto _test_eof1269 }
	fallthrough
case 1269:
	switch data[p] {
		case 9: goto tr4005
		case 10: goto tr4006
		case 32: goto tr4005
		case 40: goto tr4007
		case 41: goto tr4008
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr4009
		case 61: goto st69
		case 92: goto st1256
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
tr5464:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1270
st1270:
	p++
	if p == pe { goto _test_eof1270 }
	fallthrough
case 1270:
// line 72944 "zparse.go"
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 78: goto st1271
		case 83: goto st1276
		case 92: goto st1256
		case 95: goto st2
		case 110: goto st1271
		case 115: goto st1276
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1271:
	p++
	if p == pe { goto _test_eof1271 }
	fallthrough
case 1271:
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 83: goto st1272
		case 92: goto st1256
		case 95: goto st2
		case 115: goto st1272
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1272:
	p++
	if p == pe { goto _test_eof1272 }
	fallthrough
case 1272:
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 75: goto st1273
		case 92: goto st1256
		case 95: goto st2
		case 107: goto st1273
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1273:
	p++
	if p == pe { goto _test_eof1273 }
	fallthrough
case 1273:
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 69: goto st1274
		case 92: goto st1256
		case 95: goto st2
		case 101: goto st1274
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1274:
	p++
	if p == pe { goto _test_eof1274 }
	fallthrough
case 1274:
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 89: goto st1275
		case 92: goto st1256
		case 95: goto st2
		case 121: goto st1275
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1275:
	p++
	if p == pe { goto _test_eof1275 }
	fallthrough
case 1275:
	switch data[p] {
		case 9: goto tr4016
		case 10: goto tr4017
		case 32: goto tr4016
		case 40: goto tr4018
		case 41: goto tr4019
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr4020
		case 61: goto st69
		case 92: goto st1256
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1276:
	p++
	if p == pe { goto _test_eof1276 }
	fallthrough
case 1276:
	switch data[p] {
		case 9: goto tr4021
		case 10: goto tr4022
		case 32: goto tr4021
		case 40: goto tr4023
		case 41: goto tr4024
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr4025
		case 61: goto st69
		case 92: goto st1256
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
tr5465:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1277
st1277:
	p++
	if p == pe { goto _test_eof1277 }
	fallthrough
case 1277:
// line 73152 "zparse.go"
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 83: goto st1264
		case 92: goto st1256
		case 95: goto st2
		case 115: goto st1264
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
tr5466:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1278
st1278:
	p++
	if p == pe { goto _test_eof1278 }
	fallthrough
case 1278:
// line 73188 "zparse.go"
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 78: goto st1264
		case 92: goto st1256
		case 95: goto st2
		case 110: goto st1264
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
tr5467:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1279
st1279:
	p++
	if p == pe { goto _test_eof1279 }
	fallthrough
case 1279:
// line 73224 "zparse.go"
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 88: goto st1280
		case 92: goto st1256
		case 95: goto st2
		case 120: goto st1280
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1280:
	p++
	if p == pe { goto _test_eof1280 }
	fallthrough
case 1280:
	switch data[p] {
		case 9: goto tr4027
		case 10: goto tr4028
		case 32: goto tr4027
		case 40: goto tr4029
		case 41: goto tr4030
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr4031
		case 61: goto st69
		case 92: goto st1256
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
tr5468:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1281
st1281:
	p++
	if p == pe { goto _test_eof1281 }
	fallthrough
case 1281:
// line 73287 "zparse.go"
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 79: goto st1282
		case 83: goto st1284
		case 92: goto st1256
		case 95: goto st2
		case 111: goto st1282
		case 115: goto st1284
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1282:
	p++
	if p == pe { goto _test_eof1282 }
	fallthrough
case 1282:
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 78: goto st1283
		case 92: goto st1256
		case 95: goto st2
		case 110: goto st1283
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1283:
	p++
	if p == pe { goto _test_eof1283 }
	fallthrough
case 1283:
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 69: goto st1264
		case 92: goto st1256
		case 95: goto st2
		case 101: goto st1264
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1284:
	p++
	if p == pe { goto _test_eof1284 }
	fallthrough
case 1284:
	switch data[p] {
		case 9: goto tr4035
		case 10: goto tr4036
		case 32: goto tr4035
		case 40: goto tr4037
		case 41: goto tr4038
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr4039
		case 61: goto st69
		case 92: goto st1256
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
tr5469:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1285
st1285:
	p++
	if p == pe { goto _test_eof1285 }
	fallthrough
case 1285:
// line 73410 "zparse.go"
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 82: goto st1286
		case 92: goto st1256
		case 95: goto st2
		case 114: goto st1286
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1286:
	p++
	if p == pe { goto _test_eof1286 }
	fallthrough
case 1286:
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 83: goto st1287
		case 92: goto st1256
		case 95: goto st2
		case 115: goto st1287
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1287:
	p++
	if p == pe { goto _test_eof1287 }
	fallthrough
case 1287:
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 73: goto st1288
		case 92: goto st1256
		case 95: goto st2
		case 105: goto st1288
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1288:
	p++
	if p == pe { goto _test_eof1288 }
	fallthrough
case 1288:
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 71: goto st1289
		case 92: goto st1256
		case 95: goto st2
		case 103: goto st1289
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1289:
	p++
	if p == pe { goto _test_eof1289 }
	fallthrough
case 1289:
	switch data[p] {
		case 9: goto tr4044
		case 10: goto tr4045
		case 32: goto tr4044
		case 40: goto tr4046
		case 41: goto tr4047
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr4048
		case 61: goto st69
		case 92: goto st1256
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
tr5470:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1290
st1290:
	p++
	if p == pe { goto _test_eof1290 }
	fallthrough
case 1290:
// line 73560 "zparse.go"
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 79: goto st1291
		case 92: goto st1256
		case 95: goto st2
		case 111: goto st1291
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1291:
	p++
	if p == pe { goto _test_eof1291 }
	fallthrough
case 1291:
	switch data[p] {
		case 9: goto tr3967
		case 10: goto tr3968
		case 32: goto tr3967
		case 40: goto tr3969
		case 41: goto tr3970
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr3972
		case 61: goto st69
		case 65: goto st1292
		case 92: goto st1256
		case 95: goto st2
		case 97: goto st1292
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
st1292:
	p++
	if p == pe { goto _test_eof1292 }
	fallthrough
case 1292:
	switch data[p] {
		case 9: goto tr4051
		case 10: goto tr4052
		case 32: goto tr4051
		case 40: goto tr4053
		case 41: goto tr4054
		case 43: goto st69
		case 47: goto st69
		case 58: goto st69
		case 59: goto tr4055
		case 61: goto st69
		case 92: goto st1256
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1256 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1256 }
	} else {
		goto st1256
	}
	goto st0
tr3961:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1293
tr3956:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1293
st1293:
	p++
	if p == pe { goto _test_eof1293 }
	fallthrough
case 1293:
// line 73672 "zparse.go"
	if data[p] == 10 { goto tr4057 }
	goto st1293
tr3944:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1294
st1294:
	p++
	if p == pe { goto _test_eof1294 }
	fallthrough
case 1294:
// line 73695 "zparse.go"
	if data[p] == 10 { goto tr3946 }
	goto st1294
tr3553:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1295
st1295:
	p++
	if p == pe { goto _test_eof1295 }
	fallthrough
case 1295:
// line 73709 "zparse.go"
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 79: goto st1296
		case 83: goto st1298
		case 92: goto st97
		case 111: goto st1296
		case 115: goto st1298
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1296:
	p++
	if p == pe { goto _test_eof1296 }
	fallthrough
case 1296:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 78: goto st1297
		case 92: goto st97
		case 110: goto st1297
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1297:
	p++
	if p == pe { goto _test_eof1297 }
	fallthrough
case 1297:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 69: goto st1132
		case 92: goto st97
		case 101: goto st1132
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1298:
	p++
	if p == pe { goto _test_eof1298 }
	fallthrough
case 1298:
	switch data[p] {
		case 9: goto tr4061
		case 10: goto tr4062
		case 32: goto tr4061
		case 40: goto tr4063
		case 41: goto tr4064
		case 43: goto st97
		case 59: goto tr4065
		case 61: goto st97
		case 92: goto st97
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr4068:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1299
tr4069:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1299
tr4067:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1299
tr4061:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1299
tr4062:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1299
tr4063:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1299
tr4064:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1299
st1299:
	p++
	if p == pe { goto _test_eof1299 }
	fallthrough
case 1299:
// line 73892 "zparse.go"
	switch data[p] {
		case 9: goto st1299
		case 10: goto tr4067
		case 32: goto st1299
		case 40: goto tr4068
		case 41: goto tr4069
		case 43: goto tr4070
		case 59: goto st1301
		case 61: goto tr4070
		case 92: goto tr4070
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr4070 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr4070 }
	} else {
		goto tr4070
	}
	goto st0
tr4070:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1300
st1300:
	p++
	if p == pe { goto _test_eof1300 }
	fallthrough
case 1300:
// line 73921 "zparse.go"
	switch data[p] {
		case 9: goto tr4072
		case 10: goto tr4073
		case 32: goto tr4072
		case 40: goto tr4074
		case 41: goto tr4075
		case 43: goto st1300
		case 59: goto tr4077
		case 61: goto st1300
		case 92: goto st1300
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1300 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1300 }
	} else {
		goto st1300
	}
	goto st0
tr4065:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1301
st1301:
	p++
	if p == pe { goto _test_eof1301 }
	fallthrough
case 1301:
// line 73961 "zparse.go"
	if data[p] == 10 { goto tr4067 }
	goto st1301
tr3554:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1302
tr1620:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1302
st1302:
	p++
	if p == pe { goto _test_eof1302 }
	fallthrough
case 1302:
// line 73979 "zparse.go"
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 82: goto st1303
		case 92: goto st97
		case 114: goto st1303
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1303:
	p++
	if p == pe { goto _test_eof1303 }
	fallthrough
case 1303:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 83: goto st1304
		case 92: goto st97
		case 115: goto st1304
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1304:
	p++
	if p == pe { goto _test_eof1304 }
	fallthrough
case 1304:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 73: goto st1305
		case 92: goto st97
		case 105: goto st1305
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1305:
	p++
	if p == pe { goto _test_eof1305 }
	fallthrough
case 1305:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 71: goto st1306
		case 92: goto st97
		case 103: goto st1306
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1306:
	p++
	if p == pe { goto _test_eof1306 }
	fallthrough
case 1306:
	switch data[p] {
		case 9: goto tr4082
		case 10: goto tr4083
		case 32: goto tr4082
		case 40: goto tr4084
		case 41: goto tr4085
		case 43: goto st97
		case 59: goto tr4086
		case 61: goto st97
		case 92: goto st97
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr4089:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1307
tr4090:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1307
tr4088:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1307
tr4082:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1307
tr4083:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1307
tr4084:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1307
tr4085:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1307
st1307:
	p++
	if p == pe { goto _test_eof1307 }
	fallthrough
case 1307:
// line 74186 "zparse.go"
	switch data[p] {
		case 9: goto st1307
		case 10: goto tr4088
		case 32: goto st1307
		case 40: goto tr4089
		case 41: goto tr4090
		case 43: goto tr398
		case 58: goto tr398
		case 59: goto st1320
		case 61: goto tr398
		case 92: goto tr398
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr398 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr398 }
		} else if data[p] >= 65 {
			goto tr398
		}
	} else {
		goto tr4091
	}
	goto st0
tr4091:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1308
st1308:
	p++
	if p == pe { goto _test_eof1308 }
	fallthrough
case 1308:
// line 74220 "zparse.go"
	switch data[p] {
		case 9: goto tr4093
		case 10: goto tr4094
		case 32: goto tr4093
		case 40: goto tr4095
		case 41: goto tr4096
		case 43: goto st99
		case 58: goto st99
		case 59: goto tr4098
		case 61: goto st99
		case 92: goto st99
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st99 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st99 }
		} else if data[p] >= 65 {
			goto st99
		}
	} else {
		goto st1308
	}
	goto st0
tr4101:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1309
tr4102:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1309
tr4093:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1309
tr4095:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1309
tr4096:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1309
st1309:
	p++
	if p == pe { goto _test_eof1309 }
	fallthrough
case 1309:
// line 74328 "zparse.go"
	switch data[p] {
		case 9: goto st1309
		case 10: goto tr4100
		case 32: goto st1309
		case 40: goto tr4101
		case 41: goto tr4102
		case 59: goto tr4103
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr314 }
	goto st0
tr4100:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1785
tr4141:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1785
tr4094:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1785
st1785:
	p++
	if p == pe { goto _test_eof1785 }
	fallthrough
case 1785:
// line 74378 "zparse.go"
	switch data[p] {
		case 9: goto st1310
		case 10: goto tr4105
		case 32: goto st1310
		case 40: goto tr4106
		case 41: goto tr4107
		case 59: goto tr4108
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5471
	}
	goto st0
tr4106:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1310
tr4107:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1310
st1310:
	p++
	if p == pe { goto _test_eof1310 }
	fallthrough
case 1310:
// line 74414 "zparse.go"
	switch data[p] {
		case 9: goto st1310
		case 10: goto tr4105
		case 32: goto st1310
		case 40: goto tr4106
		case 41: goto tr4107
		case 59: goto tr4108
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr1918 }
	goto st0
tr4105:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1786
tr4133:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1786
st1786:
	p++
	if p == pe { goto _test_eof1786 }
	fallthrough
case 1786:
// line 74458 "zparse.go"
	switch data[p] {
		case 9: goto st1310
		case 10: goto tr4105
		case 32: goto st1310
		case 40: goto tr4106
		case 41: goto tr4107
		case 59: goto tr4108
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5472
	}
	goto st0
tr5472:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1311
st1311:
	p++
	if p == pe { goto _test_eof1311 }
	fallthrough
case 1311:
// line 74510 "zparse.go"
	switch data[p] {
		case 9: goto tr4109
		case 10: goto tr4110
		case 32: goto tr4109
		case 40: goto tr4111
		case 41: goto tr4112
		case 59: goto tr4114
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1311
	}
	goto st0
tr4117:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1312
tr4118:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1312
tr4116:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1312
tr4109:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1312
tr4110:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1312
tr4111:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1312
tr4112:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1312
tr4134:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1312
tr4135:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1312
tr4136:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1312
tr4137:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1312
st1312:
	p++
	if p == pe { goto _test_eof1312 }
	fallthrough
case 1312:
// line 74618 "zparse.go"
	switch data[p] {
		case 9: goto st1312
		case 10: goto tr4116
		case 32: goto st1312
		case 40: goto tr4117
		case 41: goto tr4118
		case 59: goto st1316
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4119 }
	goto st0
tr4119:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1313
st1313:
	p++
	if p == pe { goto _test_eof1313 }
	fallthrough
case 1313:
// line 74658 "zparse.go"
	switch data[p] {
		case 9: goto tr4121
		case 10: goto tr4122
		case 32: goto tr4121
		case 40: goto tr4123
		case 41: goto tr4124
		case 59: goto tr4126
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1313 }
	goto st0
tr4129:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1314
tr4130:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1314
tr4128:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1314
tr4121:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1314
tr4122:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1314
tr4123:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1314
tr4124:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1314
st1314:
	p++
	if p == pe { goto _test_eof1314 }
	fallthrough
case 1314:
// line 74716 "zparse.go"
	switch data[p] {
		case 9: goto st1314
		case 10: goto tr4128
		case 32: goto st1314
		case 40: goto tr4129
		case 41: goto tr4130
		case 59: goto st1315
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr338 }
	goto st0
tr4126:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1315
st1315:
	p++
	if p == pe { goto _test_eof1315 }
	fallthrough
case 1315:
// line 74756 "zparse.go"
	if data[p] == 10 { goto tr4128 }
	goto st1315
tr4114:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1316
tr4139:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1316
st1316:
	p++
	if p == pe { goto _test_eof1316 }
	fallthrough
case 1316:
// line 74778 "zparse.go"
	if data[p] == 10 { goto tr4116 }
	goto st1316
tr4108:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1317
st1317:
	p++
	if p == pe { goto _test_eof1317 }
	fallthrough
case 1317:
// line 74790 "zparse.go"
	if data[p] == 10 { goto tr4133 }
	goto st1317
tr5471:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1318
st1318:
	p++
	if p == pe { goto _test_eof1318 }
	fallthrough
case 1318:
// line 74802 "zparse.go"
	switch data[p] {
		case 9: goto tr4134
		case 10: goto tr4135
		case 32: goto tr4134
		case 40: goto tr4136
		case 41: goto tr4137
		case 59: goto tr4139
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1318
	}
	goto st0
tr4103:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1319
tr4098:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1319
st1319:
	p++
	if p == pe { goto _test_eof1319 }
	fallthrough
case 1319:
// line 74856 "zparse.go"
	if data[p] == 10 { goto tr4141 }
	goto st1319
tr4086:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1320
st1320:
	p++
	if p == pe { goto _test_eof1320 }
	fallthrough
case 1320:
// line 74879 "zparse.go"
	if data[p] == 10 { goto tr4088 }
	goto st1320
tr3555:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1321
tr1621:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1321
st1321:
	p++
	if p == pe { goto _test_eof1321 }
	fallthrough
case 1321:
// line 74897 "zparse.go"
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 79: goto st1322
		case 92: goto st97
		case 111: goto st1322
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1322:
	p++
	if p == pe { goto _test_eof1322 }
	fallthrough
case 1322:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 65: goto st1323
		case 92: goto st97
		case 97: goto st1323
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1323:
	p++
	if p == pe { goto _test_eof1323 }
	fallthrough
case 1323:
	switch data[p] {
		case 9: goto tr4144
		case 10: goto tr4145
		case 32: goto tr4144
		case 40: goto tr4146
		case 41: goto tr4147
		case 43: goto st97
		case 59: goto tr4148
		case 61: goto st97
		case 92: goto st97
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr4151:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1324
tr4152:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1324
tr4150:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1324
tr4144:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1324
tr4145:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1324
tr4146:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1324
tr4147:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1324
st1324:
	p++
	if p == pe { goto _test_eof1324 }
	fallthrough
case 1324:
// line 75052 "zparse.go"
	switch data[p] {
		case 9: goto st1324
		case 10: goto tr4150
		case 32: goto st1324
		case 40: goto tr4151
		case 41: goto tr4152
		case 43: goto tr4153
		case 59: goto st1476
		case 61: goto tr4153
		case 92: goto tr4153
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr4153 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr4153 }
	} else {
		goto tr4153
	}
	goto st0
tr4153:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1325
st1325:
	p++
	if p == pe { goto _test_eof1325 }
	fallthrough
case 1325:
// line 75081 "zparse.go"
	switch data[p] {
		case 9: goto tr4155
		case 10: goto tr4156
		case 32: goto tr4155
		case 40: goto tr4157
		case 41: goto tr4158
		case 43: goto st1325
		case 59: goto tr4160
		case 61: goto st1325
		case 92: goto st1325
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1325 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1325 }
	} else {
		goto st1325
	}
	goto st0
tr4163:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1326
tr4164:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1326
tr4155:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1326
tr4157:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1326
tr4158:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1326
st1326:
	p++
	if p == pe { goto _test_eof1326 }
	fallthrough
case 1326:
// line 75178 "zparse.go"
	switch data[p] {
		case 9: goto st1326
		case 10: goto tr4162
		case 32: goto st1326
		case 40: goto tr4163
		case 41: goto tr4164
		case 43: goto tr429
		case 59: goto tr4165
		case 61: goto tr429
		case 92: goto tr429
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr429 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr429 }
	} else {
		goto tr429
	}
	goto st0
tr4162:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1787
tr4579:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1787
tr4156:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1787
st1787:
	p++
	if p == pe { goto _test_eof1787 }
	fallthrough
case 1787:
// line 75235 "zparse.go"
	switch data[p] {
		case 9: goto st1327
		case 10: goto tr4167
		case 32: goto st1327
		case 40: goto tr4168
		case 41: goto tr4169
		case 43: goto tr429
		case 47: goto tr429
		case 58: goto tr429
		case 59: goto tr4170
		case 61: goto tr429
		case 92: goto tr5473
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto tr5473 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr5473 }
	} else {
		goto tr5473
	}
	goto st0
tr4168:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1327
tr4169:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1327
st1327:
	p++
	if p == pe { goto _test_eof1327 }
	fallthrough
case 1327:
// line 75271 "zparse.go"
	switch data[p] {
		case 9: goto st1327
		case 10: goto tr4167
		case 32: goto st1327
		case 40: goto tr4168
		case 41: goto tr4169
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto tr4170
		case 61: goto tr429
		case 65: goto tr1957
		case 67: goto tr1958
		case 68: goto tr1959
		case 72: goto tr1960
		case 73: goto tr1961
		case 77: goto tr1962
		case 78: goto tr1963
		case 82: goto tr1964
		case 83: goto tr1965
		case 92: goto tr429
		case 97: goto tr1957
		case 99: goto tr1958
		case 100: goto tr1959
		case 104: goto tr1960
		case 105: goto tr1961
		case 109: goto tr1962
		case 110: goto tr1963
		case 114: goto tr1964
		case 115: goto tr1965
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 66 {
			goto tr429
		}
	} else {
		goto tr1955
	}
	goto st0
tr4167:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1788
tr4189:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1788
st1788:
	p++
	if p == pe { goto _test_eof1788 }
	fallthrough
case 1788:
// line 75329 "zparse.go"
	switch data[p] {
		case 9: goto st1327
		case 10: goto tr4167
		case 32: goto st1327
		case 40: goto tr4168
		case 41: goto tr4169
		case 43: goto tr429
		case 47: goto tr429
		case 58: goto tr429
		case 59: goto tr4170
		case 61: goto tr429
		case 65: goto tr5475
		case 67: goto tr5476
		case 68: goto tr5477
		case 72: goto tr5478
		case 73: goto tr5479
		case 77: goto tr5480
		case 78: goto tr5481
		case 82: goto tr5482
		case 83: goto tr5483
		case 92: goto tr5473
		case 95: goto st2
		case 97: goto tr5475
		case 99: goto tr5476
		case 100: goto tr5477
		case 104: goto tr5478
		case 105: goto tr5479
		case 109: goto tr5480
		case 110: goto tr5481
		case 114: goto tr5482
		case 115: goto tr5483
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto tr5473 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr5473 }
		} else if data[p] >= 66 {
			goto tr5473
		}
	} else {
		goto tr5474
	}
	goto st0
tr5473:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1328
st1328:
	p++
	if p == pe { goto _test_eof1328 }
	fallthrough
case 1328:
// line 75383 "zparse.go"
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 92: goto st1328
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
tr4179:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1329
tr4180:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1329
tr4178:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1329
tr4171:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1329
tr4172:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1329
tr4173:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1329
tr4174:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1329
tr4182:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1329
tr4183:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1329
tr4184:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1329
tr4185:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1329
tr4215:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1329
tr4216:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1329
tr4217:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1329
tr4218:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1329
st1329:
	p++
	if p == pe { goto _test_eof1329 }
	fallthrough
case 1329:
// line 75529 "zparse.go"
	switch data[p] {
		case 9: goto st1329
		case 10: goto tr4178
		case 32: goto st1329
		case 40: goto tr4179
		case 41: goto tr4180
		case 59: goto st1330
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2147 }
	goto st0
tr4176:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1330
tr4187:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1330
tr4219:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1330
st1330:
	p++
	if p == pe { goto _test_eof1330 }
	fallthrough
case 1330:
// line 75585 "zparse.go"
	if data[p] == 10 { goto tr4178 }
	goto st1330
tr5474:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1331
st1331:
	p++
	if p == pe { goto _test_eof1331 }
	fallthrough
case 1331:
// line 75599 "zparse.go"
	switch data[p] {
		case 9: goto tr4182
		case 10: goto tr4183
		case 32: goto tr4182
		case 40: goto tr4184
		case 41: goto tr4185
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4187
		case 61: goto st115
		case 92: goto st1328
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st1328 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st1328 }
		} else if data[p] >= 65 {
			goto st1328
		}
	} else {
		goto st1331
	}
	goto st0
tr4170:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1332
st1332:
	p++
	if p == pe { goto _test_eof1332 }
	fallthrough
case 1332:
// line 75635 "zparse.go"
	if data[p] == 10 { goto tr4189 }
	goto st1332
tr5475:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1333
st1333:
	p++
	if p == pe { goto _test_eof1333 }
	fallthrough
case 1333:
// line 75649 "zparse.go"
	switch data[p] {
		case 9: goto tr4190
		case 10: goto tr4191
		case 32: goto tr4190
		case 40: goto tr4192
		case 41: goto tr4193
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4194
		case 61: goto st115
		case 65: goto st1336
		case 78: goto st1341
		case 92: goto st1328
		case 95: goto st2
		case 97: goto st1336
		case 110: goto st1341
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
tr4199:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1334
tr4200:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1334
tr4198:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1334
tr4190:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1334
tr4191:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1334
tr4192:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1334
tr4193:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1334
st1334:
	p++
	if p == pe { goto _test_eof1334 }
	fallthrough
case 1334:
// line 75767 "zparse.go"
	switch data[p] {
		case 9: goto st1334
		case 10: goto tr4198
		case 32: goto st1334
		case 40: goto tr4199
		case 41: goto tr4200
		case 43: goto tr58
		case 58: goto tr58
		case 59: goto st1335
		case 61: goto tr58
		case 65: goto tr539
		case 67: goto tr540
		case 68: goto tr541
		case 72: goto tr542
		case 73: goto tr543
		case 77: goto tr544
		case 78: goto tr545
		case 82: goto tr546
		case 83: goto tr547
		case 92: goto tr58
		case 97: goto tr539
		case 99: goto tr540
		case 100: goto tr541
		case 104: goto tr542
		case 105: goto tr543
		case 109: goto tr544
		case 110: goto tr545
		case 114: goto tr546
		case 115: goto tr547
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr58 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr58 }
		} else if data[p] >= 66 {
			goto tr58
		}
	} else {
		goto tr2210
	}
	goto st0
tr4194:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1335
st1335:
	p++
	if p == pe { goto _test_eof1335 }
	fallthrough
case 1335:
// line 75832 "zparse.go"
	if data[p] == 10 { goto tr4198 }
	goto st1335
st1336:
	p++
	if p == pe { goto _test_eof1336 }
	fallthrough
case 1336:
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 65: goto st1337
		case 92: goto st1328
		case 95: goto st2
		case 97: goto st1337
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1337:
	p++
	if p == pe { goto _test_eof1337 }
	fallthrough
case 1337:
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 65: goto st1338
		case 92: goto st1328
		case 95: goto st2
		case 97: goto st1338
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1338:
	p++
	if p == pe { goto _test_eof1338 }
	fallthrough
case 1338:
	switch data[p] {
		case 9: goto tr4204
		case 10: goto tr4205
		case 32: goto tr4204
		case 40: goto tr4206
		case 41: goto tr4207
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4208
		case 61: goto st115
		case 92: goto st1328
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
tr4211:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1339
tr4212:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1339
tr4210:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1339
tr4204:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1339
tr4205:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1339
tr4206:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1339
tr4207:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1339
st1339:
	p++
	if p == pe { goto _test_eof1339 }
	fallthrough
case 1339:
// line 76011 "zparse.go"
	switch data[p] {
		case 9: goto st1339
		case 10: goto tr4210
		case 32: goto st1339
		case 40: goto tr4211
		case 41: goto tr4212
		case 43: goto tr86
		case 58: goto tr86
		case 59: goto st1340
		case 61: goto tr86
		case 65: goto tr648
		case 67: goto tr649
		case 68: goto tr650
		case 72: goto tr651
		case 73: goto tr652
		case 77: goto tr653
		case 78: goto tr654
		case 82: goto tr655
		case 83: goto tr656
		case 92: goto tr86
		case 97: goto tr648
		case 99: goto tr649
		case 100: goto tr650
		case 104: goto tr651
		case 105: goto tr652
		case 109: goto tr653
		case 110: goto tr654
		case 114: goto tr655
		case 115: goto tr656
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr86 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr86 }
		} else if data[p] >= 66 {
			goto tr86
		}
	} else {
		goto tr2415
	}
	goto st0
tr4208:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1340
st1340:
	p++
	if p == pe { goto _test_eof1340 }
	fallthrough
case 1340:
// line 76076 "zparse.go"
	if data[p] == 10 { goto tr4210 }
	goto st1340
st1341:
	p++
	if p == pe { goto _test_eof1341 }
	fallthrough
case 1341:
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 89: goto st1342
		case 92: goto st1328
		case 95: goto st2
		case 121: goto st1342
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1342:
	p++
	if p == pe { goto _test_eof1342 }
	fallthrough
case 1342:
	switch data[p] {
		case 9: goto tr4215
		case 10: goto tr4216
		case 32: goto tr4215
		case 40: goto tr4217
		case 41: goto tr4218
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4219
		case 61: goto st115
		case 92: goto st1328
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
tr5476:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1343
st1343:
	p++
	if p == pe { goto _test_eof1343 }
	fallthrough
case 1343:
// line 76146 "zparse.go"
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 72: goto st1342
		case 78: goto st1344
		case 83: goto st1342
		case 92: goto st1328
		case 95: goto st2
		case 104: goto st1342
		case 110: goto st1344
		case 115: goto st1342
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1344:
	p++
	if p == pe { goto _test_eof1344 }
	fallthrough
case 1344:
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 65: goto st1345
		case 92: goto st1328
		case 95: goto st2
		case 97: goto st1345
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1345:
	p++
	if p == pe { goto _test_eof1345 }
	fallthrough
case 1345:
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 77: goto st1346
		case 92: goto st1328
		case 95: goto st2
		case 109: goto st1346
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1346:
	p++
	if p == pe { goto _test_eof1346 }
	fallthrough
case 1346:
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 69: goto st1347
		case 92: goto st1328
		case 95: goto st2
		case 101: goto st1347
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1347:
	p++
	if p == pe { goto _test_eof1347 }
	fallthrough
case 1347:
	switch data[p] {
		case 9: goto tr4224
		case 10: goto tr4225
		case 32: goto tr4224
		case 40: goto tr4226
		case 41: goto tr4227
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4228
		case 61: goto st115
		case 92: goto st1328
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
tr4231:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1348
tr4232:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1348
tr4230:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1348
tr4224:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1348
tr4225:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1348
tr4226:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1348
tr4227:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1348
st1348:
	p++
	if p == pe { goto _test_eof1348 }
	fallthrough
case 1348:
// line 76380 "zparse.go"
	switch data[p] {
		case 9: goto st1348
		case 10: goto tr4230
		case 32: goto st1348
		case 40: goto tr4231
		case 41: goto tr4232
		case 43: goto tr121
		case 58: goto tr121
		case 59: goto st1349
		case 61: goto tr121
		case 65: goto tr580
		case 67: goto tr581
		case 68: goto tr582
		case 72: goto tr583
		case 73: goto tr584
		case 77: goto tr585
		case 78: goto tr586
		case 82: goto tr587
		case 83: goto tr588
		case 92: goto tr121
		case 97: goto tr580
		case 99: goto tr581
		case 100: goto tr582
		case 104: goto tr583
		case 105: goto tr584
		case 109: goto tr585
		case 110: goto tr586
		case 114: goto tr587
		case 115: goto tr588
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr121 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr121 }
		} else if data[p] >= 66 {
			goto tr121
		}
	} else {
		goto tr2571
	}
	goto st0
tr4228:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1349
st1349:
	p++
	if p == pe { goto _test_eof1349 }
	fallthrough
case 1349:
// line 76445 "zparse.go"
	if data[p] == 10 { goto tr4230 }
	goto st1349
tr5477:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1350
st1350:
	p++
	if p == pe { goto _test_eof1350 }
	fallthrough
case 1350:
// line 76459 "zparse.go"
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 78: goto st1351
		case 83: goto st1358
		case 92: goto st1328
		case 95: goto st2
		case 110: goto st1351
		case 115: goto st1358
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1351:
	p++
	if p == pe { goto _test_eof1351 }
	fallthrough
case 1351:
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 83: goto st1352
		case 92: goto st1328
		case 95: goto st2
		case 115: goto st1352
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1352:
	p++
	if p == pe { goto _test_eof1352 }
	fallthrough
case 1352:
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 75: goto st1353
		case 92: goto st1328
		case 95: goto st2
		case 107: goto st1353
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1353:
	p++
	if p == pe { goto _test_eof1353 }
	fallthrough
case 1353:
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 69: goto st1354
		case 92: goto st1328
		case 95: goto st2
		case 101: goto st1354
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1354:
	p++
	if p == pe { goto _test_eof1354 }
	fallthrough
case 1354:
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 89: goto st1355
		case 92: goto st1328
		case 95: goto st2
		case 121: goto st1355
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1355:
	p++
	if p == pe { goto _test_eof1355 }
	fallthrough
case 1355:
	switch data[p] {
		case 9: goto tr4240
		case 10: goto tr4241
		case 32: goto tr4240
		case 40: goto tr4242
		case 41: goto tr4243
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4244
		case 61: goto st115
		case 92: goto st1328
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
tr4247:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1356
tr4248:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1356
tr4246:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1356
tr4240:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1356
tr4241:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1356
tr4242:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1356
tr4243:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1356
st1356:
	p++
	if p == pe { goto _test_eof1356 }
	fallthrough
case 1356:
// line 76720 "zparse.go"
	switch data[p] {
		case 9: goto st1356
		case 10: goto tr4246
		case 32: goto st1356
		case 40: goto tr4247
		case 41: goto tr4248
		case 59: goto st1357
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2706 }
	goto st0
tr4244:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1357
st1357:
	p++
	if p == pe { goto _test_eof1357 }
	fallthrough
case 1357:
// line 76771 "zparse.go"
	if data[p] == 10 { goto tr4246 }
	goto st1357
st1358:
	p++
	if p == pe { goto _test_eof1358 }
	fallthrough
case 1358:
	switch data[p] {
		case 9: goto tr4250
		case 10: goto tr4251
		case 32: goto tr4250
		case 40: goto tr4252
		case 41: goto tr4253
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4254
		case 61: goto st115
		case 92: goto st1328
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
tr4257:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1359
tr4258:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1359
tr4256:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1359
tr4250:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1359
tr4251:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1359
tr4252:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1359
tr4253:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1359
st1359:
	p++
	if p == pe { goto _test_eof1359 }
	fallthrough
case 1359:
// line 76892 "zparse.go"
	switch data[p] {
		case 9: goto st1359
		case 10: goto tr4256
		case 32: goto st1359
		case 40: goto tr4257
		case 41: goto tr4258
		case 59: goto st1360
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2766 }
	goto st0
tr4254:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1360
st1360:
	p++
	if p == pe { goto _test_eof1360 }
	fallthrough
case 1360:
// line 76943 "zparse.go"
	if data[p] == 10 { goto tr4256 }
	goto st1360
tr5478:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1361
st1361:
	p++
	if p == pe { goto _test_eof1361 }
	fallthrough
case 1361:
// line 76957 "zparse.go"
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 83: goto st1342
		case 92: goto st1328
		case 95: goto st2
		case 115: goto st1342
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
tr5479:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1362
st1362:
	p++
	if p == pe { goto _test_eof1362 }
	fallthrough
case 1362:
// line 76993 "zparse.go"
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 78: goto st1342
		case 92: goto st1328
		case 95: goto st2
		case 110: goto st1342
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
tr5480:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1363
st1363:
	p++
	if p == pe { goto _test_eof1363 }
	fallthrough
case 1363:
// line 77029 "zparse.go"
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 88: goto st1364
		case 92: goto st1328
		case 95: goto st2
		case 120: goto st1364
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1364:
	p++
	if p == pe { goto _test_eof1364 }
	fallthrough
case 1364:
	switch data[p] {
		case 9: goto tr4261
		case 10: goto tr4262
		case 32: goto tr4261
		case 40: goto tr4263
		case 41: goto tr4264
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4265
		case 61: goto st115
		case 92: goto st1328
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
tr4268:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1365
tr4269:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1365
tr4267:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1365
tr4261:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1365
tr4262:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1365
tr4263:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1365
tr4264:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1365
st1365:
	p++
	if p == pe { goto _test_eof1365 }
	fallthrough
case 1365:
// line 77172 "zparse.go"
	switch data[p] {
		case 9: goto st1365
		case 10: goto tr4267
		case 32: goto st1365
		case 40: goto tr4268
		case 41: goto tr4269
		case 59: goto st1366
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2827 }
	goto st0
tr4265:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1366
st1366:
	p++
	if p == pe { goto _test_eof1366 }
	fallthrough
case 1366:
// line 77223 "zparse.go"
	if data[p] == 10 { goto tr4267 }
	goto st1366
tr5481:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1367
st1367:
	p++
	if p == pe { goto _test_eof1367 }
	fallthrough
case 1367:
// line 77237 "zparse.go"
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 79: goto st1368
		case 83: goto st1370
		case 92: goto st1328
		case 95: goto st2
		case 111: goto st1368
		case 115: goto st1370
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1368:
	p++
	if p == pe { goto _test_eof1368 }
	fallthrough
case 1368:
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 78: goto st1369
		case 92: goto st1328
		case 95: goto st2
		case 110: goto st1369
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1369:
	p++
	if p == pe { goto _test_eof1369 }
	fallthrough
case 1369:
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 69: goto st1342
		case 92: goto st1328
		case 95: goto st2
		case 101: goto st1342
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1370:
	p++
	if p == pe { goto _test_eof1370 }
	fallthrough
case 1370:
	switch data[p] {
		case 9: goto tr4274
		case 10: goto tr4275
		case 32: goto tr4274
		case 40: goto tr4276
		case 41: goto tr4277
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4278
		case 61: goto st115
		case 92: goto st1328
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
tr4281:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1371
tr4282:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1371
tr4280:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1371
tr4274:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1371
tr4275:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1371
tr4276:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1371
tr4277:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1371
st1371:
	p++
	if p == pe { goto _test_eof1371 }
	fallthrough
case 1371:
// line 77440 "zparse.go"
	switch data[p] {
		case 9: goto st1371
		case 10: goto tr4280
		case 32: goto st1371
		case 40: goto tr4281
		case 41: goto tr4282
		case 43: goto tr281
		case 58: goto tr281
		case 59: goto st1372
		case 61: goto tr281
		case 65: goto tr960
		case 67: goto tr961
		case 68: goto tr962
		case 72: goto tr963
		case 73: goto tr964
		case 77: goto tr965
		case 78: goto tr966
		case 82: goto tr967
		case 83: goto tr968
		case 92: goto tr281
		case 97: goto tr960
		case 99: goto tr961
		case 100: goto tr962
		case 104: goto tr963
		case 105: goto tr964
		case 109: goto tr965
		case 110: goto tr966
		case 114: goto tr967
		case 115: goto tr968
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr281 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr281 }
		} else if data[p] >= 66 {
			goto tr281
		}
	} else {
		goto tr2910
	}
	goto st0
tr4278:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1372
st1372:
	p++
	if p == pe { goto _test_eof1372 }
	fallthrough
case 1372:
// line 77505 "zparse.go"
	if data[p] == 10 { goto tr4280 }
	goto st1372
tr5482:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1373
st1373:
	p++
	if p == pe { goto _test_eof1373 }
	fallthrough
case 1373:
// line 77519 "zparse.go"
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 82: goto st1374
		case 92: goto st1328
		case 95: goto st2
		case 114: goto st1374
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1374:
	p++
	if p == pe { goto _test_eof1374 }
	fallthrough
case 1374:
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 83: goto st1375
		case 92: goto st1328
		case 95: goto st2
		case 115: goto st1375
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1375:
	p++
	if p == pe { goto _test_eof1375 }
	fallthrough
case 1375:
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 73: goto st1376
		case 92: goto st1328
		case 95: goto st2
		case 105: goto st1376
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1376:
	p++
	if p == pe { goto _test_eof1376 }
	fallthrough
case 1376:
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 71: goto st1377
		case 92: goto st1328
		case 95: goto st2
		case 103: goto st1377
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1377:
	p++
	if p == pe { goto _test_eof1377 }
	fallthrough
case 1377:
	switch data[p] {
		case 9: goto tr4288
		case 10: goto tr4289
		case 32: goto tr4288
		case 40: goto tr4290
		case 41: goto tr4291
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4292
		case 61: goto st115
		case 92: goto st1328
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
tr4295:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1378
tr4296:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1378
tr4294:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1378
tr4288:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1378
tr4289:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1378
tr4290:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1378
tr4291:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1378
st1378:
	p++
	if p == pe { goto _test_eof1378 }
	fallthrough
case 1378:
// line 77749 "zparse.go"
	switch data[p] {
		case 9: goto st1378
		case 10: goto tr4294
		case 32: goto st1378
		case 40: goto tr4295
		case 41: goto tr4296
		case 59: goto st1379
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr2982 }
	goto st0
tr4292:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1379
st1379:
	p++
	if p == pe { goto _test_eof1379 }
	fallthrough
case 1379:
// line 77800 "zparse.go"
	if data[p] == 10 { goto tr4294 }
	goto st1379
tr5483:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1380
st1380:
	p++
	if p == pe { goto _test_eof1380 }
	fallthrough
case 1380:
// line 77814 "zparse.go"
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 79: goto st1381
		case 92: goto st1328
		case 95: goto st2
		case 111: goto st1381
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1381:
	p++
	if p == pe { goto _test_eof1381 }
	fallthrough
case 1381:
	switch data[p] {
		case 9: goto tr4171
		case 10: goto tr4172
		case 32: goto tr4171
		case 40: goto tr4173
		case 41: goto tr4174
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4176
		case 61: goto st115
		case 65: goto st1382
		case 92: goto st1328
		case 95: goto st2
		case 97: goto st1382
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
st1382:
	p++
	if p == pe { goto _test_eof1382 }
	fallthrough
case 1382:
	switch data[p] {
		case 9: goto tr4300
		case 10: goto tr4301
		case 32: goto tr4300
		case 40: goto tr4302
		case 41: goto tr4303
		case 43: goto st115
		case 47: goto st115
		case 58: goto st115
		case 59: goto tr4304
		case 61: goto st115
		case 92: goto st1328
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st1328 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1328 }
	} else {
		goto st1328
	}
	goto st0
tr4307:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1383
tr4308:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1383
tr4306:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1383
tr4300:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1383
tr4301:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1383
tr4302:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1383
tr4303:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1383
st1383:
	p++
	if p == pe { goto _test_eof1383 }
	fallthrough
case 1383:
// line 77986 "zparse.go"
	switch data[p] {
		case 9: goto st1383
		case 10: goto tr4306
		case 32: goto st1383
		case 40: goto tr4307
		case 41: goto tr4308
		case 43: goto tr417
		case 58: goto tr417
		case 59: goto st1387
		case 61: goto tr417
		case 65: goto tr1118
		case 67: goto tr1119
		case 68: goto tr1120
		case 72: goto tr1121
		case 73: goto tr1122
		case 77: goto tr1123
		case 78: goto tr1124
		case 82: goto tr1125
		case 83: goto tr1126
		case 92: goto tr417
		case 97: goto tr1118
		case 99: goto tr1119
		case 100: goto tr1120
		case 104: goto tr1121
		case 105: goto tr1122
		case 109: goto tr1123
		case 110: goto tr1124
		case 114: goto tr1125
		case 115: goto tr1126
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr417 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr417 }
		} else if data[p] >= 66 {
			goto tr417
		}
	} else {
		goto tr3044
	}
	goto st0
tr3044:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1384
st1384:
	p++
	if p == pe { goto _test_eof1384 }
	fallthrough
case 1384:
// line 78040 "zparse.go"
	switch data[p] {
		case 9: goto tr4310
		case 10: goto tr4311
		case 32: goto tr4310
		case 40: goto tr4312
		case 41: goto tr4313
		case 43: goto st113
		case 58: goto st113
		case 59: goto tr4315
		case 61: goto st113
		case 92: goto st113
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st113 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st113 }
		} else if data[p] >= 65 {
			goto st113
		}
	} else {
		goto st1384
	}
	goto st0
tr4318:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1385
tr4319:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1385
tr4317:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1385
tr4310:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1385
tr4311:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1385
tr4312:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1385
tr4313:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1385
st1385:
	p++
	if p == pe { goto _test_eof1385 }
	fallthrough
case 1385:
// line 78120 "zparse.go"
	switch data[p] {
		case 9: goto st1385
		case 10: goto tr4317
		case 32: goto st1385
		case 40: goto tr4318
		case 41: goto tr4319
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1386
		case 61: goto tr429
		case 65: goto tr1138
		case 67: goto tr1139
		case 68: goto tr1140
		case 72: goto tr1141
		case 73: goto tr1142
		case 77: goto tr1143
		case 78: goto tr1144
		case 82: goto tr1145
		case 83: goto tr1146
		case 92: goto tr429
		case 97: goto tr1138
		case 99: goto tr1139
		case 100: goto tr1140
		case 104: goto tr1141
		case 105: goto tr1142
		case 109: goto tr1143
		case 110: goto tr1144
		case 114: goto tr1145
		case 115: goto tr1146
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 66 {
			goto tr429
		}
	} else {
		goto tr2026
	}
	goto st0
tr4315:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1386
st1386:
	p++
	if p == pe { goto _test_eof1386 }
	fallthrough
case 1386:
// line 78176 "zparse.go"
	if data[p] == 10 { goto tr4317 }
	goto st1386
tr4304:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1387
st1387:
	p++
	if p == pe { goto _test_eof1387 }
	fallthrough
case 1387:
// line 78201 "zparse.go"
	if data[p] == 10 { goto tr4306 }
	goto st1387
tr1118:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1388
st1388:
	p++
	if p == pe { goto _test_eof1388 }
	fallthrough
case 1388:
// line 78215 "zparse.go"
	switch data[p] {
		case 9: goto tr4321
		case 10: goto tr4322
		case 32: goto tr4321
		case 40: goto tr4323
		case 41: goto tr4324
		case 43: goto st113
		case 59: goto tr4325
		case 61: goto st113
		case 65: goto st1391
		case 78: goto st1397
		case 92: goto st113
		case 97: goto st1391
		case 110: goto st1397
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
tr4330:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1389
tr4331:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1389
tr4329:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1389
tr4321:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1389
tr4322:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1389
tr4323:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1389
tr4324:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1389
st1389:
	p++
	if p == pe { goto _test_eof1389 }
	fallthrough
case 1389:
// line 78322 "zparse.go"
	switch data[p] {
		case 9: goto st1389
		case 10: goto tr4329
		case 32: goto st1389
		case 40: goto tr4330
		case 41: goto tr4331
		case 43: goto tr2120
		case 59: goto st1390
		case 61: goto tr2120
		case 92: goto tr2120
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr2120 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr2120 }
	} else {
		goto tr2120
	}
	goto st0
tr4325:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1390
st1390:
	p++
	if p == pe { goto _test_eof1390 }
	fallthrough
case 1390:
// line 78362 "zparse.go"
	if data[p] == 10 { goto tr4329 }
	goto st1390
st1391:
	p++
	if p == pe { goto _test_eof1391 }
	fallthrough
case 1391:
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 65: goto st1392
		case 92: goto st113
		case 97: goto st1392
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1392:
	p++
	if p == pe { goto _test_eof1392 }
	fallthrough
case 1392:
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 65: goto st1393
		case 92: goto st113
		case 97: goto st1393
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1393:
	p++
	if p == pe { goto _test_eof1393 }
	fallthrough
case 1393:
	switch data[p] {
		case 9: goto tr4335
		case 10: goto tr4336
		case 32: goto tr4335
		case 40: goto tr4337
		case 41: goto tr4338
		case 43: goto st113
		case 59: goto tr4339
		case 61: goto st113
		case 92: goto st113
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
tr4342:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1394
tr4343:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1394
tr4341:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1394
tr4335:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1394
tr4336:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1394
tr4337:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1394
tr4338:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1394
st1394:
	p++
	if p == pe { goto _test_eof1394 }
	fallthrough
case 1394:
// line 78524 "zparse.go"
	switch data[p] {
		case 9: goto st1394
		case 10: goto tr4341
		case 32: goto st1394
		case 40: goto tr4342
		case 41: goto tr4343
		case 43: goto tr4344
		case 59: goto st1396
		case 61: goto tr4344
		case 92: goto tr4344
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr4344 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr4344 }
	} else {
		goto tr4344
	}
	goto st0
tr4344:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1395
st1395:
	p++
	if p == pe { goto _test_eof1395 }
	fallthrough
case 1395:
// line 78553 "zparse.go"
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 92: goto st1395
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
tr4339:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1396
st1396:
	p++
	if p == pe { goto _test_eof1396 }
	fallthrough
case 1396:
// line 78593 "zparse.go"
	if data[p] == 10 { goto tr4341 }
	goto st1396
st1397:
	p++
	if p == pe { goto _test_eof1397 }
	fallthrough
case 1397:
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 89: goto st1398
		case 92: goto st113
		case 121: goto st1398
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1398:
	p++
	if p == pe { goto _test_eof1398 }
	fallthrough
case 1398:
	switch data[p] {
		case 9: goto tr4353
		case 10: goto tr4354
		case 32: goto tr4353
		case 40: goto tr4355
		case 41: goto tr4356
		case 43: goto st113
		case 59: goto tr4357
		case 61: goto st113
		case 92: goto st113
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
tr4360:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1399
tr4361:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1399
tr4359:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1399
tr4353:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1399
tr4354:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1399
tr4355:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1399
tr4356:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1399
st1399:
	p++
	if p == pe { goto _test_eof1399 }
	fallthrough
case 1399:
// line 78693 "zparse.go"
	switch data[p] {
		case 9: goto st1399
		case 10: goto tr4359
		case 32: goto st1399
		case 40: goto tr4360
		case 41: goto tr4361
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1401
		case 61: goto tr429
		case 65: goto tr4364
		case 67: goto tr4365
		case 68: goto tr1140
		case 77: goto tr1143
		case 78: goto tr4366
		case 82: goto tr1145
		case 83: goto tr1146
		case 92: goto tr429
		case 97: goto tr4364
		case 99: goto tr4365
		case 100: goto tr1140
		case 109: goto tr1143
		case 110: goto tr4366
		case 114: goto tr1145
		case 115: goto tr1146
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 66 {
			goto tr429
		}
	} else {
		goto tr4362
	}
	goto st0
tr4362:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1400
st1400:
	p++
	if p == pe { goto _test_eof1400 }
	fallthrough
case 1400:
// line 78741 "zparse.go"
	switch data[p] {
		case 9: goto tr4367
		case 10: goto tr4368
		case 32: goto tr4367
		case 40: goto tr4369
		case 41: goto tr4370
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr4372
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st1400
	}
	goto st0
tr4357:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1401
st1401:
	p++
	if p == pe { goto _test_eof1401 }
	fallthrough
case 1401:
// line 78777 "zparse.go"
	if data[p] == 10 { goto tr4359 }
	goto st1401
tr4364:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1402
st1402:
	p++
	if p == pe { goto _test_eof1402 }
	fallthrough
case 1402:
// line 78789 "zparse.go"
	switch data[p] {
		case 9: goto tr1147
		case 10: goto tr1148
		case 32: goto tr1147
		case 40: goto tr1149
		case 41: goto tr1150
		case 43: goto st115
		case 59: goto tr1151
		case 61: goto st115
		case 65: goto st348
		case 92: goto st115
		case 97: goto st348
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr4365:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1403
st1403:
	p++
	if p == pe { goto _test_eof1403 }
	fallthrough
case 1403:
// line 78820 "zparse.go"
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 78: goto st359
		case 92: goto st115
		case 110: goto st359
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr4366:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1404
st1404:
	p++
	if p == pe { goto _test_eof1404 }
	fallthrough
case 1404:
// line 78851 "zparse.go"
	switch data[p] {
		case 9: goto tr431
		case 10: goto tr432
		case 32: goto tr431
		case 40: goto tr433
		case 41: goto tr434
		case 43: goto st115
		case 59: goto tr436
		case 61: goto st115
		case 83: goto st428
		case 92: goto st115
		case 115: goto st428
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st115 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st115 }
	} else {
		goto st115
	}
	goto st0
tr1119:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1405
st1405:
	p++
	if p == pe { goto _test_eof1405 }
	fallthrough
case 1405:
// line 78884 "zparse.go"
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 72: goto st1398
		case 78: goto st1406
		case 83: goto st1398
		case 92: goto st113
		case 104: goto st1398
		case 110: goto st1406
		case 115: goto st1398
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1406:
	p++
	if p == pe { goto _test_eof1406 }
	fallthrough
case 1406:
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 65: goto st1407
		case 92: goto st113
		case 97: goto st1407
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1407:
	p++
	if p == pe { goto _test_eof1407 }
	fallthrough
case 1407:
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 77: goto st1408
		case 92: goto st113
		case 109: goto st1408
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1408:
	p++
	if p == pe { goto _test_eof1408 }
	fallthrough
case 1408:
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 69: goto st1409
		case 92: goto st113
		case 101: goto st1409
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1409:
	p++
	if p == pe { goto _test_eof1409 }
	fallthrough
case 1409:
	switch data[p] {
		case 9: goto tr4377
		case 10: goto tr4378
		case 32: goto tr4377
		case 40: goto tr4379
		case 41: goto tr4380
		case 43: goto st113
		case 59: goto tr4381
		case 61: goto st113
		case 92: goto st113
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
tr4384:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1410
tr4385:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1410
tr4383:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1410
tr4377:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1410
tr4378:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1410
tr4379:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1410
tr4380:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1410
st1410:
	p++
	if p == pe { goto _test_eof1410 }
	fallthrough
case 1410:
// line 79095 "zparse.go"
	switch data[p] {
		case 9: goto st1410
		case 10: goto tr4383
		case 32: goto st1410
		case 40: goto tr4384
		case 41: goto tr4385
		case 43: goto tr3090
		case 59: goto st1411
		case 61: goto tr3090
		case 92: goto tr3090
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr3090 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr3090 }
	} else {
		goto tr3090
	}
	goto st0
tr4381:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1411
st1411:
	p++
	if p == pe { goto _test_eof1411 }
	fallthrough
case 1411:
// line 79135 "zparse.go"
	if data[p] == 10 { goto tr4383 }
	goto st1411
tr1120:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1412
st1412:
	p++
	if p == pe { goto _test_eof1412 }
	fallthrough
case 1412:
// line 79149 "zparse.go"
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 78: goto st1413
		case 83: goto st1423
		case 92: goto st113
		case 110: goto st1413
		case 115: goto st1423
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1413:
	p++
	if p == pe { goto _test_eof1413 }
	fallthrough
case 1413:
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 83: goto st1414
		case 92: goto st113
		case 115: goto st1414
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1414:
	p++
	if p == pe { goto _test_eof1414 }
	fallthrough
case 1414:
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 75: goto st1415
		case 92: goto st113
		case 107: goto st1415
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1415:
	p++
	if p == pe { goto _test_eof1415 }
	fallthrough
case 1415:
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 69: goto st1416
		case 92: goto st113
		case 101: goto st1416
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1416:
	p++
	if p == pe { goto _test_eof1416 }
	fallthrough
case 1416:
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 89: goto st1417
		case 92: goto st113
		case 121: goto st1417
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1417:
	p++
	if p == pe { goto _test_eof1417 }
	fallthrough
case 1417:
	switch data[p] {
		case 9: goto tr4393
		case 10: goto tr4394
		case 32: goto tr4393
		case 40: goto tr4395
		case 41: goto tr4396
		case 43: goto st113
		case 59: goto tr4397
		case 61: goto st113
		case 92: goto st113
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
tr4400:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1418
tr4401:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1418
tr4399:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1418
tr4393:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1418
tr4394:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1418
tr4395:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1418
tr4396:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1418
st1418:
	p++
	if p == pe { goto _test_eof1418 }
	fallthrough
case 1418:
// line 79384 "zparse.go"
	switch data[p] {
		case 9: goto st1418
		case 10: goto tr4399
		case 32: goto st1418
		case 40: goto tr4400
		case 41: goto tr4401
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1422
		case 61: goto tr429
		case 92: goto tr429
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 65 {
			goto tr429
		}
	} else {
		goto tr4402
	}
	goto st0
tr4402:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1419
st1419:
	p++
	if p == pe { goto _test_eof1419 }
	fallthrough
case 1419:
// line 79418 "zparse.go"
	switch data[p] {
		case 9: goto tr4404
		case 10: goto tr4405
		case 32: goto tr4404
		case 40: goto tr4406
		case 41: goto tr4407
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr4409
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st1419
	}
	goto st0
tr4412:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1420
tr4413:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1420
tr4411:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1420
tr4404:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1420
tr4405:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1420
tr4406:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1420
tr4407:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1420
st1420:
	p++
	if p == pe { goto _test_eof1420 }
	fallthrough
case 1420:
// line 79490 "zparse.go"
	switch data[p] {
		case 9: goto st1420
		case 10: goto tr4411
		case 32: goto st1420
		case 40: goto tr4412
		case 41: goto tr4413
		case 59: goto st1421
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr3218 }
	goto st0
tr4409:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1421
st1421:
	p++
	if p == pe { goto _test_eof1421 }
	fallthrough
case 1421:
// line 79512 "zparse.go"
	if data[p] == 10 { goto tr4411 }
	goto st1421
tr4397:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1422
st1422:
	p++
	if p == pe { goto _test_eof1422 }
	fallthrough
case 1422:
// line 79535 "zparse.go"
	if data[p] == 10 { goto tr4399 }
	goto st1422
st1423:
	p++
	if p == pe { goto _test_eof1423 }
	fallthrough
case 1423:
	switch data[p] {
		case 9: goto tr4415
		case 10: goto tr4416
		case 32: goto tr4415
		case 40: goto tr4417
		case 41: goto tr4418
		case 43: goto st113
		case 59: goto tr4419
		case 61: goto st113
		case 92: goto st113
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
tr4422:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1424
tr4423:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1424
tr4421:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1424
tr4415:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1424
tr4416:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1424
tr4417:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1424
tr4418:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1424
st1424:
	p++
	if p == pe { goto _test_eof1424 }
	fallthrough
case 1424:
// line 79645 "zparse.go"
	switch data[p] {
		case 9: goto st1424
		case 10: goto tr4421
		case 32: goto st1424
		case 40: goto tr4422
		case 41: goto tr4423
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1428
		case 61: goto tr429
		case 92: goto tr429
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 65 {
			goto tr429
		}
	} else {
		goto tr4424
	}
	goto st0
tr4424:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1425
st1425:
	p++
	if p == pe { goto _test_eof1425 }
	fallthrough
case 1425:
// line 79679 "zparse.go"
	switch data[p] {
		case 9: goto tr4426
		case 10: goto tr4427
		case 32: goto tr4426
		case 40: goto tr4428
		case 41: goto tr4429
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr4431
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st1425
	}
	goto st0
tr4434:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1426
tr4435:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1426
tr4433:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1426
tr4426:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1426
tr4427:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1426
tr4428:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1426
tr4429:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1426
st1426:
	p++
	if p == pe { goto _test_eof1426 }
	fallthrough
case 1426:
// line 79751 "zparse.go"
	switch data[p] {
		case 9: goto st1426
		case 10: goto tr4433
		case 32: goto st1426
		case 40: goto tr4434
		case 41: goto tr4435
		case 59: goto st1427
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr3271 }
	goto st0
tr4431:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1427
st1427:
	p++
	if p == pe { goto _test_eof1427 }
	fallthrough
case 1427:
// line 79773 "zparse.go"
	if data[p] == 10 { goto tr4433 }
	goto st1427
tr4419:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1428
st1428:
	p++
	if p == pe { goto _test_eof1428 }
	fallthrough
case 1428:
// line 79796 "zparse.go"
	if data[p] == 10 { goto tr4421 }
	goto st1428
tr1121:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1429
st1429:
	p++
	if p == pe { goto _test_eof1429 }
	fallthrough
case 1429:
// line 79810 "zparse.go"
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 83: goto st1398
		case 92: goto st113
		case 115: goto st1398
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
tr1122:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1430
st1430:
	p++
	if p == pe { goto _test_eof1430 }
	fallthrough
case 1430:
// line 79843 "zparse.go"
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 78: goto st1398
		case 92: goto st113
		case 110: goto st1398
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
tr1123:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1431
st1431:
	p++
	if p == pe { goto _test_eof1431 }
	fallthrough
case 1431:
// line 79876 "zparse.go"
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 88: goto st1432
		case 92: goto st113
		case 120: goto st1432
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1432:
	p++
	if p == pe { goto _test_eof1432 }
	fallthrough
case 1432:
	switch data[p] {
		case 9: goto tr4438
		case 10: goto tr4439
		case 32: goto tr4438
		case 40: goto tr4440
		case 41: goto tr4441
		case 43: goto st113
		case 59: goto tr4442
		case 61: goto st113
		case 92: goto st113
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
tr4445:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1433
tr4446:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1433
tr4444:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1433
tr4438:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1433
tr4439:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1433
tr4440:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1433
tr4441:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1433
st1433:
	p++
	if p == pe { goto _test_eof1433 }
	fallthrough
case 1433:
// line 80005 "zparse.go"
	switch data[p] {
		case 9: goto st1433
		case 10: goto tr4444
		case 32: goto st1433
		case 40: goto tr4445
		case 41: goto tr4446
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1437
		case 61: goto tr429
		case 92: goto tr429
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 65 {
			goto tr429
		}
	} else {
		goto tr4447
	}
	goto st0
tr4447:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1434
st1434:
	p++
	if p == pe { goto _test_eof1434 }
	fallthrough
case 1434:
// line 80039 "zparse.go"
	switch data[p] {
		case 9: goto tr4449
		case 10: goto tr4450
		case 32: goto tr4449
		case 40: goto tr4451
		case 41: goto tr4452
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr4454
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st1434
	}
	goto st0
tr4457:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1435
tr4458:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1435
tr4456:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1435
tr4449:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1435
tr4450:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1435
tr4451:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1435
tr4452:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1435
st1435:
	p++
	if p == pe { goto _test_eof1435 }
	fallthrough
case 1435:
// line 80111 "zparse.go"
	switch data[p] {
		case 9: goto st1435
		case 10: goto tr4456
		case 32: goto st1435
		case 40: goto tr4457
		case 41: goto tr4458
		case 43: goto tr263
		case 58: goto tr263
		case 59: goto st1436
		case 61: goto tr263
		case 92: goto tr263
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr263 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr263 }
		} else if data[p] >= 65 {
			goto tr263
		}
	} else {
		goto tr3325
	}
	goto st0
tr4454:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1436
st1436:
	p++
	if p == pe { goto _test_eof1436 }
	fallthrough
case 1436:
// line 80147 "zparse.go"
	if data[p] == 10 { goto tr4456 }
	goto st1436
tr4442:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1437
st1437:
	p++
	if p == pe { goto _test_eof1437 }
	fallthrough
case 1437:
// line 80170 "zparse.go"
	if data[p] == 10 { goto tr4444 }
	goto st1437
tr1124:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1438
st1438:
	p++
	if p == pe { goto _test_eof1438 }
	fallthrough
case 1438:
// line 80184 "zparse.go"
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 79: goto st1439
		case 83: goto st1441
		case 92: goto st113
		case 111: goto st1439
		case 115: goto st1441
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1439:
	p++
	if p == pe { goto _test_eof1439 }
	fallthrough
case 1439:
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 78: goto st1440
		case 92: goto st113
		case 110: goto st1440
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1440:
	p++
	if p == pe { goto _test_eof1440 }
	fallthrough
case 1440:
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 69: goto st1398
		case 92: goto st113
		case 101: goto st1398
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1441:
	p++
	if p == pe { goto _test_eof1441 }
	fallthrough
case 1441:
	switch data[p] {
		case 9: goto tr4463
		case 10: goto tr4464
		case 32: goto tr4463
		case 40: goto tr4465
		case 41: goto tr4466
		case 43: goto st113
		case 59: goto tr4467
		case 61: goto st113
		case 92: goto st113
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
tr4470:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1442
tr4471:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1442
tr4469:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1442
tr4463:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1442
tr4464:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1442
tr4465:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1442
tr4466:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1442
st1442:
	p++
	if p == pe { goto _test_eof1442 }
	fallthrough
case 1442:
// line 80367 "zparse.go"
	switch data[p] {
		case 9: goto st1442
		case 10: goto tr4469
		case 32: goto st1442
		case 40: goto tr4470
		case 41: goto tr4471
		case 43: goto tr3345
		case 59: goto st1443
		case 61: goto tr3345
		case 92: goto tr3345
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr3345 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr3345 }
	} else {
		goto tr3345
	}
	goto st0
tr4467:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1443
st1443:
	p++
	if p == pe { goto _test_eof1443 }
	fallthrough
case 1443:
// line 80407 "zparse.go"
	if data[p] == 10 { goto tr4469 }
	goto st1443
tr1125:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1444
st1444:
	p++
	if p == pe { goto _test_eof1444 }
	fallthrough
case 1444:
// line 80421 "zparse.go"
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 82: goto st1445
		case 92: goto st113
		case 114: goto st1445
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1445:
	p++
	if p == pe { goto _test_eof1445 }
	fallthrough
case 1445:
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 83: goto st1446
		case 92: goto st113
		case 115: goto st1446
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1446:
	p++
	if p == pe { goto _test_eof1446 }
	fallthrough
case 1446:
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 73: goto st1447
		case 92: goto st113
		case 105: goto st1447
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1447:
	p++
	if p == pe { goto _test_eof1447 }
	fallthrough
case 1447:
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 71: goto st1448
		case 92: goto st113
		case 103: goto st1448
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1448:
	p++
	if p == pe { goto _test_eof1448 }
	fallthrough
case 1448:
	switch data[p] {
		case 9: goto tr4477
		case 10: goto tr4478
		case 32: goto tr4477
		case 40: goto tr4479
		case 41: goto tr4480
		case 43: goto st113
		case 59: goto tr4481
		case 61: goto st113
		case 92: goto st113
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
tr4484:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1449
tr4485:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1449
tr4483:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1449
tr4477:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1449
tr4478:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1449
tr4479:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1449
tr4480:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1449
st1449:
	p++
	if p == pe { goto _test_eof1449 }
	fallthrough
case 1449:
// line 80628 "zparse.go"
	switch data[p] {
		case 9: goto st1449
		case 10: goto tr4483
		case 32: goto st1449
		case 40: goto tr4484
		case 41: goto tr4485
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1453
		case 61: goto tr429
		case 92: goto tr429
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 65 {
			goto tr429
		}
	} else {
		goto tr4486
	}
	goto st0
tr4486:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1450
st1450:
	p++
	if p == pe { goto _test_eof1450 }
	fallthrough
case 1450:
// line 80662 "zparse.go"
	switch data[p] {
		case 9: goto tr4488
		case 10: goto tr4489
		case 32: goto tr4488
		case 40: goto tr4490
		case 41: goto tr4491
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr4493
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st1450
	}
	goto st0
tr4496:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1451
tr4497:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1451
tr4495:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1451
tr4488:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1451
tr4489:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1451
tr4490:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1451
tr4491:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1451
st1451:
	p++
	if p == pe { goto _test_eof1451 }
	fallthrough
case 1451:
// line 80734 "zparse.go"
	switch data[p] {
		case 9: goto st1451
		case 10: goto tr4495
		case 32: goto st1451
		case 40: goto tr4496
		case 41: goto tr4497
		case 59: goto st1452
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr3469 }
	goto st0
tr4493:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1452
st1452:
	p++
	if p == pe { goto _test_eof1452 }
	fallthrough
case 1452:
// line 80756 "zparse.go"
	if data[p] == 10 { goto tr4495 }
	goto st1452
tr4481:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1453
st1453:
	p++
	if p == pe { goto _test_eof1453 }
	fallthrough
case 1453:
// line 80779 "zparse.go"
	if data[p] == 10 { goto tr4483 }
	goto st1453
tr1126:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1454
st1454:
	p++
	if p == pe { goto _test_eof1454 }
	fallthrough
case 1454:
// line 80793 "zparse.go"
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 79: goto st1455
		case 92: goto st113
		case 111: goto st1455
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1455:
	p++
	if p == pe { goto _test_eof1455 }
	fallthrough
case 1455:
	switch data[p] {
		case 9: goto tr419
		case 10: goto tr420
		case 32: goto tr419
		case 40: goto tr421
		case 41: goto tr422
		case 43: goto st113
		case 59: goto tr424
		case 61: goto st113
		case 65: goto st1456
		case 92: goto st113
		case 97: goto st1456
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
st1456:
	p++
	if p == pe { goto _test_eof1456 }
	fallthrough
case 1456:
	switch data[p] {
		case 9: goto tr4501
		case 10: goto tr4502
		case 32: goto tr4501
		case 40: goto tr4503
		case 41: goto tr4504
		case 43: goto st113
		case 59: goto tr4505
		case 61: goto st113
		case 92: goto st113
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st113 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st113 }
	} else {
		goto st113
	}
	goto st0
tr4508:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1457
tr4509:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1457
tr4507:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1457
tr4501:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1457
tr4502:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1457
tr4503:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1457
tr4504:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1457
st1457:
	p++
	if p == pe { goto _test_eof1457 }
	fallthrough
case 1457:
// line 80948 "zparse.go"
	switch data[p] {
		case 9: goto st1457
		case 10: goto tr4507
		case 32: goto st1457
		case 40: goto tr4508
		case 41: goto tr4509
		case 43: goto tr4510
		case 59: goto st1474
		case 61: goto tr4510
		case 92: goto tr4510
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto tr4510 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto tr4510 }
	} else {
		goto tr4510
	}
	goto st0
tr4510:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1458
st1458:
	p++
	if p == pe { goto _test_eof1458 }
	fallthrough
case 1458:
// line 80977 "zparse.go"
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 92: goto st1458
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
tr4520:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1459
tr4521:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1459
tr4519:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1459
tr4512:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1459
tr4513:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1459
tr4514:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1459
tr4515:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1459
st1459:
	p++
	if p == pe { goto _test_eof1459 }
	fallthrough
case 1459:
// line 81036 "zparse.go"
	switch data[p] {
		case 9: goto st1459
		case 10: goto tr4519
		case 32: goto st1459
		case 40: goto tr4520
		case 41: goto tr4521
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1473
		case 61: goto tr429
		case 92: goto tr429
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 65 {
			goto tr429
		}
	} else {
		goto tr4522
	}
	goto st0
tr4522:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1460
st1460:
	p++
	if p == pe { goto _test_eof1460 }
	fallthrough
case 1460:
// line 81070 "zparse.go"
	switch data[p] {
		case 9: goto tr4524
		case 10: goto tr4525
		case 32: goto tr4524
		case 40: goto tr4526
		case 41: goto tr4527
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr4529
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st1460
	}
	goto st0
tr4532:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1461
tr4533:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1461
tr4531:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1461
tr4524:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1461
tr4525:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1461
tr4526:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1461
tr4527:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1461
st1461:
	p++
	if p == pe { goto _test_eof1461 }
	fallthrough
case 1461:
// line 81142 "zparse.go"
	switch data[p] {
		case 9: goto st1461
		case 10: goto tr4531
		case 32: goto st1461
		case 40: goto tr4532
		case 41: goto tr4533
		case 59: goto st1472
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4534 }
	goto st0
tr4534:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1462
st1462:
	p++
	if p == pe { goto _test_eof1462 }
	fallthrough
case 1462:
// line 81162 "zparse.go"
	switch data[p] {
		case 9: goto tr4536
		case 10: goto tr4537
		case 32: goto tr4536
		case 40: goto tr4538
		case 41: goto tr4539
		case 59: goto tr4541
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1462 }
	goto st0
tr4544:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1463
tr4545:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1463
tr4543:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1463
tr4536:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1463
tr4537:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1463
tr4538:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1463
tr4539:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1463
st1463:
	p++
	if p == pe { goto _test_eof1463 }
	fallthrough
case 1463:
// line 81212 "zparse.go"
	switch data[p] {
		case 9: goto st1463
		case 10: goto tr4543
		case 32: goto st1463
		case 40: goto tr4544
		case 41: goto tr4545
		case 59: goto st1471
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4546 }
	goto st0
tr4546:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1464
st1464:
	p++
	if p == pe { goto _test_eof1464 }
	fallthrough
case 1464:
// line 81232 "zparse.go"
	switch data[p] {
		case 9: goto tr4548
		case 10: goto tr4549
		case 32: goto tr4548
		case 40: goto tr4550
		case 41: goto tr4551
		case 59: goto tr4553
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1464 }
	goto st0
tr4556:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1465
tr4557:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1465
tr4555:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1465
tr4548:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1465
tr4549:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1465
tr4550:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1465
tr4551:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1465
st1465:
	p++
	if p == pe { goto _test_eof1465 }
	fallthrough
case 1465:
// line 81282 "zparse.go"
	switch data[p] {
		case 9: goto st1465
		case 10: goto tr4555
		case 32: goto st1465
		case 40: goto tr4556
		case 41: goto tr4557
		case 59: goto st1470
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4558 }
	goto st0
tr4558:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1466
st1466:
	p++
	if p == pe { goto _test_eof1466 }
	fallthrough
case 1466:
// line 81302 "zparse.go"
	switch data[p] {
		case 9: goto tr4560
		case 10: goto tr4561
		case 32: goto tr4560
		case 40: goto tr4562
		case 41: goto tr4563
		case 59: goto tr4565
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1466 }
	goto st0
tr4568:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1467
tr4569:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1467
tr4567:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1467
tr4560:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1467
tr4561:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1467
tr4562:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1467
tr4563:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1467
st1467:
	p++
	if p == pe { goto _test_eof1467 }
	fallthrough
case 1467:
// line 81352 "zparse.go"
	switch data[p] {
		case 9: goto st1467
		case 10: goto tr4567
		case 32: goto st1467
		case 40: goto tr4568
		case 41: goto tr4569
		case 59: goto st1469
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4570 }
	goto st0
tr4570:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1468
st1468:
	p++
	if p == pe { goto _test_eof1468 }
	fallthrough
case 1468:
// line 81372 "zparse.go"
	switch data[p] {
		case 9: goto tr4572
		case 10: goto tr4573
		case 32: goto tr4572
		case 40: goto tr4574
		case 41: goto tr4575
		case 59: goto tr4577
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1468 }
	goto st0
tr4565:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1469
st1469:
	p++
	if p == pe { goto _test_eof1469 }
	fallthrough
case 1469:
// line 81392 "zparse.go"
	if data[p] == 10 { goto tr4567 }
	goto st1469
tr4553:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1470
st1470:
	p++
	if p == pe { goto _test_eof1470 }
	fallthrough
case 1470:
// line 81404 "zparse.go"
	if data[p] == 10 { goto tr4555 }
	goto st1470
tr4541:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1471
st1471:
	p++
	if p == pe { goto _test_eof1471 }
	fallthrough
case 1471:
// line 81416 "zparse.go"
	if data[p] == 10 { goto tr4543 }
	goto st1471
tr4529:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1472
st1472:
	p++
	if p == pe { goto _test_eof1472 }
	fallthrough
case 1472:
// line 81430 "zparse.go"
	if data[p] == 10 { goto tr4531 }
	goto st1472
tr4517:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1473
st1473:
	p++
	if p == pe { goto _test_eof1473 }
	fallthrough
case 1473:
// line 81442 "zparse.go"
	if data[p] == 10 { goto tr4519 }
	goto st1473
tr4505:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1474
st1474:
	p++
	if p == pe { goto _test_eof1474 }
	fallthrough
case 1474:
// line 81465 "zparse.go"
	if data[p] == 10 { goto tr4507 }
	goto st1474
tr4165:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1475
tr4160:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 57 "types.rl"
	{
            x := rr.(*RR_RRSIG)
            x.Hdr = *hdr;
            x.TypeCovered = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.Labels = uint8(tok.N[2])
            x.OrigTtl = uint32(tok.N[3])
            x.Expiration = uint32(tok.N[4])
            x.Inception = uint32(tok.N[5])
            x.KeyTag = uint16(tok.N[6])
            x.SignerName = tok.T[0]
            x.Signature = tok.T[1]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1475
st1475:
	p++
	if p == pe { goto _test_eof1475 }
	fallthrough
case 1475:
// line 81497 "zparse.go"
	if data[p] == 10 { goto tr4579 }
	goto st1475
tr4148:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1476
st1476:
	p++
	if p == pe { goto _test_eof1476 }
	fallthrough
case 1476:
// line 81520 "zparse.go"
	if data[p] == 10 { goto tr4150 }
	goto st1476
tr3534:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1477
tr5090:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1477
tr5111:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1477
st1477:
	p++
	if p == pe { goto _test_eof1477 }
	fallthrough
case 1477:
// line 81574 "zparse.go"
	if data[p] == 10 { goto tr4581 }
	goto st1477
tr5454:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1478
st1478:
	p++
	if p == pe { goto _test_eof1478 }
	fallthrough
case 1478:
// line 81586 "zparse.go"
	switch data[p] {
		case 9: goto tr4582
		case 10: goto tr4583
		case 32: goto tr4582
		case 40: goto tr4584
		case 41: goto tr4585
		case 59: goto tr4587
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1478
	}
	goto st0
tr3529:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1479
tr3524:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1479
st1479:
	p++
	if p == pe { goto _test_eof1479 }
	fallthrough
case 1479:
// line 81636 "zparse.go"
	if data[p] == 10 { goto tr4589 }
	goto st1479
tr3512:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1480
st1480:
	p++
	if p == pe { goto _test_eof1480 }
	fallthrough
case 1480:
// line 81648 "zparse.go"
	if data[p] == 10 { goto tr3514 }
	goto st1480
tr3500:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1481
st1481:
	p++
	if p == pe { goto _test_eof1481 }
	fallthrough
case 1481:
// line 81660 "zparse.go"
	if data[p] == 10 { goto tr3502 }
	goto st1481
tr3488:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1482
st1482:
	p++
	if p == pe { goto _test_eof1482 }
	fallthrough
case 1482:
// line 81672 "zparse.go"
	if data[p] == 10 { goto tr3490 }
	goto st1482
tr3476:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1483
st1483:
	p++
	if p == pe { goto _test_eof1483 }
	fallthrough
case 1483:
// line 81684 "zparse.go"
	if data[p] == 10 { goto tr3478 }
	goto st1483
tr3464:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1484
st1484:
	p++
	if p == pe { goto _test_eof1484 }
	fallthrough
case 1484:
// line 81700 "zparse.go"
	if data[p] == 10 { goto tr3466 }
	goto st1484
tr3452:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1485
st1485:
	p++
	if p == pe { goto _test_eof1485 }
	fallthrough
case 1485:
// line 81725 "zparse.go"
	if data[p] == 10 { goto tr3454 }
	goto st1485
tr5429:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1486
st1486:
	p++
	if p == pe { goto _test_eof1486 }
	fallthrough
case 1486:
// line 81739 "zparse.go"
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 79: goto st1487
		case 92: goto st566
		case 95: goto st2
		case 111: goto st1487
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1487:
	p++
	if p == pe { goto _test_eof1487 }
	fallthrough
case 1487:
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 65: goto st1488
		case 92: goto st566
		case 95: goto st2
		case 97: goto st1488
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1488:
	p++
	if p == pe { goto _test_eof1488 }
	fallthrough
case 1488:
	switch data[p] {
		case 9: goto tr4592
		case 10: goto tr4593
		case 32: goto tr4592
		case 40: goto tr4594
		case 41: goto tr4595
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr4596
		case 61: goto st113
		case 92: goto st566
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
tr4599:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1489
tr4600:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1489
tr4598:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1489
tr4592:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1489
tr4593:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1489
tr4594:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1489
tr4595:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1489
st1489:
	p++
	if p == pe { goto _test_eof1489 }
	fallthrough
case 1489:
// line 81911 "zparse.go"
	switch data[p] {
		case 9: goto st1489
		case 10: goto tr4598
		case 32: goto st1489
		case 40: goto tr4599
		case 41: goto tr4600
		case 43: goto tr4510
		case 58: goto tr4510
		case 59: goto st1493
		case 61: goto tr4510
		case 65: goto tr4603
		case 67: goto tr4604
		case 68: goto tr4605
		case 72: goto tr4606
		case 73: goto tr4607
		case 77: goto tr4608
		case 78: goto tr4609
		case 82: goto tr4610
		case 83: goto tr4611
		case 92: goto tr4510
		case 97: goto tr4603
		case 99: goto tr4604
		case 100: goto tr4605
		case 104: goto tr4606
		case 105: goto tr4607
		case 109: goto tr4608
		case 110: goto tr4609
		case 114: goto tr4610
		case 115: goto tr4611
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr4510 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr4510 }
		} else if data[p] >= 66 {
			goto tr4510
		}
	} else {
		goto tr4601
	}
	goto st0
tr4601:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1490
st1490:
	p++
	if p == pe { goto _test_eof1490 }
	fallthrough
case 1490:
// line 81965 "zparse.go"
	switch data[p] {
		case 9: goto tr4612
		case 10: goto tr4613
		case 32: goto tr4612
		case 40: goto tr4614
		case 41: goto tr4615
		case 43: goto st1458
		case 58: goto st1458
		case 59: goto tr4617
		case 61: goto st1458
		case 92: goto st1458
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st1458 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st1458 }
		} else if data[p] >= 65 {
			goto st1458
		}
	} else {
		goto st1490
	}
	goto st0
tr4620:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1491
tr4621:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1491
tr4619:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1491
tr4612:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1491
tr4613:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1491
tr4614:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1491
tr4615:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1491
st1491:
	p++
	if p == pe { goto _test_eof1491 }
	fallthrough
case 1491:
// line 82037 "zparse.go"
	switch data[p] {
		case 9: goto st1491
		case 10: goto tr4619
		case 32: goto st1491
		case 40: goto tr4620
		case 41: goto tr4621
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1492
		case 61: goto tr429
		case 65: goto tr1138
		case 67: goto tr1139
		case 68: goto tr1140
		case 72: goto tr1141
		case 73: goto tr1142
		case 77: goto tr1143
		case 78: goto tr1144
		case 82: goto tr1145
		case 83: goto tr1146
		case 92: goto tr429
		case 97: goto tr1138
		case 99: goto tr1139
		case 100: goto tr1140
		case 104: goto tr1141
		case 105: goto tr1142
		case 109: goto tr1143
		case 110: goto tr1144
		case 114: goto tr1145
		case 115: goto tr1146
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 66 {
			goto tr429
		}
	} else {
		goto tr4522
	}
	goto st0
tr4617:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1492
st1492:
	p++
	if p == pe { goto _test_eof1492 }
	fallthrough
case 1492:
// line 82091 "zparse.go"
	if data[p] == 10 { goto tr4619 }
	goto st1492
tr4596:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1493
st1493:
	p++
	if p == pe { goto _test_eof1493 }
	fallthrough
case 1493:
// line 82116 "zparse.go"
	if data[p] == 10 { goto tr4598 }
	goto st1493
tr4603:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1494
st1494:
	p++
	if p == pe { goto _test_eof1494 }
	fallthrough
case 1494:
// line 82130 "zparse.go"
	switch data[p] {
		case 9: goto tr4623
		case 10: goto tr4624
		case 32: goto tr4623
		case 40: goto tr4625
		case 41: goto tr4626
		case 43: goto st1458
		case 59: goto tr4627
		case 61: goto st1458
		case 65: goto st1512
		case 78: goto st1518
		case 92: goto st1458
		case 97: goto st1512
		case 110: goto st1518
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
tr4632:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1495
tr4633:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1495
tr4631:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1495
tr4623:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1495
tr4624:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1495
tr4625:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1495
tr4626:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1495
st1495:
	p++
	if p == pe { goto _test_eof1495 }
	fallthrough
case 1495:
// line 82237 "zparse.go"
	switch data[p] {
		case 9: goto st1495
		case 10: goto tr4631
		case 32: goto st1495
		case 40: goto tr4632
		case 41: goto tr4633
		case 43: goto tr2120
		case 58: goto tr2120
		case 59: goto st1511
		case 61: goto tr2120
		case 92: goto tr2120
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr2120 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr2120 }
		} else if data[p] >= 65 {
			goto tr2120
		}
	} else {
		goto tr4634
	}
	goto st0
tr4634:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1496
st1496:
	p++
	if p == pe { goto _test_eof1496 }
	fallthrough
case 1496:
// line 82271 "zparse.go"
	switch data[p] {
		case 9: goto tr4636
		case 10: goto tr4637
		case 32: goto tr4636
		case 40: goto tr4638
		case 41: goto tr4639
		case 43: goto st616
		case 58: goto st616
		case 59: goto tr4641
		case 61: goto st616
		case 92: goto st616
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st616 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st616 }
		} else if data[p] >= 65 {
			goto st616
		}
	} else {
		goto st1496
	}
	goto st0
tr4644:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1497
tr4645:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1497
tr4636:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1497
tr4710:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1497
tr4754:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1497
tr4999:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1497
tr4638:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1497
tr4639:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1497
tr4712:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1497
tr4713:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1497
tr4756:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1497
tr4757:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1497
tr5001:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1497
tr5002:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1497
st1497:
	p++
	if p == pe { goto _test_eof1497 }
	fallthrough
case 1497:
// line 82493 "zparse.go"
	switch data[p] {
		case 9: goto st1497
		case 10: goto tr4643
		case 32: goto st1497
		case 40: goto tr4644
		case 41: goto tr4645
		case 59: goto tr4646
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4534 }
	goto st0
tr4643:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1789
tr4696:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1789
tr4637:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1789
tr4711:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1789
tr4755:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1789
tr5000:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1789
st1789:
	p++
	if p == pe { goto _test_eof1789 }
	fallthrough
case 1789:
// line 82583 "zparse.go"
	switch data[p] {
		case 9: goto st1498
		case 10: goto tr4648
		case 32: goto st1498
		case 40: goto tr4649
		case 41: goto tr4650
		case 59: goto tr4652
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5484
	}
	goto st0
tr4649:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1498
tr4650:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1498
st1498:
	p++
	if p == pe { goto _test_eof1498 }
	fallthrough
case 1498:
// line 82619 "zparse.go"
	switch data[p] {
		case 9: goto st1498
		case 10: goto tr4648
		case 32: goto st1498
		case 40: goto tr4649
		case 41: goto tr4650
		case 59: goto tr4652
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4651 }
	goto st0
tr4648:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1790
tr4677:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1790
st1790:
	p++
	if p == pe { goto _test_eof1790 }
	fallthrough
case 1790:
// line 82663 "zparse.go"
	switch data[p] {
		case 9: goto st1498
		case 10: goto tr4648
		case 32: goto st1498
		case 40: goto tr4649
		case 41: goto tr4650
		case 59: goto tr4652
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5485
	}
	goto st0
tr5485:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1499
st1499:
	p++
	if p == pe { goto _test_eof1499 }
	fallthrough
case 1499:
// line 82715 "zparse.go"
	switch data[p] {
		case 9: goto tr4653
		case 10: goto tr4654
		case 32: goto tr4653
		case 40: goto tr4655
		case 41: goto tr4656
		case 59: goto tr4658
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1499
	}
	goto st0
tr4661:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1500
tr4662:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1500
tr4660:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1500
tr4653:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1500
tr4654:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1500
tr4655:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1500
tr4656:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1500
tr4689:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1500
tr4690:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1500
tr4691:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1500
tr4692:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1500
st1500:
	p++
	if p == pe { goto _test_eof1500 }
	fallthrough
case 1500:
// line 82823 "zparse.go"
	switch data[p] {
		case 9: goto st1500
		case 10: goto tr4660
		case 32: goto st1500
		case 40: goto tr4661
		case 41: goto tr4662
		case 59: goto st1504
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4663 }
	goto st0
tr4663:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1501
st1501:
	p++
	if p == pe { goto _test_eof1501 }
	fallthrough
case 1501:
// line 82863 "zparse.go"
	switch data[p] {
		case 9: goto tr4665
		case 10: goto tr4666
		case 32: goto tr4665
		case 40: goto tr4667
		case 41: goto tr4668
		case 59: goto tr4670
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1501 }
	goto st0
tr4673:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1502
tr4674:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1502
tr4672:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1502
tr4665:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1502
tr4666:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1502
tr4667:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1502
tr4668:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1502
st1502:
	p++
	if p == pe { goto _test_eof1502 }
	fallthrough
case 1502:
// line 82921 "zparse.go"
	switch data[p] {
		case 9: goto st1502
		case 10: goto tr4672
		case 32: goto st1502
		case 40: goto tr4673
		case 41: goto tr4674
		case 59: goto st1503
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4558 }
	goto st0
tr4670:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1503
st1503:
	p++
	if p == pe { goto _test_eof1503 }
	fallthrough
case 1503:
// line 82961 "zparse.go"
	if data[p] == 10 { goto tr4672 }
	goto st1503
tr4658:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1504
tr4694:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1504
st1504:
	p++
	if p == pe { goto _test_eof1504 }
	fallthrough
case 1504:
// line 82983 "zparse.go"
	if data[p] == 10 { goto tr4660 }
	goto st1504
tr4652:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1505
st1505:
	p++
	if p == pe { goto _test_eof1505 }
	fallthrough
case 1505:
// line 82995 "zparse.go"
	if data[p] == 10 { goto tr4677 }
	goto st1505
tr4651:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1506
st1506:
	p++
	if p == pe { goto _test_eof1506 }
	fallthrough
case 1506:
// line 83009 "zparse.go"
	switch data[p] {
		case 9: goto tr4678
		case 10: goto tr4679
		case 32: goto tr4678
		case 40: goto tr4680
		case 41: goto tr4681
		case 59: goto tr4683
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1506 }
	goto st0
tr4686:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1507
tr4687:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1507
tr4685:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1507
tr4678:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1507
tr4679:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1507
tr4680:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1507
tr4681:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1507
st1507:
	p++
	if p == pe { goto _test_eof1507 }
	fallthrough
case 1507:
// line 83067 "zparse.go"
	switch data[p] {
		case 9: goto st1507
		case 10: goto tr4685
		case 32: goto st1507
		case 40: goto tr4686
		case 41: goto tr4687
		case 59: goto st1508
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4546 }
	goto st0
tr4683:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1508
st1508:
	p++
	if p == pe { goto _test_eof1508 }
	fallthrough
case 1508:
// line 83107 "zparse.go"
	if data[p] == 10 { goto tr4685 }
	goto st1508
tr5484:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1509
st1509:
	p++
	if p == pe { goto _test_eof1509 }
	fallthrough
case 1509:
// line 83119 "zparse.go"
	switch data[p] {
		case 9: goto tr4689
		case 10: goto tr4690
		case 32: goto tr4689
		case 40: goto tr4691
		case 41: goto tr4692
		case 59: goto tr4694
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1509
	}
	goto st0
tr4646:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1510
tr4641:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 4 "types.rl"
	{
            x := rr.(*RR_A)
            x.Hdr = *hdr
            x.A = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1510
tr4715:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 9 "types.rl"
	{
            x := rr.(*RR_AAAA)
            x.Hdr = *hdr
            x.AAAA = net.ParseIP(tok.T[0])
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1510
tr4759:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 19 "types.rl"
	{
            x := rr.(*RR_CNAME)
            x.Hdr = *hdr
            x.Cname = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1510
tr5004:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 14 "types.rl"
	{
            x := rr.(*RR_NS)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
        }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1510
st1510:
	p++
	if p == pe { goto _test_eof1510 }
	fallthrough
case 1510:
// line 83207 "zparse.go"
	if data[p] == 10 { goto tr4696 }
	goto st1510
tr4627:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1511
st1511:
	p++
	if p == pe { goto _test_eof1511 }
	fallthrough
case 1511:
// line 83230 "zparse.go"
	if data[p] == 10 { goto tr4631 }
	goto st1511
st1512:
	p++
	if p == pe { goto _test_eof1512 }
	fallthrough
case 1512:
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 65: goto st1513
		case 92: goto st1458
		case 97: goto st1513
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1513:
	p++
	if p == pe { goto _test_eof1513 }
	fallthrough
case 1513:
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 65: goto st1514
		case 92: goto st1458
		case 97: goto st1514
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1514:
	p++
	if p == pe { goto _test_eof1514 }
	fallthrough
case 1514:
	switch data[p] {
		case 9: goto tr4699
		case 10: goto tr4700
		case 32: goto tr4699
		case 40: goto tr4701
		case 41: goto tr4702
		case 43: goto st1458
		case 59: goto tr4703
		case 61: goto st1458
		case 92: goto st1458
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
tr4706:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1515
tr4707:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1515
tr4705:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1515
tr4699:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1515
tr4700:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1515
tr4701:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1515
tr4702:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1515
st1515:
	p++
	if p == pe { goto _test_eof1515 }
	fallthrough
case 1515:
// line 83392 "zparse.go"
	switch data[p] {
		case 9: goto st1515
		case 10: goto tr4705
		case 32: goto st1515
		case 40: goto tr4706
		case 41: goto tr4707
		case 43: goto tr4344
		case 58: goto tr4344
		case 59: goto st1517
		case 61: goto tr4344
		case 92: goto tr4344
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr4344 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr4344 }
		} else if data[p] >= 65 {
			goto tr4344
		}
	} else {
		goto tr4708
	}
	goto st0
tr4708:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1516
st1516:
	p++
	if p == pe { goto _test_eof1516 }
	fallthrough
case 1516:
// line 83426 "zparse.go"
	switch data[p] {
		case 9: goto tr4710
		case 10: goto tr4711
		case 32: goto tr4710
		case 40: goto tr4712
		case 41: goto tr4713
		case 43: goto st1395
		case 58: goto st1395
		case 59: goto tr4715
		case 61: goto st1395
		case 92: goto st1395
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st1395 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st1395 }
		} else if data[p] >= 65 {
			goto st1395
		}
	} else {
		goto st1516
	}
	goto st0
tr4703:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1517
st1517:
	p++
	if p == pe { goto _test_eof1517 }
	fallthrough
case 1517:
// line 83471 "zparse.go"
	if data[p] == 10 { goto tr4705 }
	goto st1517
st1518:
	p++
	if p == pe { goto _test_eof1518 }
	fallthrough
case 1518:
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 89: goto st1519
		case 92: goto st1458
		case 121: goto st1519
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1519:
	p++
	if p == pe { goto _test_eof1519 }
	fallthrough
case 1519:
	switch data[p] {
		case 9: goto tr4717
		case 10: goto tr4718
		case 32: goto tr4717
		case 40: goto tr4719
		case 41: goto tr4720
		case 43: goto st1458
		case 59: goto tr4721
		case 61: goto st1458
		case 92: goto st1458
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
tr4724:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1520
tr4725:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1520
tr4723:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1520
tr4717:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1520
tr4718:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1520
tr4719:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1520
tr4720:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1520
st1520:
	p++
	if p == pe { goto _test_eof1520 }
	fallthrough
case 1520:
// line 83571 "zparse.go"
	switch data[p] {
		case 9: goto st1520
		case 10: goto tr4723
		case 32: goto st1520
		case 40: goto tr4724
		case 41: goto tr4725
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1524
		case 61: goto tr429
		case 65: goto tr4364
		case 67: goto tr4365
		case 68: goto tr1140
		case 77: goto tr1143
		case 78: goto tr4366
		case 82: goto tr1145
		case 83: goto tr1146
		case 92: goto tr429
		case 97: goto tr4364
		case 99: goto tr4365
		case 100: goto tr1140
		case 109: goto tr1143
		case 110: goto tr4366
		case 114: goto tr1145
		case 115: goto tr1146
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 66 {
			goto tr429
		}
	} else {
		goto tr4726
	}
	goto st0
tr4726:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1521
st1521:
	p++
	if p == pe { goto _test_eof1521 }
	fallthrough
case 1521:
// line 83619 "zparse.go"
	switch data[p] {
		case 9: goto tr4728
		case 10: goto tr4729
		case 32: goto tr4728
		case 40: goto tr4730
		case 41: goto tr4731
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr4733
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st1521
	}
	goto st0
tr4736:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1522
tr4737:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1522
tr4735:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1522
tr4728:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1522
tr4729:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1522
tr4730:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1522
tr4731:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1522
st1522:
	p++
	if p == pe { goto _test_eof1522 }
	fallthrough
case 1522:
// line 83699 "zparse.go"
	switch data[p] {
		case 9: goto st1522
		case 10: goto tr4735
		case 32: goto st1522
		case 40: goto tr4736
		case 41: goto tr4737
		case 59: goto st1523
		case 65: goto tr105
		case 67: goto tr106
		case 68: goto tr40
		case 77: goto tr43
		case 78: goto tr107
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr105
		case 99: goto tr106
		case 100: goto tr40
		case 109: goto tr43
		case 110: goto tr107
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4534 }
	goto st0
tr4733:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1523
st1523:
	p++
	if p == pe { goto _test_eof1523 }
	fallthrough
case 1523:
// line 83737 "zparse.go"
	if data[p] == 10 { goto tr4735 }
	goto st1523
tr4721:
// line 91 "zparse.rl"
	{ hdr.Class = Str_class[data[mark:p]] }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1524
st1524:
	p++
	if p == pe { goto _test_eof1524 }
	fallthrough
case 1524:
// line 83751 "zparse.go"
	if data[p] == 10 { goto tr4723 }
	goto st1524
tr4604:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1525
st1525:
	p++
	if p == pe { goto _test_eof1525 }
	fallthrough
case 1525:
// line 83765 "zparse.go"
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 72: goto st1519
		case 78: goto st1526
		case 83: goto st1519
		case 92: goto st1458
		case 104: goto st1519
		case 110: goto st1526
		case 115: goto st1519
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1526:
	p++
	if p == pe { goto _test_eof1526 }
	fallthrough
case 1526:
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 65: goto st1527
		case 92: goto st1458
		case 97: goto st1527
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1527:
	p++
	if p == pe { goto _test_eof1527 }
	fallthrough
case 1527:
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 77: goto st1528
		case 92: goto st1458
		case 109: goto st1528
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1528:
	p++
	if p == pe { goto _test_eof1528 }
	fallthrough
case 1528:
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 69: goto st1529
		case 92: goto st1458
		case 101: goto st1529
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1529:
	p++
	if p == pe { goto _test_eof1529 }
	fallthrough
case 1529:
	switch data[p] {
		case 9: goto tr4743
		case 10: goto tr4744
		case 32: goto tr4743
		case 40: goto tr4745
		case 41: goto tr4746
		case 43: goto st1458
		case 59: goto tr4747
		case 61: goto st1458
		case 92: goto st1458
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
tr4750:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1530
tr4751:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1530
tr4749:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1530
tr4743:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1530
tr4744:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1530
tr4745:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1530
tr4746:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1530
st1530:
	p++
	if p == pe { goto _test_eof1530 }
	fallthrough
case 1530:
// line 83976 "zparse.go"
	switch data[p] {
		case 9: goto st1530
		case 10: goto tr4749
		case 32: goto st1530
		case 40: goto tr4750
		case 41: goto tr4751
		case 43: goto tr3090
		case 58: goto tr3090
		case 59: goto st1532
		case 61: goto tr3090
		case 92: goto tr3090
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr3090 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr3090 }
		} else if data[p] >= 65 {
			goto tr3090
		}
	} else {
		goto tr4752
	}
	goto st0
tr4752:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1531
st1531:
	p++
	if p == pe { goto _test_eof1531 }
	fallthrough
case 1531:
// line 84010 "zparse.go"
	switch data[p] {
		case 9: goto tr4754
		case 10: goto tr4755
		case 32: goto tr4754
		case 40: goto tr4756
		case 41: goto tr4757
		case 43: goto st965
		case 58: goto st965
		case 59: goto tr4759
		case 61: goto st965
		case 92: goto st965
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st965 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st965 }
		} else if data[p] >= 65 {
			goto st965
		}
	} else {
		goto st1531
	}
	goto st0
tr4747:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1532
st1532:
	p++
	if p == pe { goto _test_eof1532 }
	fallthrough
case 1532:
// line 84055 "zparse.go"
	if data[p] == 10 { goto tr4749 }
	goto st1532
tr4605:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1533
st1533:
	p++
	if p == pe { goto _test_eof1533 }
	fallthrough
case 1533:
// line 84069 "zparse.go"
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 78: goto st1534
		case 83: goto st1560
		case 92: goto st1458
		case 110: goto st1534
		case 115: goto st1560
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1534:
	p++
	if p == pe { goto _test_eof1534 }
	fallthrough
case 1534:
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 83: goto st1535
		case 92: goto st1458
		case 115: goto st1535
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1535:
	p++
	if p == pe { goto _test_eof1535 }
	fallthrough
case 1535:
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 75: goto st1536
		case 92: goto st1458
		case 107: goto st1536
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1536:
	p++
	if p == pe { goto _test_eof1536 }
	fallthrough
case 1536:
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 69: goto st1537
		case 92: goto st1458
		case 101: goto st1537
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1537:
	p++
	if p == pe { goto _test_eof1537 }
	fallthrough
case 1537:
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 89: goto st1538
		case 92: goto st1458
		case 121: goto st1538
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1538:
	p++
	if p == pe { goto _test_eof1538 }
	fallthrough
case 1538:
	switch data[p] {
		case 9: goto tr4766
		case 10: goto tr4767
		case 32: goto tr4766
		case 40: goto tr4768
		case 41: goto tr4769
		case 43: goto st1458
		case 59: goto tr4770
		case 61: goto st1458
		case 92: goto st1458
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
tr4773:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1539
tr4774:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1539
tr4772:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1539
tr4766:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1539
tr4767:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1539
tr4768:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1539
tr4769:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1539
st1539:
	p++
	if p == pe { goto _test_eof1539 }
	fallthrough
case 1539:
// line 84304 "zparse.go"
	switch data[p] {
		case 9: goto st1539
		case 10: goto tr4772
		case 32: goto st1539
		case 40: goto tr4773
		case 41: goto tr4774
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1559
		case 61: goto tr429
		case 92: goto tr429
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 65 {
			goto tr429
		}
	} else {
		goto tr4775
	}
	goto st0
tr4775:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1540
st1540:
	p++
	if p == pe { goto _test_eof1540 }
	fallthrough
case 1540:
// line 84338 "zparse.go"
	switch data[p] {
		case 9: goto tr4777
		case 10: goto tr4778
		case 32: goto tr4777
		case 40: goto tr4779
		case 41: goto tr4780
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr4782
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st1540
	}
	goto st0
tr4785:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1541
tr4786:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1541
tr4784:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1541
tr4777:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1541
tr4778:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1541
tr4779:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1541
tr4780:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1541
st1541:
	p++
	if p == pe { goto _test_eof1541 }
	fallthrough
case 1541:
// line 84410 "zparse.go"
	switch data[p] {
		case 9: goto st1541
		case 10: goto tr4784
		case 32: goto st1541
		case 40: goto tr4785
		case 41: goto tr4786
		case 59: goto st1558
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4787 }
	goto st0
tr4787:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1542
st1542:
	p++
	if p == pe { goto _test_eof1542 }
	fallthrough
case 1542:
// line 84430 "zparse.go"
	switch data[p] {
		case 9: goto tr4789
		case 10: goto tr4790
		case 32: goto tr4789
		case 40: goto tr4791
		case 41: goto tr4792
		case 59: goto tr4794
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1542 }
	goto st0
tr4797:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1543
tr4798:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1543
tr4796:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1543
tr4789:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1543
tr4790:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1543
tr4791:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1543
tr4792:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1543
st1543:
	p++
	if p == pe { goto _test_eof1543 }
	fallthrough
case 1543:
// line 84480 "zparse.go"
	switch data[p] {
		case 9: goto st1543
		case 10: goto tr4796
		case 32: goto st1543
		case 40: goto tr4797
		case 41: goto tr4798
		case 59: goto st1557
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4799 }
	goto st0
tr4799:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1544
st1544:
	p++
	if p == pe { goto _test_eof1544 }
	fallthrough
case 1544:
// line 84500 "zparse.go"
	switch data[p] {
		case 9: goto tr4801
		case 10: goto tr4802
		case 32: goto tr4801
		case 40: goto tr4803
		case 41: goto tr4804
		case 59: goto tr4806
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1544 }
	goto st0
tr4809:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1545
tr4810:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1545
tr4808:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1545
tr4801:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1545
tr4802:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1545
tr4803:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1545
tr4804:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1545
st1545:
	p++
	if p == pe { goto _test_eof1545 }
	fallthrough
case 1545:
// line 84550 "zparse.go"
	switch data[p] {
		case 9: goto st1545
		case 10: goto tr4808
		case 32: goto st1545
		case 40: goto tr4809
		case 41: goto tr4810
		case 43: goto tr180
		case 58: goto tr180
		case 59: goto st1556
		case 61: goto tr180
		case 92: goto tr180
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr180 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr180 }
		} else if data[p] >= 65 {
			goto tr180
		}
	} else {
		goto tr4811
	}
	goto st0
tr4811:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1546
st1546:
	p++
	if p == pe { goto _test_eof1546 }
	fallthrough
case 1546:
// line 84584 "zparse.go"
	switch data[p] {
		case 9: goto tr4813
		case 10: goto tr4814
		case 32: goto tr4813
		case 40: goto tr4815
		case 41: goto tr4816
		case 43: goto st46
		case 58: goto st46
		case 59: goto tr4818
		case 61: goto st46
		case 92: goto st46
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st46 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st46 }
		} else if data[p] >= 65 {
			goto st46
		}
	} else {
		goto st1546
	}
	goto st0
tr4821:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1547
tr4822:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1547
tr5175:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1547
tr4813:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1547
tr4815:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1547
tr4816:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1547
tr4906:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1547
tr4908:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1547
tr4909:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1547
tr5177:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1547
tr5178:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1547
st1547:
	p++
	if p == pe { goto _test_eof1547 }
	fallthrough
case 1547:
// line 84790 "zparse.go"
	switch data[p] {
		case 9: goto st1547
		case 10: goto tr4820
		case 32: goto st1547
		case 40: goto tr4821
		case 41: goto tr4822
		case 59: goto tr4823
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4570 }
	goto st0
tr4820:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1791
tr4858:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1791
tr4814:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1791
tr4907:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1791
tr5176:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1791
st1791:
	p++
	if p == pe { goto _test_eof1791 }
	fallthrough
case 1791:
// line 84874 "zparse.go"
	switch data[p] {
		case 9: goto st1548
		case 10: goto tr4825
		case 32: goto st1548
		case 40: goto tr4826
		case 41: goto tr4827
		case 59: goto tr4829
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5486
	}
	goto st0
tr4826:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1548
tr4827:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1548
st1548:
	p++
	if p == pe { goto _test_eof1548 }
	fallthrough
case 1548:
// line 84910 "zparse.go"
	switch data[p] {
		case 9: goto st1548
		case 10: goto tr4825
		case 32: goto st1548
		case 40: goto tr4826
		case 41: goto tr4827
		case 59: goto tr4829
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4828 }
	goto st0
tr4825:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1792
tr4837:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1792
st1792:
	p++
	if p == pe { goto _test_eof1792 }
	fallthrough
case 1792:
// line 84954 "zparse.go"
	switch data[p] {
		case 9: goto st1548
		case 10: goto tr4825
		case 32: goto st1548
		case 40: goto tr4826
		case 41: goto tr4827
		case 59: goto tr4829
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5487
	}
	goto st0
tr5487:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1549
st1549:
	p++
	if p == pe { goto _test_eof1549 }
	fallthrough
case 1549:
// line 85006 "zparse.go"
	switch data[p] {
		case 9: goto tr4830
		case 10: goto tr4831
		case 32: goto tr4830
		case 40: goto tr4832
		case 41: goto tr4833
		case 59: goto tr4835
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1549
	}
	goto st0
tr4829:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1550
st1550:
	p++
	if p == pe { goto _test_eof1550 }
	fallthrough
case 1550:
// line 85038 "zparse.go"
	if data[p] == 10 { goto tr4837 }
	goto st1550
tr4828:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1551
st1551:
	p++
	if p == pe { goto _test_eof1551 }
	fallthrough
case 1551:
// line 85052 "zparse.go"
	switch data[p] {
		case 9: goto tr4838
		case 10: goto tr4839
		case 32: goto tr4838
		case 40: goto tr4840
		case 41: goto tr4841
		case 59: goto tr4843
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1551 }
	goto st0
tr4846:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1552
tr4847:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1552
tr4838:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1552
tr4840:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1552
tr4841:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1552
st1552:
	p++
	if p == pe { goto _test_eof1552 }
	fallthrough
case 1552:
// line 85140 "zparse.go"
	switch data[p] {
		case 9: goto st1552
		case 10: goto tr4845
		case 32: goto st1552
		case 40: goto tr4846
		case 41: goto tr4847
		case 59: goto tr4848
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr489 }
	goto st0
tr4845:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1793
tr4850:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1793
tr4839:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1793
st1793:
	p++
	if p == pe { goto _test_eof1793 }
	fallthrough
case 1793:
// line 85206 "zparse.go"
	switch data[p] {
		case 9: goto st381
		case 10: goto tr1337
		case 32: goto st381
		case 40: goto tr1338
		case 41: goto tr1339
		case 59: goto tr1341
		case 65: goto tr5347
		case 67: goto tr5348
		case 68: goto tr5349
		case 72: goto tr5350
		case 73: goto tr5351
		case 77: goto tr5352
		case 78: goto tr5353
		case 82: goto tr5354
		case 83: goto tr5355
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5347
		case 99: goto tr5348
		case 100: goto tr5349
		case 104: goto tr5350
		case 105: goto tr5351
		case 109: goto tr5352
		case 110: goto tr5353
		case 114: goto tr5354
		case 115: goto tr5355
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5399
	}
	goto st0
tr4848:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1553
tr4843:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1553
st1553:
	p++
	if p == pe { goto _test_eof1553 }
	fallthrough
case 1553:
// line 85276 "zparse.go"
	if data[p] == 10 { goto tr4850 }
	goto st1553
tr5486:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1554
st1554:
	p++
	if p == pe { goto _test_eof1554 }
	fallthrough
case 1554:
// line 85288 "zparse.go"
	switch data[p] {
		case 9: goto tr4851
		case 10: goto tr4852
		case 32: goto tr4851
		case 40: goto tr4853
		case 41: goto tr4854
		case 59: goto tr4856
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1554
	}
	goto st0
tr4823:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1555
tr5180:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1555
tr4818:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 49 "types.rl"
	{
            x := rr.(*RR_DNSKEY)
            x.Hdr = *hdr;
            x.Flags = uint16(tok.N[0])
            x.Protocol = uint8(tok.N[1])
            x.Algorithm = uint8(tok.N[2])
            x.PublicKey = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1555
tr4911:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 41 "types.rl"
	{
            x := rr.(*RR_DS)
            x.Hdr = *hdr;
            x.KeyTag = uint16(tok.N[0])
            x.Algorithm = uint8(tok.N[1])
            x.DigestType = uint8(tok.N[2])
            x.Digest = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1555
st1555:
	p++
	if p == pe { goto _test_eof1555 }
	fallthrough
case 1555:
// line 85372 "zparse.go"
	if data[p] == 10 { goto tr4858 }
	goto st1555
tr4806:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1556
st1556:
	p++
	if p == pe { goto _test_eof1556 }
	fallthrough
case 1556:
// line 85384 "zparse.go"
	if data[p] == 10 { goto tr4808 }
	goto st1556
tr4794:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1557
st1557:
	p++
	if p == pe { goto _test_eof1557 }
	fallthrough
case 1557:
// line 85396 "zparse.go"
	if data[p] == 10 { goto tr4796 }
	goto st1557
tr4782:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1558
st1558:
	p++
	if p == pe { goto _test_eof1558 }
	fallthrough
case 1558:
// line 85410 "zparse.go"
	if data[p] == 10 { goto tr4784 }
	goto st1558
tr4770:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1559
st1559:
	p++
	if p == pe { goto _test_eof1559 }
	fallthrough
case 1559:
// line 85433 "zparse.go"
	if data[p] == 10 { goto tr4772 }
	goto st1559
st1560:
	p++
	if p == pe { goto _test_eof1560 }
	fallthrough
case 1560:
	switch data[p] {
		case 9: goto tr4859
		case 10: goto tr4860
		case 32: goto tr4859
		case 40: goto tr4861
		case 41: goto tr4862
		case 43: goto st1458
		case 59: goto tr4863
		case 61: goto st1458
		case 92: goto st1458
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
tr4866:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1561
tr4867:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1561
tr4865:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1561
tr4859:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1561
tr4860:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1561
tr4861:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1561
tr4862:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1561
st1561:
	p++
	if p == pe { goto _test_eof1561 }
	fallthrough
case 1561:
// line 85543 "zparse.go"
	switch data[p] {
		case 9: goto st1561
		case 10: goto tr4865
		case 32: goto st1561
		case 40: goto tr4866
		case 41: goto tr4867
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1572
		case 61: goto tr429
		case 92: goto tr429
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 65 {
			goto tr429
		}
	} else {
		goto tr4868
	}
	goto st0
tr4868:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1562
st1562:
	p++
	if p == pe { goto _test_eof1562 }
	fallthrough
case 1562:
// line 85577 "zparse.go"
	switch data[p] {
		case 9: goto tr4870
		case 10: goto tr4871
		case 32: goto tr4870
		case 40: goto tr4872
		case 41: goto tr4873
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr4875
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st1562
	}
	goto st0
tr4878:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1563
tr4879:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1563
tr4877:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1563
tr4870:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1563
tr4871:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1563
tr4872:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1563
tr4873:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1563
st1563:
	p++
	if p == pe { goto _test_eof1563 }
	fallthrough
case 1563:
// line 85649 "zparse.go"
	switch data[p] {
		case 9: goto st1563
		case 10: goto tr4877
		case 32: goto st1563
		case 40: goto tr4878
		case 41: goto tr4879
		case 59: goto st1571
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4880 }
	goto st0
tr4880:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1564
st1564:
	p++
	if p == pe { goto _test_eof1564 }
	fallthrough
case 1564:
// line 85669 "zparse.go"
	switch data[p] {
		case 9: goto tr4882
		case 10: goto tr4883
		case 32: goto tr4882
		case 40: goto tr4884
		case 41: goto tr4885
		case 59: goto tr4887
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1564 }
	goto st0
tr4890:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1565
tr4891:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1565
tr4889:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1565
tr4882:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1565
tr4883:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1565
tr4884:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1565
tr4885:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1565
st1565:
	p++
	if p == pe { goto _test_eof1565 }
	fallthrough
case 1565:
// line 85719 "zparse.go"
	switch data[p] {
		case 9: goto st1565
		case 10: goto tr4889
		case 32: goto st1565
		case 40: goto tr4890
		case 41: goto tr4891
		case 59: goto st1570
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4892 }
	goto st0
tr4892:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1566
st1566:
	p++
	if p == pe { goto _test_eof1566 }
	fallthrough
case 1566:
// line 85739 "zparse.go"
	switch data[p] {
		case 9: goto tr4894
		case 10: goto tr4895
		case 32: goto tr4894
		case 40: goto tr4896
		case 41: goto tr4897
		case 59: goto tr4899
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1566 }
	goto st0
tr4902:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1567
tr4903:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1567
tr4901:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1567
tr4894:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1567
tr4895:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1567
tr4896:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1567
tr4897:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1567
st1567:
	p++
	if p == pe { goto _test_eof1567 }
	fallthrough
case 1567:
// line 85789 "zparse.go"
	switch data[p] {
		case 9: goto st1567
		case 10: goto tr4901
		case 32: goto st1567
		case 40: goto tr4902
		case 41: goto tr4903
		case 43: goto tr233
		case 58: goto tr233
		case 59: goto st1569
		case 61: goto tr233
		case 92: goto tr233
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr233 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr233 }
		} else if data[p] >= 65 {
			goto tr233
		}
	} else {
		goto tr4904
	}
	goto st0
tr4904:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1568
st1568:
	p++
	if p == pe { goto _test_eof1568 }
	fallthrough
case 1568:
// line 85823 "zparse.go"
	switch data[p] {
		case 9: goto tr4906
		case 10: goto tr4907
		case 32: goto tr4906
		case 40: goto tr4908
		case 41: goto tr4909
		case 43: goto st59
		case 58: goto st59
		case 59: goto tr4911
		case 61: goto st59
		case 92: goto st59
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st59 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st59 }
		} else if data[p] >= 65 {
			goto st59
		}
	} else {
		goto st1568
	}
	goto st0
tr4899:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1569
st1569:
	p++
	if p == pe { goto _test_eof1569 }
	fallthrough
case 1569:
// line 85857 "zparse.go"
	if data[p] == 10 { goto tr4901 }
	goto st1569
tr4887:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1570
st1570:
	p++
	if p == pe { goto _test_eof1570 }
	fallthrough
case 1570:
// line 85869 "zparse.go"
	if data[p] == 10 { goto tr4889 }
	goto st1570
tr4875:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1571
st1571:
	p++
	if p == pe { goto _test_eof1571 }
	fallthrough
case 1571:
// line 85883 "zparse.go"
	if data[p] == 10 { goto tr4877 }
	goto st1571
tr4863:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1572
st1572:
	p++
	if p == pe { goto _test_eof1572 }
	fallthrough
case 1572:
// line 85906 "zparse.go"
	if data[p] == 10 { goto tr4865 }
	goto st1572
tr4606:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1573
st1573:
	p++
	if p == pe { goto _test_eof1573 }
	fallthrough
case 1573:
// line 85920 "zparse.go"
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 83: goto st1519
		case 92: goto st1458
		case 115: goto st1519
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
tr4607:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1574
st1574:
	p++
	if p == pe { goto _test_eof1574 }
	fallthrough
case 1574:
// line 85953 "zparse.go"
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 78: goto st1519
		case 92: goto st1458
		case 110: goto st1519
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
tr4608:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1575
st1575:
	p++
	if p == pe { goto _test_eof1575 }
	fallthrough
case 1575:
// line 85986 "zparse.go"
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 88: goto st1576
		case 92: goto st1458
		case 120: goto st1576
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1576:
	p++
	if p == pe { goto _test_eof1576 }
	fallthrough
case 1576:
	switch data[p] {
		case 9: goto tr4913
		case 10: goto tr4914
		case 32: goto tr4913
		case 40: goto tr4915
		case 41: goto tr4916
		case 43: goto st1458
		case 59: goto tr4917
		case 61: goto st1458
		case 92: goto st1458
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
tr4920:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1577
tr4921:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1577
tr4919:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1577
tr4913:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1577
tr4914:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1577
tr4915:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1577
tr4916:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1577
st1577:
	p++
	if p == pe { goto _test_eof1577 }
	fallthrough
case 1577:
// line 86115 "zparse.go"
	switch data[p] {
		case 9: goto st1577
		case 10: goto tr4919
		case 32: goto st1577
		case 40: goto tr4920
		case 41: goto tr4921
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1593
		case 61: goto tr429
		case 92: goto tr429
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 65 {
			goto tr429
		}
	} else {
		goto tr4922
	}
	goto st0
tr4922:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1578
st1578:
	p++
	if p == pe { goto _test_eof1578 }
	fallthrough
case 1578:
// line 86149 "zparse.go"
	switch data[p] {
		case 9: goto tr4924
		case 10: goto tr4925
		case 32: goto tr4924
		case 40: goto tr4926
		case 41: goto tr4927
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr4929
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st1578
	}
	goto st0
tr4932:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1579
tr4933:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1579
tr4931:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1579
tr4924:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1579
tr4925:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1579
tr4926:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1579
tr4927:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1579
st1579:
	p++
	if p == pe { goto _test_eof1579 }
	fallthrough
case 1579:
// line 86221 "zparse.go"
	switch data[p] {
		case 9: goto st1579
		case 10: goto tr4931
		case 32: goto st1579
		case 40: goto tr4932
		case 41: goto tr4933
		case 43: goto tr263
		case 58: goto tr263
		case 59: goto st1592
		case 61: goto tr263
		case 92: goto tr263
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr263 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr263 }
		} else if data[p] >= 65 {
			goto tr263
		}
	} else {
		goto tr4934
	}
	goto st0
tr4934:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1580
st1580:
	p++
	if p == pe { goto _test_eof1580 }
	fallthrough
case 1580:
// line 86255 "zparse.go"
	switch data[p] {
		case 9: goto tr4936
		case 10: goto tr4937
		case 32: goto tr4936
		case 40: goto tr4938
		case 41: goto tr4939
		case 43: goto st69
		case 58: goto st69
		case 59: goto tr4941
		case 61: goto st69
		case 92: goto st69
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st69 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st69 }
		} else if data[p] >= 65 {
			goto st69
		}
	} else {
		goto st1580
	}
	goto st0
tr4944:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1581
tr4945:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1581
tr4936:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1581
tr4938:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1581
tr4939:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1581
st1581:
	p++
	if p == pe { goto _test_eof1581 }
	fallthrough
case 1581:
// line 86342 "zparse.go"
	switch data[p] {
		case 9: goto st1581
		case 10: goto tr4943
		case 32: goto st1581
		case 40: goto tr4944
		case 41: goto tr4945
		case 59: goto tr4946
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4546 }
	goto st0
tr4943:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1794
tr4984:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1794
tr4937:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1794
st1794:
	p++
	if p == pe { goto _test_eof1794 }
	fallthrough
case 1794:
// line 86385 "zparse.go"
	switch data[p] {
		case 9: goto st1582
		case 10: goto tr4948
		case 32: goto st1582
		case 40: goto tr4949
		case 41: goto tr4950
		case 59: goto tr4951
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5488
	}
	goto st0
tr4949:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1582
tr4950:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1582
st1582:
	p++
	if p == pe { goto _test_eof1582 }
	fallthrough
case 1582:
// line 86421 "zparse.go"
	switch data[p] {
		case 9: goto st1582
		case 10: goto tr4948
		case 32: goto st1582
		case 40: goto tr4949
		case 41: goto tr4950
		case 59: goto tr4951
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4663 }
	goto st0
tr4948:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1795
tr4976:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1795
st1795:
	p++
	if p == pe { goto _test_eof1795 }
	fallthrough
case 1795:
// line 86465 "zparse.go"
	switch data[p] {
		case 9: goto st1582
		case 10: goto tr4948
		case 32: goto st1582
		case 40: goto tr4949
		case 41: goto tr4950
		case 59: goto tr4951
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5489
	}
	goto st0
tr5489:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1583
st1583:
	p++
	if p == pe { goto _test_eof1583 }
	fallthrough
case 1583:
// line 86517 "zparse.go"
	switch data[p] {
		case 9: goto tr4952
		case 10: goto tr4953
		case 32: goto tr4952
		case 40: goto tr4954
		case 41: goto tr4955
		case 59: goto tr4957
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1583
	}
	goto st0
tr4960:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1584
tr4961:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1584
tr4959:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1584
tr4952:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1584
tr4953:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1584
tr4954:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1584
tr4955:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1584
tr4977:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1584
tr4978:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1584
tr4979:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1584
tr4980:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1584
st1584:
	p++
	if p == pe { goto _test_eof1584 }
	fallthrough
case 1584:
// line 86625 "zparse.go"
	switch data[p] {
		case 9: goto st1584
		case 10: goto tr4959
		case 32: goto st1584
		case 40: goto tr4960
		case 41: goto tr4961
		case 59: goto st1588
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4962 }
	goto st0
tr4962:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1585
st1585:
	p++
	if p == pe { goto _test_eof1585 }
	fallthrough
case 1585:
// line 86665 "zparse.go"
	switch data[p] {
		case 9: goto tr4964
		case 10: goto tr4965
		case 32: goto tr4964
		case 40: goto tr4966
		case 41: goto tr4967
		case 59: goto tr4969
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1585 }
	goto st0
tr4972:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1586
tr4973:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1586
tr4971:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1586
tr4964:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1586
tr4965:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1586
tr4966:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1586
tr4967:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1586
st1586:
	p++
	if p == pe { goto _test_eof1586 }
	fallthrough
case 1586:
// line 86723 "zparse.go"
	switch data[p] {
		case 9: goto st1586
		case 10: goto tr4971
		case 32: goto st1586
		case 40: goto tr4972
		case 41: goto tr4973
		case 59: goto st1587
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr4570 }
	goto st0
tr4969:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1587
st1587:
	p++
	if p == pe { goto _test_eof1587 }
	fallthrough
case 1587:
// line 86763 "zparse.go"
	if data[p] == 10 { goto tr4971 }
	goto st1587
tr4957:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1588
tr4982:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1588
st1588:
	p++
	if p == pe { goto _test_eof1588 }
	fallthrough
case 1588:
// line 86785 "zparse.go"
	if data[p] == 10 { goto tr4959 }
	goto st1588
tr4951:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1589
st1589:
	p++
	if p == pe { goto _test_eof1589 }
	fallthrough
case 1589:
// line 86797 "zparse.go"
	if data[p] == 10 { goto tr4976 }
	goto st1589
tr5488:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1590
st1590:
	p++
	if p == pe { goto _test_eof1590 }
	fallthrough
case 1590:
// line 86809 "zparse.go"
	switch data[p] {
		case 9: goto tr4977
		case 10: goto tr4978
		case 32: goto tr4977
		case 40: goto tr4979
		case 41: goto tr4980
		case 59: goto tr4982
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1590
	}
	goto st0
tr4946:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1591
tr4941:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 35 "types.rl"
	{
            x := rr.(*RR_MX)
            x.Hdr = *hdr;
            x.Pref = uint16(tok.N[0])
            x.Mx = tok.T[0]
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1591
st1591:
	p++
	if p == pe { goto _test_eof1591 }
	fallthrough
case 1591:
// line 86856 "zparse.go"
	if data[p] == 10 { goto tr4984 }
	goto st1591
tr4929:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1592
st1592:
	p++
	if p == pe { goto _test_eof1592 }
	fallthrough
case 1592:
// line 86870 "zparse.go"
	if data[p] == 10 { goto tr4931 }
	goto st1592
tr4917:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1593
st1593:
	p++
	if p == pe { goto _test_eof1593 }
	fallthrough
case 1593:
// line 86893 "zparse.go"
	if data[p] == 10 { goto tr4919 }
	goto st1593
tr4609:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1594
st1594:
	p++
	if p == pe { goto _test_eof1594 }
	fallthrough
case 1594:
// line 86907 "zparse.go"
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 79: goto st1595
		case 83: goto st1597
		case 92: goto st1458
		case 111: goto st1595
		case 115: goto st1597
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1595:
	p++
	if p == pe { goto _test_eof1595 }
	fallthrough
case 1595:
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 78: goto st1596
		case 92: goto st1458
		case 110: goto st1596
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1596:
	p++
	if p == pe { goto _test_eof1596 }
	fallthrough
case 1596:
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 69: goto st1519
		case 92: goto st1458
		case 101: goto st1519
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1597:
	p++
	if p == pe { goto _test_eof1597 }
	fallthrough
case 1597:
	switch data[p] {
		case 9: goto tr4988
		case 10: goto tr4989
		case 32: goto tr4988
		case 40: goto tr4990
		case 41: goto tr4991
		case 43: goto st1458
		case 59: goto tr4992
		case 61: goto st1458
		case 92: goto st1458
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
tr4995:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1598
tr4996:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1598
tr4994:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1598
tr4988:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1598
tr4989:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1598
tr4990:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1598
tr4991:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1598
st1598:
	p++
	if p == pe { goto _test_eof1598 }
	fallthrough
case 1598:
// line 87090 "zparse.go"
	switch data[p] {
		case 9: goto st1598
		case 10: goto tr4994
		case 32: goto st1598
		case 40: goto tr4995
		case 41: goto tr4996
		case 43: goto tr3345
		case 58: goto tr3345
		case 59: goto st1600
		case 61: goto tr3345
		case 92: goto tr3345
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr3345 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr3345 }
		} else if data[p] >= 65 {
			goto tr3345
		}
	} else {
		goto tr4997
	}
	goto st0
tr4997:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1599
st1599:
	p++
	if p == pe { goto _test_eof1599 }
	fallthrough
case 1599:
// line 87124 "zparse.go"
	switch data[p] {
		case 9: goto tr4999
		case 10: goto tr5000
		case 32: goto tr4999
		case 40: goto tr5001
		case 41: goto tr5002
		case 43: goto st1049
		case 58: goto st1049
		case 59: goto tr5004
		case 61: goto st1049
		case 92: goto st1049
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st1049 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st1049 }
		} else if data[p] >= 65 {
			goto st1049
		}
	} else {
		goto st1599
	}
	goto st0
tr4992:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1600
st1600:
	p++
	if p == pe { goto _test_eof1600 }
	fallthrough
case 1600:
// line 87169 "zparse.go"
	if data[p] == 10 { goto tr4994 }
	goto st1600
tr4610:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1601
st1601:
	p++
	if p == pe { goto _test_eof1601 }
	fallthrough
case 1601:
// line 87183 "zparse.go"
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 82: goto st1602
		case 92: goto st1458
		case 114: goto st1602
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1602:
	p++
	if p == pe { goto _test_eof1602 }
	fallthrough
case 1602:
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 83: goto st1603
		case 92: goto st1458
		case 115: goto st1603
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1603:
	p++
	if p == pe { goto _test_eof1603 }
	fallthrough
case 1603:
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 73: goto st1604
		case 92: goto st1458
		case 105: goto st1604
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1604:
	p++
	if p == pe { goto _test_eof1604 }
	fallthrough
case 1604:
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 71: goto st1605
		case 92: goto st1458
		case 103: goto st1605
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1605:
	p++
	if p == pe { goto _test_eof1605 }
	fallthrough
case 1605:
	switch data[p] {
		case 9: goto tr5009
		case 10: goto tr5010
		case 32: goto tr5009
		case 40: goto tr5011
		case 41: goto tr5012
		case 43: goto st1458
		case 59: goto tr5013
		case 61: goto st1458
		case 92: goto st1458
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
tr5016:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1606
tr5017:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1606
tr5015:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1606
tr5009:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1606
tr5010:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1606
tr5011:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1606
tr5012:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1606
st1606:
	p++
	if p == pe { goto _test_eof1606 }
	fallthrough
case 1606:
// line 87390 "zparse.go"
	switch data[p] {
		case 9: goto st1606
		case 10: goto tr5015
		case 32: goto st1606
		case 40: goto tr5016
		case 41: goto tr5017
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1629
		case 61: goto tr429
		case 92: goto tr429
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 65 {
			goto tr429
		}
	} else {
		goto tr5018
	}
	goto st0
tr5018:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1607
st1607:
	p++
	if p == pe { goto _test_eof1607 }
	fallthrough
case 1607:
// line 87424 "zparse.go"
	switch data[p] {
		case 9: goto tr5020
		case 10: goto tr5021
		case 32: goto tr5020
		case 40: goto tr5022
		case 41: goto tr5023
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr5025
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st1607
	}
	goto st0
tr5028:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1608
tr5029:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1608
tr5027:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1608
tr5020:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1608
tr5021:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1608
tr5022:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1608
tr5023:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1608
st1608:
	p++
	if p == pe { goto _test_eof1608 }
	fallthrough
case 1608:
// line 87496 "zparse.go"
	switch data[p] {
		case 9: goto st1608
		case 10: goto tr5027
		case 32: goto st1608
		case 40: goto tr5028
		case 41: goto tr5029
		case 59: goto st1628
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr5030 }
	goto st0
tr5030:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1609
st1609:
	p++
	if p == pe { goto _test_eof1609 }
	fallthrough
case 1609:
// line 87516 "zparse.go"
	switch data[p] {
		case 9: goto tr5032
		case 10: goto tr5033
		case 32: goto tr5032
		case 40: goto tr5034
		case 41: goto tr5035
		case 59: goto tr5037
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1609 }
	goto st0
tr5040:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1610
tr5041:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1610
tr5039:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1610
tr5032:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1610
tr5033:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1610
tr5034:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1610
tr5035:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1610
st1610:
	p++
	if p == pe { goto _test_eof1610 }
	fallthrough
case 1610:
// line 87566 "zparse.go"
	switch data[p] {
		case 9: goto st1610
		case 10: goto tr5039
		case 32: goto st1610
		case 40: goto tr5040
		case 41: goto tr5041
		case 59: goto st1627
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr5042 }
	goto st0
tr5042:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1611
st1611:
	p++
	if p == pe { goto _test_eof1611 }
	fallthrough
case 1611:
// line 87586 "zparse.go"
	switch data[p] {
		case 9: goto tr5044
		case 10: goto tr5045
		case 32: goto tr5044
		case 40: goto tr5046
		case 41: goto tr5047
		case 59: goto tr5049
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1611 }
	goto st0
tr5052:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1612
tr5053:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1612
tr5051:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1612
tr5044:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1612
tr5045:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1612
tr5046:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1612
tr5047:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1612
st1612:
	p++
	if p == pe { goto _test_eof1612 }
	fallthrough
case 1612:
// line 87636 "zparse.go"
	switch data[p] {
		case 9: goto st1612
		case 10: goto tr5051
		case 32: goto st1612
		case 40: goto tr5052
		case 41: goto tr5053
		case 59: goto st1626
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr5054 }
	goto st0
tr5054:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1613
st1613:
	p++
	if p == pe { goto _test_eof1613 }
	fallthrough
case 1613:
// line 87656 "zparse.go"
	switch data[p] {
		case 9: goto tr5056
		case 10: goto tr5057
		case 32: goto tr5056
		case 40: goto tr5058
		case 41: goto tr5059
		case 59: goto tr5061
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1613 }
	goto st0
tr5064:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1614
tr5065:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1614
tr5063:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1614
tr5056:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1614
tr5057:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1614
tr5058:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1614
tr5059:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1614
st1614:
	p++
	if p == pe { goto _test_eof1614 }
	fallthrough
case 1614:
// line 87706 "zparse.go"
	switch data[p] {
		case 9: goto st1614
		case 10: goto tr5063
		case 32: goto st1614
		case 40: goto tr5064
		case 41: goto tr5065
		case 59: goto st1625
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr5066 }
	goto st0
tr5066:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1615
st1615:
	p++
	if p == pe { goto _test_eof1615 }
	fallthrough
case 1615:
// line 87726 "zparse.go"
	switch data[p] {
		case 9: goto tr5068
		case 10: goto tr5069
		case 32: goto tr5068
		case 40: goto tr5070
		case 41: goto tr5071
		case 59: goto tr5073
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1615 }
	goto st0
tr5076:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1616
tr5077:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1616
tr5068:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1616
tr5070:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1616
tr5071:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1616
st1616:
	p++
	if p == pe { goto _test_eof1616 }
	fallthrough
case 1616:
// line 87808 "zparse.go"
	switch data[p] {
		case 9: goto st1616
		case 10: goto tr5075
		case 32: goto st1616
		case 40: goto tr5076
		case 41: goto tr5077
		case 59: goto tr5078
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr3517 }
	goto st0
tr5075:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1796
tr5113:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1796
tr5069:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1796
st1796:
	p++
	if p == pe { goto _test_eof1796 }
	fallthrough
case 1796:
// line 87854 "zparse.go"
	switch data[p] {
		case 9: goto st1617
		case 10: goto tr5080
		case 32: goto st1617
		case 40: goto tr5081
		case 41: goto tr5082
		case 59: goto tr5084
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto tr5490
	}
	goto st0
tr5081:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1617
tr5082:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1617
st1617:
	p++
	if p == pe { goto _test_eof1617 }
	fallthrough
case 1617:
// line 87890 "zparse.go"
	switch data[p] {
		case 9: goto st1617
		case 10: goto tr5080
		case 32: goto st1617
		case 40: goto tr5081
		case 41: goto tr5082
		case 59: goto tr5084
		case 65: goto tr7
		case 67: goto tr8
		case 68: goto tr9
		case 72: goto tr10
		case 73: goto tr11
		case 77: goto tr12
		case 78: goto tr13
		case 82: goto tr14
		case 83: goto tr15
		case 97: goto tr7
		case 99: goto tr8
		case 100: goto tr9
		case 104: goto tr10
		case 105: goto tr11
		case 109: goto tr12
		case 110: goto tr13
		case 114: goto tr14
		case 115: goto tr15
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr5083 }
	goto st0
tr5080:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1797
tr5092:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1797
st1797:
	p++
	if p == pe { goto _test_eof1797 }
	fallthrough
case 1797:
// line 87934 "zparse.go"
	switch data[p] {
		case 9: goto st1617
		case 10: goto tr5080
		case 32: goto st1617
		case 40: goto tr5081
		case 41: goto tr5082
		case 59: goto tr5084
		case 65: goto tr5338
		case 67: goto tr5339
		case 68: goto tr5340
		case 72: goto tr5341
		case 73: goto tr5342
		case 77: goto tr5343
		case 78: goto tr5344
		case 82: goto tr5345
		case 83: goto tr5346
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5338
		case 99: goto tr5339
		case 100: goto tr5340
		case 104: goto tr5341
		case 105: goto tr5342
		case 109: goto tr5343
		case 110: goto tr5344
		case 114: goto tr5345
		case 115: goto tr5346
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5491
	}
	goto st0
tr5491:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1618
st1618:
	p++
	if p == pe { goto _test_eof1618 }
	fallthrough
case 1618:
// line 87986 "zparse.go"
	switch data[p] {
		case 9: goto tr5085
		case 10: goto tr5086
		case 32: goto tr5085
		case 40: goto tr5087
		case 41: goto tr5088
		case 59: goto tr5090
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1618
	}
	goto st0
tr5084:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1619
st1619:
	p++
	if p == pe { goto _test_eof1619 }
	fallthrough
case 1619:
// line 88018 "zparse.go"
	if data[p] == 10 { goto tr5092 }
	goto st1619
tr5083:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1620
st1620:
	p++
	if p == pe { goto _test_eof1620 }
	fallthrough
case 1620:
// line 88032 "zparse.go"
	switch data[p] {
		case 9: goto tr5093
		case 10: goto tr5094
		case 32: goto tr5093
		case 40: goto tr5095
		case 41: goto tr5096
		case 59: goto tr5098
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1620 }
	goto st0
tr5101:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1621
tr5102:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1621
tr5093:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1621
tr5095:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1621
tr5096:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1621
st1621:
	p++
	if p == pe { goto _test_eof1621 }
	fallthrough
case 1621:
// line 88120 "zparse.go"
	switch data[p] {
		case 9: goto st1621
		case 10: goto tr5100
		case 32: goto st1621
		case 40: goto tr5101
		case 41: goto tr5102
		case 59: goto tr5103
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr374 }
	goto st0
tr5100:
// line 101 "zparse.rl"
	{ lines++ }
// line 89 "zparse.rl"
	{ mark = p }
	goto st1798
tr5105:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1798
tr5094:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1798
st1798:
	p++
	if p == pe { goto _test_eof1798 }
	fallthrough
case 1798:
// line 88186 "zparse.go"
	switch data[p] {
		case 9: goto st1104
		case 10: goto tr3531
		case 32: goto st1104
		case 40: goto tr3532
		case 41: goto tr3533
		case 59: goto tr3534
		case 65: goto tr5347
		case 67: goto tr5348
		case 68: goto tr5349
		case 72: goto tr5350
		case 73: goto tr5351
		case 77: goto tr5352
		case 78: goto tr5353
		case 82: goto tr5354
		case 83: goto tr5355
		case 92: goto st2
		case 95: goto st2
		case 97: goto tr5347
		case 99: goto tr5348
		case 100: goto tr5349
		case 104: goto tr5350
		case 105: goto tr5351
		case 109: goto tr5352
		case 110: goto tr5353
		case 114: goto tr5354
		case 115: goto tr5355
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 66 {
			goto st2
		}
	} else {
		goto tr5454
	}
	goto st0
tr5103:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1622
tr5098:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1622
st1622:
	p++
	if p == pe { goto _test_eof1622 }
	fallthrough
case 1622:
// line 88256 "zparse.go"
	if data[p] == 10 { goto tr5105 }
	goto st1622
tr5490:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1623
st1623:
	p++
	if p == pe { goto _test_eof1623 }
	fallthrough
case 1623:
// line 88268 "zparse.go"
	switch data[p] {
		case 9: goto tr5106
		case 10: goto tr5107
		case 32: goto tr5106
		case 40: goto tr5108
		case 41: goto tr5109
		case 59: goto tr5111
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1623
	}
	goto st0
tr5078:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1624
tr5073:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1624
st1624:
	p++
	if p == pe { goto _test_eof1624 }
	fallthrough
case 1624:
// line 88318 "zparse.go"
	if data[p] == 10 { goto tr5113 }
	goto st1624
tr5061:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1625
st1625:
	p++
	if p == pe { goto _test_eof1625 }
	fallthrough
case 1625:
// line 88330 "zparse.go"
	if data[p] == 10 { goto tr5063 }
	goto st1625
tr5049:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1626
st1626:
	p++
	if p == pe { goto _test_eof1626 }
	fallthrough
case 1626:
// line 88342 "zparse.go"
	if data[p] == 10 { goto tr5051 }
	goto st1626
tr5037:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1627
st1627:
	p++
	if p == pe { goto _test_eof1627 }
	fallthrough
case 1627:
// line 88354 "zparse.go"
	if data[p] == 10 { goto tr5039 }
	goto st1627
tr5025:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1628
st1628:
	p++
	if p == pe { goto _test_eof1628 }
	fallthrough
case 1628:
// line 88368 "zparse.go"
	if data[p] == 10 { goto tr5027 }
	goto st1628
tr5013:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1629
st1629:
	p++
	if p == pe { goto _test_eof1629 }
	fallthrough
case 1629:
// line 88391 "zparse.go"
	if data[p] == 10 { goto tr5015 }
	goto st1629
tr4611:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1630
st1630:
	p++
	if p == pe { goto _test_eof1630 }
	fallthrough
case 1630:
// line 88405 "zparse.go"
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 79: goto st1631
		case 92: goto st1458
		case 111: goto st1631
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1631:
	p++
	if p == pe { goto _test_eof1631 }
	fallthrough
case 1631:
	switch data[p] {
		case 9: goto tr4512
		case 10: goto tr4513
		case 32: goto tr4512
		case 40: goto tr4514
		case 41: goto tr4515
		case 43: goto st1458
		case 59: goto tr4517
		case 61: goto st1458
		case 65: goto st1632
		case 92: goto st1458
		case 97: goto st1632
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
st1632:
	p++
	if p == pe { goto _test_eof1632 }
	fallthrough
case 1632:
	switch data[p] {
		case 9: goto tr5116
		case 10: goto tr5117
		case 32: goto tr5116
		case 40: goto tr5118
		case 41: goto tr5119
		case 43: goto st1458
		case 59: goto tr5120
		case 61: goto st1458
		case 92: goto st1458
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1458 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1458 }
	} else {
		goto st1458
	}
	goto st0
tr5123:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1633
tr5124:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1633
tr5122:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1633
tr5116:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1633
tr5117:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 101 "zparse.rl"
	{ lines++ }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1633
tr5118:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1633
tr5119:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1633
st1633:
	p++
	if p == pe { goto _test_eof1633 }
	fallthrough
case 1633:
// line 88560 "zparse.go"
	switch data[p] {
		case 9: goto st1633
		case 10: goto tr5122
		case 32: goto st1633
		case 40: goto tr5123
		case 41: goto tr5124
		case 43: goto tr4510
		case 58: goto tr4510
		case 59: goto st1647
		case 61: goto tr4510
		case 92: goto tr4510
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr4510 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr4510 }
		} else if data[p] >= 65 {
			goto tr4510
		}
	} else {
		goto tr5125
	}
	goto st0
tr5125:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1634
st1634:
	p++
	if p == pe { goto _test_eof1634 }
	fallthrough
case 1634:
// line 88594 "zparse.go"
	switch data[p] {
		case 9: goto tr5127
		case 10: goto tr5128
		case 32: goto tr5127
		case 40: goto tr5129
		case 41: goto tr5130
		case 43: goto st1458
		case 58: goto st1458
		case 59: goto tr5132
		case 61: goto st1458
		case 92: goto st1458
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st1458 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st1458 }
		} else if data[p] >= 65 {
			goto st1458
		}
	} else {
		goto st1634
	}
	goto st0
tr5135:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1635
tr5136:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1635
tr5134:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1635
tr5127:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1635
tr5128:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1635
tr5129:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1635
tr5130:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1635
st1635:
	p++
	if p == pe { goto _test_eof1635 }
	fallthrough
case 1635:
// line 88666 "zparse.go"
	switch data[p] {
		case 9: goto st1635
		case 10: goto tr5134
		case 32: goto st1635
		case 40: goto tr5135
		case 41: goto tr5136
		case 43: goto tr429
		case 58: goto tr429
		case 59: goto st1646
		case 61: goto tr429
		case 92: goto tr429
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr429 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto tr429 }
		} else if data[p] >= 65 {
			goto tr429
		}
	} else {
		goto tr5137
	}
	goto st0
tr5137:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1636
st1636:
	p++
	if p == pe { goto _test_eof1636 }
	fallthrough
case 1636:
// line 88700 "zparse.go"
	switch data[p] {
		case 9: goto tr5139
		case 10: goto tr5140
		case 32: goto tr5139
		case 40: goto tr5141
		case 41: goto tr5142
		case 43: goto st115
		case 58: goto st115
		case 59: goto tr5144
		case 61: goto st115
		case 92: goto st115
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st115 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st115 }
		} else if data[p] >= 65 {
			goto st115
		}
	} else {
		goto st1636
	}
	goto st0
tr5147:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1637
tr5148:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1637
tr5146:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1637
tr5139:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1637
tr5140:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1637
tr5141:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1637
tr5142:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1637
st1637:
	p++
	if p == pe { goto _test_eof1637 }
	fallthrough
case 1637:
// line 88772 "zparse.go"
	switch data[p] {
		case 9: goto st1637
		case 10: goto tr5146
		case 32: goto st1637
		case 40: goto tr5147
		case 41: goto tr5148
		case 59: goto st1645
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr5149 }
	goto st0
tr5149:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1638
st1638:
	p++
	if p == pe { goto _test_eof1638 }
	fallthrough
case 1638:
// line 88792 "zparse.go"
	switch data[p] {
		case 9: goto tr5151
		case 10: goto tr5152
		case 32: goto tr5151
		case 40: goto tr5153
		case 41: goto tr5154
		case 59: goto tr5156
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1638 }
	goto st0
tr5159:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1639
tr5160:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1639
tr5158:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1639
tr5151:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1639
tr5152:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1639
tr5153:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1639
tr5154:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1639
st1639:
	p++
	if p == pe { goto _test_eof1639 }
	fallthrough
case 1639:
// line 88842 "zparse.go"
	switch data[p] {
		case 9: goto st1639
		case 10: goto tr5158
		case 32: goto st1639
		case 40: goto tr5159
		case 41: goto tr5160
		case 59: goto st1644
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr5161 }
	goto st0
tr5161:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1640
st1640:
	p++
	if p == pe { goto _test_eof1640 }
	fallthrough
case 1640:
// line 88862 "zparse.go"
	switch data[p] {
		case 9: goto tr5163
		case 10: goto tr5164
		case 32: goto tr5163
		case 40: goto tr5165
		case 41: goto tr5166
		case 59: goto tr5168
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1640 }
	goto st0
tr5171:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1641
tr5172:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1641
tr5170:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1641
tr5163:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1641
tr5164:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 101 "zparse.rl"
	{ lines++ }
	goto st1641
tr5165:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1641
tr5166:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1641
st1641:
	p++
	if p == pe { goto _test_eof1641 }
	fallthrough
case 1641:
// line 88912 "zparse.go"
	switch data[p] {
		case 9: goto st1641
		case 10: goto tr5170
		case 32: goto st1641
		case 40: goto tr5171
		case 41: goto tr5172
		case 59: goto st1643
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr5173 }
	goto st0
tr5173:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1642
st1642:
	p++
	if p == pe { goto _test_eof1642 }
	fallthrough
case 1642:
// line 88932 "zparse.go"
	switch data[p] {
		case 9: goto tr5175
		case 10: goto tr5176
		case 32: goto tr5175
		case 40: goto tr5177
		case 41: goto tr5178
		case 59: goto tr5180
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1642 }
	goto st0
tr5168:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1643
st1643:
	p++
	if p == pe { goto _test_eof1643 }
	fallthrough
case 1643:
// line 88952 "zparse.go"
	if data[p] == 10 { goto tr5170 }
	goto st1643
tr5156:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1644
st1644:
	p++
	if p == pe { goto _test_eof1644 }
	fallthrough
case 1644:
// line 88964 "zparse.go"
	if data[p] == 10 { goto tr5158 }
	goto st1644
tr5144:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1645
st1645:
	p++
	if p == pe { goto _test_eof1645 }
	fallthrough
case 1645:
// line 88978 "zparse.go"
	if data[p] == 10 { goto tr5146 }
	goto st1645
tr5132:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1646
st1646:
	p++
	if p == pe { goto _test_eof1646 }
	fallthrough
case 1646:
// line 88992 "zparse.go"
	if data[p] == 10 { goto tr5134 }
	goto st1646
tr5120:
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1647
st1647:
	p++
	if p == pe { goto _test_eof1647 }
	fallthrough
case 1647:
// line 89015 "zparse.go"
	if data[p] == 10 { goto tr5122 }
	goto st1647
tr5452:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1648
st1648:
	p++
	if p == pe { goto _test_eof1648 }
	fallthrough
case 1648:
// line 89027 "zparse.go"
	switch data[p] {
		case 9: goto tr5181
		case 10: goto tr5182
		case 32: goto tr5181
		case 40: goto tr5183
		case 41: goto tr5184
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr5186
		case 61: goto st113
		case 92: goto st566
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st566 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st566 }
		} else if data[p] >= 65 {
			goto st566
		}
	} else {
		goto st1648
	}
	goto st0
st1649:
	p++
	if p == pe { goto _test_eof1649 }
	fallthrough
case 1649:
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 65: goto st1650
		case 92: goto st566
		case 95: goto st2
		case 97: goto st1650
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1650:
	p++
	if p == pe { goto _test_eof1650 }
	fallthrough
case 1650:
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 65: goto st1651
		case 92: goto st566
		case 95: goto st2
		case 97: goto st1651
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
st1651:
	p++
	if p == pe { goto _test_eof1651 }
	fallthrough
case 1651:
	switch data[p] {
		case 9: goto tr5189
		case 10: goto tr5190
		case 32: goto tr5189
		case 40: goto tr5191
		case 41: goto tr5192
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr5193
		case 61: goto st113
		case 92: goto st566
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
tr5196:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1652
tr5197:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1652
tr5195:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1652
tr5189:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1652
tr5190:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 101 "zparse.rl"
	{ lines++ }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1652
tr5191:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1652
tr5192:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1652
st1652:
	p++
	if p == pe { goto _test_eof1652 }
	fallthrough
case 1652:
// line 89230 "zparse.go"
	switch data[p] {
		case 9: goto st1652
		case 10: goto tr5195
		case 32: goto st1652
		case 40: goto tr5196
		case 41: goto tr5197
		case 43: goto tr4344
		case 58: goto tr4344
		case 59: goto st1654
		case 61: goto tr4344
		case 65: goto tr5200
		case 67: goto tr5201
		case 68: goto tr5202
		case 72: goto tr5203
		case 73: goto tr5204
		case 77: goto tr5205
		case 78: goto tr5206
		case 82: goto tr5207
		case 83: goto tr5208
		case 92: goto tr4344
		case 97: goto tr5200
		case 99: goto tr5201
		case 100: goto tr5202
		case 104: goto tr5203
		case 105: goto tr5204
		case 109: goto tr5205
		case 110: goto tr5206
		case 114: goto tr5207
		case 115: goto tr5208
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto tr4344 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 98 <= data[p] && data[p] <= 122 { goto tr4344 }
		} else if data[p] >= 66 {
			goto tr4344
		}
	} else {
		goto tr5198
	}
	goto st0
tr5198:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1653
st1653:
	p++
	if p == pe { goto _test_eof1653 }
	fallthrough
case 1653:
// line 89284 "zparse.go"
	switch data[p] {
		case 9: goto tr5209
		case 10: goto tr5210
		case 32: goto tr5209
		case 40: goto tr5211
		case 41: goto tr5212
		case 43: goto st1395
		case 58: goto st1395
		case 59: goto tr5214
		case 61: goto st1395
		case 92: goto st1395
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 47 { goto st1395 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st1395 }
		} else if data[p] >= 65 {
			goto st1395
		}
	} else {
		goto st1653
	}
	goto st0
tr5193:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
	goto st1654
st1654:
	p++
	if p == pe { goto _test_eof1654 }
	fallthrough
case 1654:
// line 89331 "zparse.go"
	if data[p] == 10 { goto tr5195 }
	goto st1654
tr5200:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1655
st1655:
	p++
	if p == pe { goto _test_eof1655 }
	fallthrough
case 1655:
// line 89345 "zparse.go"
	switch data[p] {
		case 9: goto tr5215
		case 10: goto tr5216
		case 32: goto tr5215
		case 40: goto tr5217
		case 41: goto tr5218
		case 43: goto st1395
		case 59: goto tr5219
		case 61: goto st1395
		case 65: goto st1656
		case 78: goto st1659
		case 92: goto st1395
		case 97: goto st1656
		case 110: goto st1659
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1656:
	p++
	if p == pe { goto _test_eof1656 }
	fallthrough
case 1656:
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 65: goto st1657
		case 92: goto st1395
		case 97: goto st1657
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1657:
	p++
	if p == pe { goto _test_eof1657 }
	fallthrough
case 1657:
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 65: goto st1658
		case 92: goto st1395
		case 97: goto st1658
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1658:
	p++
	if p == pe { goto _test_eof1658 }
	fallthrough
case 1658:
	switch data[p] {
		case 9: goto tr5224
		case 10: goto tr5225
		case 32: goto tr5224
		case 40: goto tr5226
		case 41: goto tr5227
		case 43: goto st1395
		case 59: goto tr5228
		case 61: goto st1395
		case 92: goto st1395
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1659:
	p++
	if p == pe { goto _test_eof1659 }
	fallthrough
case 1659:
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 89: goto st1660
		case 92: goto st1395
		case 121: goto st1660
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1660:
	p++
	if p == pe { goto _test_eof1660 }
	fallthrough
case 1660:
	switch data[p] {
		case 9: goto tr5230
		case 10: goto tr5231
		case 32: goto tr5230
		case 40: goto tr5232
		case 41: goto tr5233
		case 43: goto st1395
		case 59: goto tr5234
		case 61: goto st1395
		case 92: goto st1395
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
tr5201:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1661
st1661:
	p++
	if p == pe { goto _test_eof1661 }
	fallthrough
case 1661:
// line 89506 "zparse.go"
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 72: goto st1660
		case 78: goto st1662
		case 83: goto st1660
		case 92: goto st1395
		case 104: goto st1660
		case 110: goto st1662
		case 115: goto st1660
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1662:
	p++
	if p == pe { goto _test_eof1662 }
	fallthrough
case 1662:
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 65: goto st1663
		case 92: goto st1395
		case 97: goto st1663
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1663:
	p++
	if p == pe { goto _test_eof1663 }
	fallthrough
case 1663:
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 77: goto st1664
		case 92: goto st1395
		case 109: goto st1664
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1664:
	p++
	if p == pe { goto _test_eof1664 }
	fallthrough
case 1664:
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 69: goto st1665
		case 92: goto st1395
		case 101: goto st1665
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1665:
	p++
	if p == pe { goto _test_eof1665 }
	fallthrough
case 1665:
	switch data[p] {
		case 9: goto tr5239
		case 10: goto tr5240
		case 32: goto tr5239
		case 40: goto tr5241
		case 41: goto tr5242
		case 43: goto st1395
		case 59: goto tr5243
		case 61: goto st1395
		case 92: goto st1395
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
tr5202:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1666
st1666:
	p++
	if p == pe { goto _test_eof1666 }
	fallthrough
case 1666:
// line 89645 "zparse.go"
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 78: goto st1667
		case 83: goto st1672
		case 92: goto st1395
		case 110: goto st1667
		case 115: goto st1672
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1667:
	p++
	if p == pe { goto _test_eof1667 }
	fallthrough
case 1667:
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 83: goto st1668
		case 92: goto st1395
		case 115: goto st1668
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1668:
	p++
	if p == pe { goto _test_eof1668 }
	fallthrough
case 1668:
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 75: goto st1669
		case 92: goto st1395
		case 107: goto st1669
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1669:
	p++
	if p == pe { goto _test_eof1669 }
	fallthrough
case 1669:
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 69: goto st1670
		case 92: goto st1395
		case 101: goto st1670
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1670:
	p++
	if p == pe { goto _test_eof1670 }
	fallthrough
case 1670:
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 89: goto st1671
		case 92: goto st1395
		case 121: goto st1671
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1671:
	p++
	if p == pe { goto _test_eof1671 }
	fallthrough
case 1671:
	switch data[p] {
		case 9: goto tr5250
		case 10: goto tr5251
		case 32: goto tr5250
		case 40: goto tr5252
		case 41: goto tr5253
		case 43: goto st1395
		case 59: goto tr5254
		case 61: goto st1395
		case 92: goto st1395
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1672:
	p++
	if p == pe { goto _test_eof1672 }
	fallthrough
case 1672:
	switch data[p] {
		case 9: goto tr5255
		case 10: goto tr5256
		case 32: goto tr5255
		case 40: goto tr5257
		case 41: goto tr5258
		case 43: goto st1395
		case 59: goto tr5259
		case 61: goto st1395
		case 92: goto st1395
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
tr5203:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1673
st1673:
	p++
	if p == pe { goto _test_eof1673 }
	fallthrough
case 1673:
// line 89832 "zparse.go"
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 83: goto st1660
		case 92: goto st1395
		case 115: goto st1660
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
tr5204:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1674
st1674:
	p++
	if p == pe { goto _test_eof1674 }
	fallthrough
case 1674:
// line 89865 "zparse.go"
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 78: goto st1660
		case 92: goto st1395
		case 110: goto st1660
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
tr5205:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1675
st1675:
	p++
	if p == pe { goto _test_eof1675 }
	fallthrough
case 1675:
// line 89898 "zparse.go"
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 88: goto st1676
		case 92: goto st1395
		case 120: goto st1676
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1676:
	p++
	if p == pe { goto _test_eof1676 }
	fallthrough
case 1676:
	switch data[p] {
		case 9: goto tr5261
		case 10: goto tr5262
		case 32: goto tr5261
		case 40: goto tr5263
		case 41: goto tr5264
		case 43: goto st1395
		case 59: goto tr5265
		case 61: goto st1395
		case 92: goto st1395
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
tr5206:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1677
st1677:
	p++
	if p == pe { goto _test_eof1677 }
	fallthrough
case 1677:
// line 89955 "zparse.go"
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 79: goto st1678
		case 83: goto st1680
		case 92: goto st1395
		case 111: goto st1678
		case 115: goto st1680
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1678:
	p++
	if p == pe { goto _test_eof1678 }
	fallthrough
case 1678:
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 78: goto st1679
		case 92: goto st1395
		case 110: goto st1679
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1679:
	p++
	if p == pe { goto _test_eof1679 }
	fallthrough
case 1679:
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 69: goto st1660
		case 92: goto st1395
		case 101: goto st1660
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1680:
	p++
	if p == pe { goto _test_eof1680 }
	fallthrough
case 1680:
	switch data[p] {
		case 9: goto tr5269
		case 10: goto tr5270
		case 32: goto tr5269
		case 40: goto tr5271
		case 41: goto tr5272
		case 43: goto st1395
		case 59: goto tr5273
		case 61: goto st1395
		case 92: goto st1395
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
tr5207:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1681
st1681:
	p++
	if p == pe { goto _test_eof1681 }
	fallthrough
case 1681:
// line 90066 "zparse.go"
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 82: goto st1682
		case 92: goto st1395
		case 114: goto st1682
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1682:
	p++
	if p == pe { goto _test_eof1682 }
	fallthrough
case 1682:
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 83: goto st1683
		case 92: goto st1395
		case 115: goto st1683
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1683:
	p++
	if p == pe { goto _test_eof1683 }
	fallthrough
case 1683:
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 73: goto st1684
		case 92: goto st1395
		case 105: goto st1684
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1684:
	p++
	if p == pe { goto _test_eof1684 }
	fallthrough
case 1684:
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 71: goto st1685
		case 92: goto st1395
		case 103: goto st1685
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1685:
	p++
	if p == pe { goto _test_eof1685 }
	fallthrough
case 1685:
	switch data[p] {
		case 9: goto tr5278
		case 10: goto tr5279
		case 32: goto tr5278
		case 40: goto tr5280
		case 41: goto tr5281
		case 43: goto st1395
		case 59: goto tr5282
		case 61: goto st1395
		case 92: goto st1395
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
tr5208:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1686
st1686:
	p++
	if p == pe { goto _test_eof1686 }
	fallthrough
case 1686:
// line 90201 "zparse.go"
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 79: goto st1687
		case 92: goto st1395
		case 111: goto st1687
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1687:
	p++
	if p == pe { goto _test_eof1687 }
	fallthrough
case 1687:
	switch data[p] {
		case 9: goto tr4346
		case 10: goto tr4347
		case 32: goto tr4346
		case 40: goto tr4348
		case 41: goto tr4349
		case 43: goto st1395
		case 59: goto tr4351
		case 61: goto st1395
		case 65: goto st1688
		case 92: goto st1395
		case 97: goto st1688
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1688:
	p++
	if p == pe { goto _test_eof1688 }
	fallthrough
case 1688:
	switch data[p] {
		case 9: goto tr5285
		case 10: goto tr5286
		case 32: goto tr5285
		case 40: goto tr5287
		case 41: goto tr5288
		case 43: goto st1395
		case 59: goto tr5289
		case 61: goto st1395
		case 92: goto st1395
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st1395 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st1395 }
	} else {
		goto st1395
	}
	goto st0
st1689:
	p++
	if p == pe { goto _test_eof1689 }
	fallthrough
case 1689:
	switch data[p] {
		case 9: goto tr1945
		case 10: goto tr1946
		case 32: goto tr1945
		case 40: goto tr1947
		case 41: goto tr1948
		case 43: goto st113
		case 47: goto st113
		case 58: goto st113
		case 59: goto tr1950
		case 61: goto st113
		case 89: goto st959
		case 92: goto st566
		case 95: goto st2
		case 121: goto st959
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st566 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st566 }
	} else {
		goto st566
	}
	goto st0
tr5405:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1690
st1690:
	p++
	if p == pe { goto _test_eof1690 }
	fallthrough
case 1690:
// line 90311 "zparse.go"
	switch data[p] {
		case 9: goto tr5290
		case 10: goto tr5291
		case 32: goto tr5290
		case 40: goto tr5292
		case 41: goto tr5293
		case 59: goto tr5295
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1690
	}
	goto st0
tr1614:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1691
st1691:
	p++
	if p == pe { goto _test_eof1691 }
	fallthrough
case 1691:
// line 90343 "zparse.go"
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 72: goto st465
		case 78: goto st1138
		case 83: goto st465
		case 92: goto st97
		case 104: goto st465
		case 110: goto st1138
		case 115: goto st465
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr1616:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1692
st1692:
	p++
	if p == pe { goto _test_eof1692 }
	fallthrough
case 1692:
// line 90378 "zparse.go"
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 83: goto st465
		case 92: goto st97
		case 115: goto st465
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr1617:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1693
st1693:
	p++
	if p == pe { goto _test_eof1693 }
	fallthrough
case 1693:
// line 90409 "zparse.go"
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 78: goto st465
		case 92: goto st97
		case 110: goto st465
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr1619:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1694
st1694:
	p++
	if p == pe { goto _test_eof1694 }
	fallthrough
case 1694:
// line 90440 "zparse.go"
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 79: goto st1695
		case 83: goto st1298
		case 92: goto st97
		case 111: goto st1695
		case 115: goto st1298
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1695:
	p++
	if p == pe { goto _test_eof1695 }
	fallthrough
case 1695:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 78: goto st1696
		case 92: goto st97
		case 110: goto st1696
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
st1696:
	p++
	if p == pe { goto _test_eof1696 }
	fallthrough
case 1696:
	switch data[p] {
		case 9: goto tr388
		case 10: goto tr389
		case 32: goto tr388
		case 40: goto tr390
		case 41: goto tr391
		case 43: goto st97
		case 59: goto tr393
		case 61: goto st97
		case 69: goto st465
		case 92: goto st97
		case 101: goto st465
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st97 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st97 }
	} else {
		goto st97
	}
	goto st0
tr1595:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1697
tr5316:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1697
st1697:
	p++
	if p == pe { goto _test_eof1697 }
	fallthrough
case 1697:
// line 90535 "zparse.go"
	if data[p] == 10 { goto tr1597 }
	goto st1697
tr1589:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1698
st1698:
	p++
	if p == pe { goto _test_eof1698 }
	fallthrough
case 1698:
// line 90547 "zparse.go"
	if data[p] == 10 { goto tr5299 }
	goto st1698
tr1588:
// line 89 "zparse.rl"
	{ mark = p }
// line 92 "zparse.rl"
	{ /* ... */ }
	goto st1699
st1699:
	p++
	if p == pe { goto _test_eof1699 }
	fallthrough
case 1699:
// line 90561 "zparse.go"
	switch data[p] {
		case 9: goto tr5300
		case 10: goto tr5301
		case 32: goto tr5300
		case 40: goto tr5302
		case 41: goto tr5303
		case 59: goto tr5305
	}
	if 48 <= data[p] && data[p] <= 57 { goto st1699 }
	goto st0
tr5308:
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
	goto st1700
tr5309:
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
	goto st1700
tr5307:
// line 101 "zparse.rl"
	{ lines++ }
	goto st1700
tr5300:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1700
tr5301:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 101 "zparse.rl"
	{ lines++ }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1700
tr5302:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 98 "zparse.rl"
	{ if brace { println("Brace already open")} ; brace = true }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1700
tr5303:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 99 "zparse.rl"
	{ if !brace { println("Brace already closed")}; brace = false }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1700
st1700:
	p++
	if p == pe { goto _test_eof1700 }
	fallthrough
case 1700:
// line 90619 "zparse.go"
	switch data[p] {
		case 9: goto st1700
		case 10: goto tr5307
		case 32: goto st1700
		case 40: goto tr5308
		case 41: goto tr5309
		case 59: goto st1701
		case 65: goto tr38
		case 67: goto tr39
		case 68: goto tr40
		case 72: goto tr41
		case 73: goto tr42
		case 77: goto tr43
		case 78: goto tr44
		case 82: goto tr45
		case 83: goto tr46
		case 97: goto tr38
		case 99: goto tr39
		case 100: goto tr40
		case 104: goto tr41
		case 105: goto tr42
		case 109: goto tr43
		case 110: goto tr44
		case 114: goto tr45
		case 115: goto tr46
	}
	if 48 <= data[p] && data[p] <= 57 { goto tr374 }
	goto st0
tr5305:
// line 93 "zparse.rl"
	{ ttl, _ :=  strconv.Atoi(data[mark:p]); hdr.Ttl = uint32(ttl) }
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1701
st1701:
	p++
	if p == pe { goto _test_eof1701 }
	fallthrough
case 1701:
// line 90659 "zparse.go"
	if data[p] == 10 { goto tr5307 }
	goto st1701
tr5403:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1702
st1702:
	p++
	if p == pe { goto _test_eof1702 }
	fallthrough
case 1702:
// line 90671 "zparse.go"
	switch data[p] {
		case 9: goto tr5311
		case 10: goto tr5312
		case 32: goto tr5311
		case 40: goto tr5313
		case 41: goto tr5314
		case 59: goto tr5316
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1702
	}
	goto st0
tr1583:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1703
tr1578:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
// line 24 "types.rl"
	{
            x := rr.(*RR_SOA)
            x.Hdr = *hdr
            x.Ns = tok.T[0]
            x.Mbox = tok.T[1]
            x.Serial = uint32(tok.N[0])
            x.Refresh = uint32(tok.N[1])
            x.Retry = uint32(tok.N[2])
            x.Expire = uint32(tok.N[3])
            x.Minttl = uint32(tok.N[4])
        }
// line 97 "zparse.rl"
	{ z.Push(rr); tok.reset(); println("setting") }
	goto st1703
st1703:
	p++
	if p == pe { goto _test_eof1703 }
	fallthrough
case 1703:
// line 90721 "zparse.go"
	if data[p] == 10 { goto tr5318 }
	goto st1703
tr1566:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1704
st1704:
	p++
	if p == pe { goto _test_eof1704 }
	fallthrough
case 1704:
// line 90733 "zparse.go"
	if data[p] == 10 { goto tr1568 }
	goto st1704
tr1554:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1705
st1705:
	p++
	if p == pe { goto _test_eof1705 }
	fallthrough
case 1705:
// line 90745 "zparse.go"
	if data[p] == 10 { goto tr1556 }
	goto st1705
tr1542:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1706
st1706:
	p++
	if p == pe { goto _test_eof1706 }
	fallthrough
case 1706:
// line 90757 "zparse.go"
	if data[p] == 10 { goto tr1544 }
	goto st1706
tr1530:
// line 94 "zparse.rl"
	{ tok.pushInt(data[mark:p]) }
	goto st1707
st1707:
	p++
	if p == pe { goto _test_eof1707 }
	fallthrough
case 1707:
// line 90769 "zparse.go"
	if data[p] == 10 { goto tr1532 }
	goto st1707
tr1518:
// line 95 "zparse.rl"
	{ tok.pushString(data[mark:p]) }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1708
st1708:
	p++
	if p == pe { goto _test_eof1708 }
	fallthrough
case 1708:
// line 90792 "zparse.go"
	if data[p] == 10 { goto tr1520 }
	goto st1708
tr1111:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1709
st1709:
	p++
	if p == pe { goto _test_eof1709 }
	fallthrough
case 1709:
// line 90815 "zparse.go"
	if data[p] == 10 { goto tr1113 }
	goto st1709
tr5395:
// line 89 "zparse.rl"
	{ mark = p }
	goto st1710
st1710:
	p++
	if p == pe { goto _test_eof1710 }
	fallthrough
case 1710:
// line 90827 "zparse.go"
	switch data[p] {
		case 9: goto tr5319
		case 10: goto tr5320
		case 32: goto tr5319
		case 40: goto tr5321
		case 41: goto tr5322
		case 59: goto tr5324
		case 92: goto st2
		case 95: goto st2
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st1710
	}
	goto st0
tr844:
// line 90 "zparse.rl"
	{ hdr.Name = data[mark:p] }
// line 102 "zparse.rl"
	{ 
                    i := Str_rr[data[mark:p]]
                    mk, known := rr_mk[int(i)]
                    if ! known {
                        println("Unknown type seen: " + data[mark:p])
                        // panic?
                    }
                    rr = mk()
                    hdr.Rrtype = i
                }
	goto st1711
st1711:
	p++
	if p == pe { goto _test_eof1711 }
	fallthrough
case 1711:
// line 90870 "zparse.go"
	if data[p] == 10 { goto tr846 }
	goto st1711
st1712:
	p++
	if p == pe { goto _test_eof1712 }
	fallthrough
case 1712:
	switch data[p] {
		case 9: goto tr5325
		case 10: goto tr5326
		case 32: goto tr5325
		case 40: goto tr5327
		case 41: goto tr5328
		case 43: goto st31
		case 47: goto st31
		case 58: goto st31
		case 59: goto tr5329
		case 61: goto st31
		case 92: goto st193
		case 95: goto st2
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st193 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st193 }
	} else {
		goto st193
	}
	goto st0
st1713:
	p++
	if p == pe { goto _test_eof1713 }
	fallthrough
case 1713:
	switch data[p] {
		case 9: goto tr614
		case 10: goto tr615
		case 32: goto tr614
		case 40: goto tr616
		case 41: goto tr617
		case 43: goto st9
		case 47: goto st9
		case 58: goto st9
		case 59: goto tr619
		case 61: goto st9
		case 89: goto st638
		case 92: goto st170
		case 95: goto st2
		case 121: goto st638
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 57 { goto st170 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st170 }
	} else {
		goto st170
	}
	goto st0
st1714:
	p++
	if p == pe { goto _test_eof1714 }
	fallthrough
case 1714:
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 65: goto st1715
		case 92: goto st31
		case 97: goto st1715
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st1715:
	p++
	if p == pe { goto _test_eof1715 }
	fallthrough
case 1715:
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 65: goto st1716
		case 92: goto st31
		case 97: goto st1716
	}
	if data[p] < 66 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 98 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st1716:
	p++
	if p == pe { goto _test_eof1716 }
	fallthrough
case 1716:
	switch data[p] {
		case 9: goto tr5332
		case 10: goto tr5333
		case 32: goto tr5332
		case 40: goto tr5334
		case 41: goto tr5335
		case 43: goto st31
		case 59: goto tr5336
		case 61: goto st31
		case 92: goto st31
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st1717:
	p++
	if p == pe { goto _test_eof1717 }
	fallthrough
case 1717:
	switch data[p] {
		case 9: goto tr123
		case 10: goto tr124
		case 32: goto tr123
		case 40: goto tr125
		case 41: goto tr126
		case 43: goto st31
		case 59: goto tr128
		case 61: goto st31
		case 89: goto st803
		case 92: goto st31
		case 121: goto st803
	}
	if data[p] < 65 {
		if 45 <= data[p] && data[p] <= 58 { goto st31 }
	} else if data[p] > 90 {
		if 97 <= data[p] && data[p] <= 122 { goto st31 }
	} else {
		goto st31
	}
	goto st0
st1718:
	p++
	if p == pe { goto _test_eof1718 }
	fallthrough
case 1718:
	switch data[p] {
		case 9: goto tr16
		case 10: goto tr17
		case 32: goto tr16
		case 40: goto tr18
		case 41: goto tr19
		case 59: goto tr21
		case 89: goto st158
		case 92: goto st2
		case 95: goto st2
		case 121: goto st158
	}
	if data[p] < 48 {
		if 45 <= data[p] && data[p] <= 46 { goto st2 }
	} else if data[p] > 57 {
		if data[p] > 90 {
			if 97 <= data[p] && data[p] <= 122 { goto st2 }
		} else if data[p] >= 65 {
			goto st2
		}
	} else {
		goto st2
	}
	goto st0
	}
	_test_eof1: cs = 1; goto _test_eof; 
	_test_eof1720: cs = 1720; goto _test_eof; 
	_test_eof2: cs = 2; goto _test_eof; 
	_test_eof3: cs = 3; goto _test_eof; 
	_test_eof4: cs = 4; goto _test_eof; 
	_test_eof5: cs = 5; goto _test_eof; 
	_test_eof6: cs = 6; goto _test_eof; 
	_test_eof7: cs = 7; goto _test_eof; 
	_test_eof8: cs = 8; goto _test_eof; 
	_test_eof9: cs = 9; goto _test_eof; 
	_test_eof10: cs = 10; goto _test_eof; 
	_test_eof1721: cs = 1721; goto _test_eof; 
	_test_eof11: cs = 11; goto _test_eof; 
	_test_eof12: cs = 12; goto _test_eof; 
	_test_eof13: cs = 13; goto _test_eof; 
	_test_eof14: cs = 14; goto _test_eof; 
	_test_eof15: cs = 15; goto _test_eof; 
	_test_eof16: cs = 16; goto _test_eof; 
	_test_eof17: cs = 17; goto _test_eof; 
	_test_eof18: cs = 18; goto _test_eof; 
	_test_eof19: cs = 19; goto _test_eof; 
	_test_eof20: cs = 20; goto _test_eof; 
	_test_eof21: cs = 21; goto _test_eof; 
	_test_eof22: cs = 22; goto _test_eof; 
	_test_eof23: cs = 23; goto _test_eof; 
	_test_eof24: cs = 24; goto _test_eof; 
	_test_eof25: cs = 25; goto _test_eof; 
	_test_eof26: cs = 26; goto _test_eof; 
	_test_eof27: cs = 27; goto _test_eof; 
	_test_eof28: cs = 28; goto _test_eof; 
	_test_eof29: cs = 29; goto _test_eof; 
	_test_eof30: cs = 30; goto _test_eof; 
	_test_eof31: cs = 31; goto _test_eof; 
	_test_eof32: cs = 32; goto _test_eof; 
	_test_eof33: cs = 33; goto _test_eof; 
	_test_eof34: cs = 34; goto _test_eof; 
	_test_eof35: cs = 35; goto _test_eof; 
	_test_eof36: cs = 36; goto _test_eof; 
	_test_eof37: cs = 37; goto _test_eof; 
	_test_eof38: cs = 38; goto _test_eof; 
	_test_eof39: cs = 39; goto _test_eof; 
	_test_eof40: cs = 40; goto _test_eof; 
	_test_eof41: cs = 41; goto _test_eof; 
	_test_eof42: cs = 42; goto _test_eof; 
	_test_eof43: cs = 43; goto _test_eof; 
	_test_eof44: cs = 44; goto _test_eof; 
	_test_eof45: cs = 45; goto _test_eof; 
	_test_eof46: cs = 46; goto _test_eof; 
	_test_eof47: cs = 47; goto _test_eof; 
	_test_eof48: cs = 48; goto _test_eof; 
	_test_eof49: cs = 49; goto _test_eof; 
	_test_eof50: cs = 50; goto _test_eof; 
	_test_eof51: cs = 51; goto _test_eof; 
	_test_eof52: cs = 52; goto _test_eof; 
	_test_eof53: cs = 53; goto _test_eof; 
	_test_eof54: cs = 54; goto _test_eof; 
	_test_eof55: cs = 55; goto _test_eof; 
	_test_eof56: cs = 56; goto _test_eof; 
	_test_eof57: cs = 57; goto _test_eof; 
	_test_eof58: cs = 58; goto _test_eof; 
	_test_eof59: cs = 59; goto _test_eof; 
	_test_eof60: cs = 60; goto _test_eof; 
	_test_eof61: cs = 61; goto _test_eof; 
	_test_eof62: cs = 62; goto _test_eof; 
	_test_eof63: cs = 63; goto _test_eof; 
	_test_eof64: cs = 64; goto _test_eof; 
	_test_eof65: cs = 65; goto _test_eof; 
	_test_eof66: cs = 66; goto _test_eof; 
	_test_eof67: cs = 67; goto _test_eof; 
	_test_eof68: cs = 68; goto _test_eof; 
	_test_eof69: cs = 69; goto _test_eof; 
	_test_eof70: cs = 70; goto _test_eof; 
	_test_eof71: cs = 71; goto _test_eof; 
	_test_eof72: cs = 72; goto _test_eof; 
	_test_eof73: cs = 73; goto _test_eof; 
	_test_eof74: cs = 74; goto _test_eof; 
	_test_eof75: cs = 75; goto _test_eof; 
	_test_eof76: cs = 76; goto _test_eof; 
	_test_eof77: cs = 77; goto _test_eof; 
	_test_eof78: cs = 78; goto _test_eof; 
	_test_eof79: cs = 79; goto _test_eof; 
	_test_eof80: cs = 80; goto _test_eof; 
	_test_eof81: cs = 81; goto _test_eof; 
	_test_eof82: cs = 82; goto _test_eof; 
	_test_eof83: cs = 83; goto _test_eof; 
	_test_eof84: cs = 84; goto _test_eof; 
	_test_eof85: cs = 85; goto _test_eof; 
	_test_eof86: cs = 86; goto _test_eof; 
	_test_eof87: cs = 87; goto _test_eof; 
	_test_eof88: cs = 88; goto _test_eof; 
	_test_eof89: cs = 89; goto _test_eof; 
	_test_eof90: cs = 90; goto _test_eof; 
	_test_eof91: cs = 91; goto _test_eof; 
	_test_eof92: cs = 92; goto _test_eof; 
	_test_eof93: cs = 93; goto _test_eof; 
	_test_eof94: cs = 94; goto _test_eof; 
	_test_eof95: cs = 95; goto _test_eof; 
	_test_eof96: cs = 96; goto _test_eof; 
	_test_eof97: cs = 97; goto _test_eof; 
	_test_eof98: cs = 98; goto _test_eof; 
	_test_eof99: cs = 99; goto _test_eof; 
	_test_eof100: cs = 100; goto _test_eof; 
	_test_eof101: cs = 101; goto _test_eof; 
	_test_eof102: cs = 102; goto _test_eof; 
	_test_eof103: cs = 103; goto _test_eof; 
	_test_eof104: cs = 104; goto _test_eof; 
	_test_eof105: cs = 105; goto _test_eof; 
	_test_eof106: cs = 106; goto _test_eof; 
	_test_eof107: cs = 107; goto _test_eof; 
	_test_eof108: cs = 108; goto _test_eof; 
	_test_eof109: cs = 109; goto _test_eof; 
	_test_eof110: cs = 110; goto _test_eof; 
	_test_eof111: cs = 111; goto _test_eof; 
	_test_eof112: cs = 112; goto _test_eof; 
	_test_eof113: cs = 113; goto _test_eof; 
	_test_eof114: cs = 114; goto _test_eof; 
	_test_eof115: cs = 115; goto _test_eof; 
	_test_eof116: cs = 116; goto _test_eof; 
	_test_eof117: cs = 117; goto _test_eof; 
	_test_eof118: cs = 118; goto _test_eof; 
	_test_eof119: cs = 119; goto _test_eof; 
	_test_eof120: cs = 120; goto _test_eof; 
	_test_eof121: cs = 121; goto _test_eof; 
	_test_eof122: cs = 122; goto _test_eof; 
	_test_eof123: cs = 123; goto _test_eof; 
	_test_eof124: cs = 124; goto _test_eof; 
	_test_eof125: cs = 125; goto _test_eof; 
	_test_eof126: cs = 126; goto _test_eof; 
	_test_eof127: cs = 127; goto _test_eof; 
	_test_eof128: cs = 128; goto _test_eof; 
	_test_eof129: cs = 129; goto _test_eof; 
	_test_eof130: cs = 130; goto _test_eof; 
	_test_eof131: cs = 131; goto _test_eof; 
	_test_eof132: cs = 132; goto _test_eof; 
	_test_eof133: cs = 133; goto _test_eof; 
	_test_eof134: cs = 134; goto _test_eof; 
	_test_eof135: cs = 135; goto _test_eof; 
	_test_eof136: cs = 136; goto _test_eof; 
	_test_eof137: cs = 137; goto _test_eof; 
	_test_eof138: cs = 138; goto _test_eof; 
	_test_eof139: cs = 139; goto _test_eof; 
	_test_eof140: cs = 140; goto _test_eof; 
	_test_eof141: cs = 141; goto _test_eof; 
	_test_eof142: cs = 142; goto _test_eof; 
	_test_eof143: cs = 143; goto _test_eof; 
	_test_eof144: cs = 144; goto _test_eof; 
	_test_eof145: cs = 145; goto _test_eof; 
	_test_eof146: cs = 146; goto _test_eof; 
	_test_eof147: cs = 147; goto _test_eof; 
	_test_eof148: cs = 148; goto _test_eof; 
	_test_eof149: cs = 149; goto _test_eof; 
	_test_eof150: cs = 150; goto _test_eof; 
	_test_eof151: cs = 151; goto _test_eof; 
	_test_eof152: cs = 152; goto _test_eof; 
	_test_eof153: cs = 153; goto _test_eof; 
	_test_eof154: cs = 154; goto _test_eof; 
	_test_eof155: cs = 155; goto _test_eof; 
	_test_eof156: cs = 156; goto _test_eof; 
	_test_eof1722: cs = 1722; goto _test_eof; 
	_test_eof157: cs = 157; goto _test_eof; 
	_test_eof158: cs = 158; goto _test_eof; 
	_test_eof159: cs = 159; goto _test_eof; 
	_test_eof160: cs = 160; goto _test_eof; 
	_test_eof161: cs = 161; goto _test_eof; 
	_test_eof162: cs = 162; goto _test_eof; 
	_test_eof163: cs = 163; goto _test_eof; 
	_test_eof164: cs = 164; goto _test_eof; 
	_test_eof165: cs = 165; goto _test_eof; 
	_test_eof166: cs = 166; goto _test_eof; 
	_test_eof167: cs = 167; goto _test_eof; 
	_test_eof168: cs = 168; goto _test_eof; 
	_test_eof1723: cs = 1723; goto _test_eof; 
	_test_eof169: cs = 169; goto _test_eof; 
	_test_eof1724: cs = 1724; goto _test_eof; 
	_test_eof170: cs = 170; goto _test_eof; 
	_test_eof171: cs = 171; goto _test_eof; 
	_test_eof172: cs = 172; goto _test_eof; 
	_test_eof173: cs = 173; goto _test_eof; 
	_test_eof174: cs = 174; goto _test_eof; 
	_test_eof175: cs = 175; goto _test_eof; 
	_test_eof176: cs = 176; goto _test_eof; 
	_test_eof177: cs = 177; goto _test_eof; 
	_test_eof1725: cs = 1725; goto _test_eof; 
	_test_eof178: cs = 178; goto _test_eof; 
	_test_eof179: cs = 179; goto _test_eof; 
	_test_eof180: cs = 180; goto _test_eof; 
	_test_eof181: cs = 181; goto _test_eof; 
	_test_eof182: cs = 182; goto _test_eof; 
	_test_eof183: cs = 183; goto _test_eof; 
	_test_eof184: cs = 184; goto _test_eof; 
	_test_eof185: cs = 185; goto _test_eof; 
	_test_eof186: cs = 186; goto _test_eof; 
	_test_eof187: cs = 187; goto _test_eof; 
	_test_eof188: cs = 188; goto _test_eof; 
	_test_eof189: cs = 189; goto _test_eof; 
	_test_eof190: cs = 190; goto _test_eof; 
	_test_eof191: cs = 191; goto _test_eof; 
	_test_eof192: cs = 192; goto _test_eof; 
	_test_eof1726: cs = 1726; goto _test_eof; 
	_test_eof193: cs = 193; goto _test_eof; 
	_test_eof194: cs = 194; goto _test_eof; 
	_test_eof195: cs = 195; goto _test_eof; 
	_test_eof196: cs = 196; goto _test_eof; 
	_test_eof197: cs = 197; goto _test_eof; 
	_test_eof198: cs = 198; goto _test_eof; 
	_test_eof199: cs = 199; goto _test_eof; 
	_test_eof200: cs = 200; goto _test_eof; 
	_test_eof201: cs = 201; goto _test_eof; 
	_test_eof202: cs = 202; goto _test_eof; 
	_test_eof203: cs = 203; goto _test_eof; 
	_test_eof204: cs = 204; goto _test_eof; 
	_test_eof205: cs = 205; goto _test_eof; 
	_test_eof206: cs = 206; goto _test_eof; 
	_test_eof207: cs = 207; goto _test_eof; 
	_test_eof208: cs = 208; goto _test_eof; 
	_test_eof209: cs = 209; goto _test_eof; 
	_test_eof210: cs = 210; goto _test_eof; 
	_test_eof211: cs = 211; goto _test_eof; 
	_test_eof212: cs = 212; goto _test_eof; 
	_test_eof213: cs = 213; goto _test_eof; 
	_test_eof1727: cs = 1727; goto _test_eof; 
	_test_eof214: cs = 214; goto _test_eof; 
	_test_eof215: cs = 215; goto _test_eof; 
	_test_eof216: cs = 216; goto _test_eof; 
	_test_eof217: cs = 217; goto _test_eof; 
	_test_eof218: cs = 218; goto _test_eof; 
	_test_eof219: cs = 219; goto _test_eof; 
	_test_eof220: cs = 220; goto _test_eof; 
	_test_eof221: cs = 221; goto _test_eof; 
	_test_eof222: cs = 222; goto _test_eof; 
	_test_eof223: cs = 223; goto _test_eof; 
	_test_eof224: cs = 224; goto _test_eof; 
	_test_eof225: cs = 225; goto _test_eof; 
	_test_eof226: cs = 226; goto _test_eof; 
	_test_eof227: cs = 227; goto _test_eof; 
	_test_eof228: cs = 228; goto _test_eof; 
	_test_eof229: cs = 229; goto _test_eof; 
	_test_eof230: cs = 230; goto _test_eof; 
	_test_eof231: cs = 231; goto _test_eof; 
	_test_eof232: cs = 232; goto _test_eof; 
	_test_eof233: cs = 233; goto _test_eof; 
	_test_eof234: cs = 234; goto _test_eof; 
	_test_eof235: cs = 235; goto _test_eof; 
	_test_eof236: cs = 236; goto _test_eof; 
	_test_eof237: cs = 237; goto _test_eof; 
	_test_eof238: cs = 238; goto _test_eof; 
	_test_eof239: cs = 239; goto _test_eof; 
	_test_eof240: cs = 240; goto _test_eof; 
	_test_eof241: cs = 241; goto _test_eof; 
	_test_eof242: cs = 242; goto _test_eof; 
	_test_eof243: cs = 243; goto _test_eof; 
	_test_eof244: cs = 244; goto _test_eof; 
	_test_eof245: cs = 245; goto _test_eof; 
	_test_eof246: cs = 246; goto _test_eof; 
	_test_eof247: cs = 247; goto _test_eof; 
	_test_eof248: cs = 248; goto _test_eof; 
	_test_eof249: cs = 249; goto _test_eof; 
	_test_eof250: cs = 250; goto _test_eof; 
	_test_eof251: cs = 251; goto _test_eof; 
	_test_eof1728: cs = 1728; goto _test_eof; 
	_test_eof252: cs = 252; goto _test_eof; 
	_test_eof253: cs = 253; goto _test_eof; 
	_test_eof254: cs = 254; goto _test_eof; 
	_test_eof255: cs = 255; goto _test_eof; 
	_test_eof1729: cs = 1729; goto _test_eof; 
	_test_eof256: cs = 256; goto _test_eof; 
	_test_eof257: cs = 257; goto _test_eof; 
	_test_eof258: cs = 258; goto _test_eof; 
	_test_eof259: cs = 259; goto _test_eof; 
	_test_eof260: cs = 260; goto _test_eof; 
	_test_eof261: cs = 261; goto _test_eof; 
	_test_eof262: cs = 262; goto _test_eof; 
	_test_eof263: cs = 263; goto _test_eof; 
	_test_eof264: cs = 264; goto _test_eof; 
	_test_eof265: cs = 265; goto _test_eof; 
	_test_eof266: cs = 266; goto _test_eof; 
	_test_eof267: cs = 267; goto _test_eof; 
	_test_eof268: cs = 268; goto _test_eof; 
	_test_eof269: cs = 269; goto _test_eof; 
	_test_eof270: cs = 270; goto _test_eof; 
	_test_eof1730: cs = 1730; goto _test_eof; 
	_test_eof271: cs = 271; goto _test_eof; 
	_test_eof272: cs = 272; goto _test_eof; 
	_test_eof273: cs = 273; goto _test_eof; 
	_test_eof274: cs = 274; goto _test_eof; 
	_test_eof275: cs = 275; goto _test_eof; 
	_test_eof276: cs = 276; goto _test_eof; 
	_test_eof277: cs = 277; goto _test_eof; 
	_test_eof278: cs = 278; goto _test_eof; 
	_test_eof279: cs = 279; goto _test_eof; 
	_test_eof280: cs = 280; goto _test_eof; 
	_test_eof281: cs = 281; goto _test_eof; 
	_test_eof282: cs = 282; goto _test_eof; 
	_test_eof283: cs = 283; goto _test_eof; 
	_test_eof284: cs = 284; goto _test_eof; 
	_test_eof285: cs = 285; goto _test_eof; 
	_test_eof286: cs = 286; goto _test_eof; 
	_test_eof287: cs = 287; goto _test_eof; 
	_test_eof288: cs = 288; goto _test_eof; 
	_test_eof289: cs = 289; goto _test_eof; 
	_test_eof1731: cs = 1731; goto _test_eof; 
	_test_eof290: cs = 290; goto _test_eof; 
	_test_eof291: cs = 291; goto _test_eof; 
	_test_eof292: cs = 292; goto _test_eof; 
	_test_eof293: cs = 293; goto _test_eof; 
	_test_eof294: cs = 294; goto _test_eof; 
	_test_eof295: cs = 295; goto _test_eof; 
	_test_eof296: cs = 296; goto _test_eof; 
	_test_eof297: cs = 297; goto _test_eof; 
	_test_eof1732: cs = 1732; goto _test_eof; 
	_test_eof298: cs = 298; goto _test_eof; 
	_test_eof299: cs = 299; goto _test_eof; 
	_test_eof300: cs = 300; goto _test_eof; 
	_test_eof301: cs = 301; goto _test_eof; 
	_test_eof1733: cs = 1733; goto _test_eof; 
	_test_eof302: cs = 302; goto _test_eof; 
	_test_eof1734: cs = 1734; goto _test_eof; 
	_test_eof303: cs = 303; goto _test_eof; 
	_test_eof304: cs = 304; goto _test_eof; 
	_test_eof305: cs = 305; goto _test_eof; 
	_test_eof306: cs = 306; goto _test_eof; 
	_test_eof307: cs = 307; goto _test_eof; 
	_test_eof308: cs = 308; goto _test_eof; 
	_test_eof309: cs = 309; goto _test_eof; 
	_test_eof310: cs = 310; goto _test_eof; 
	_test_eof311: cs = 311; goto _test_eof; 
	_test_eof312: cs = 312; goto _test_eof; 
	_test_eof313: cs = 313; goto _test_eof; 
	_test_eof314: cs = 314; goto _test_eof; 
	_test_eof315: cs = 315; goto _test_eof; 
	_test_eof316: cs = 316; goto _test_eof; 
	_test_eof317: cs = 317; goto _test_eof; 
	_test_eof318: cs = 318; goto _test_eof; 
	_test_eof319: cs = 319; goto _test_eof; 
	_test_eof320: cs = 320; goto _test_eof; 
	_test_eof321: cs = 321; goto _test_eof; 
	_test_eof322: cs = 322; goto _test_eof; 
	_test_eof323: cs = 323; goto _test_eof; 
	_test_eof324: cs = 324; goto _test_eof; 
	_test_eof325: cs = 325; goto _test_eof; 
	_test_eof326: cs = 326; goto _test_eof; 
	_test_eof327: cs = 327; goto _test_eof; 
	_test_eof328: cs = 328; goto _test_eof; 
	_test_eof329: cs = 329; goto _test_eof; 
	_test_eof330: cs = 330; goto _test_eof; 
	_test_eof331: cs = 331; goto _test_eof; 
	_test_eof332: cs = 332; goto _test_eof; 
	_test_eof333: cs = 333; goto _test_eof; 
	_test_eof1735: cs = 1735; goto _test_eof; 
	_test_eof334: cs = 334; goto _test_eof; 
	_test_eof1736: cs = 1736; goto _test_eof; 
	_test_eof335: cs = 335; goto _test_eof; 
	_test_eof336: cs = 336; goto _test_eof; 
	_test_eof337: cs = 337; goto _test_eof; 
	_test_eof338: cs = 338; goto _test_eof; 
	_test_eof339: cs = 339; goto _test_eof; 
	_test_eof340: cs = 340; goto _test_eof; 
	_test_eof341: cs = 341; goto _test_eof; 
	_test_eof342: cs = 342; goto _test_eof; 
	_test_eof343: cs = 343; goto _test_eof; 
	_test_eof344: cs = 344; goto _test_eof; 
	_test_eof345: cs = 345; goto _test_eof; 
	_test_eof346: cs = 346; goto _test_eof; 
	_test_eof347: cs = 347; goto _test_eof; 
	_test_eof348: cs = 348; goto _test_eof; 
	_test_eof349: cs = 349; goto _test_eof; 
	_test_eof350: cs = 350; goto _test_eof; 
	_test_eof351: cs = 351; goto _test_eof; 
	_test_eof352: cs = 352; goto _test_eof; 
	_test_eof353: cs = 353; goto _test_eof; 
	_test_eof354: cs = 354; goto _test_eof; 
	_test_eof355: cs = 355; goto _test_eof; 
	_test_eof356: cs = 356; goto _test_eof; 
	_test_eof357: cs = 357; goto _test_eof; 
	_test_eof358: cs = 358; goto _test_eof; 
	_test_eof359: cs = 359; goto _test_eof; 
	_test_eof360: cs = 360; goto _test_eof; 
	_test_eof361: cs = 361; goto _test_eof; 
	_test_eof362: cs = 362; goto _test_eof; 
	_test_eof363: cs = 363; goto _test_eof; 
	_test_eof364: cs = 364; goto _test_eof; 
	_test_eof365: cs = 365; goto _test_eof; 
	_test_eof366: cs = 366; goto _test_eof; 
	_test_eof367: cs = 367; goto _test_eof; 
	_test_eof368: cs = 368; goto _test_eof; 
	_test_eof369: cs = 369; goto _test_eof; 
	_test_eof370: cs = 370; goto _test_eof; 
	_test_eof371: cs = 371; goto _test_eof; 
	_test_eof372: cs = 372; goto _test_eof; 
	_test_eof373: cs = 373; goto _test_eof; 
	_test_eof374: cs = 374; goto _test_eof; 
	_test_eof375: cs = 375; goto _test_eof; 
	_test_eof376: cs = 376; goto _test_eof; 
	_test_eof377: cs = 377; goto _test_eof; 
	_test_eof378: cs = 378; goto _test_eof; 
	_test_eof379: cs = 379; goto _test_eof; 
	_test_eof380: cs = 380; goto _test_eof; 
	_test_eof1737: cs = 1737; goto _test_eof; 
	_test_eof381: cs = 381; goto _test_eof; 
	_test_eof1738: cs = 1738; goto _test_eof; 
	_test_eof382: cs = 382; goto _test_eof; 
	_test_eof383: cs = 383; goto _test_eof; 
	_test_eof384: cs = 384; goto _test_eof; 
	_test_eof385: cs = 385; goto _test_eof; 
	_test_eof386: cs = 386; goto _test_eof; 
	_test_eof387: cs = 387; goto _test_eof; 
	_test_eof388: cs = 388; goto _test_eof; 
	_test_eof389: cs = 389; goto _test_eof; 
	_test_eof390: cs = 390; goto _test_eof; 
	_test_eof391: cs = 391; goto _test_eof; 
	_test_eof392: cs = 392; goto _test_eof; 
	_test_eof393: cs = 393; goto _test_eof; 
	_test_eof394: cs = 394; goto _test_eof; 
	_test_eof395: cs = 395; goto _test_eof; 
	_test_eof396: cs = 396; goto _test_eof; 
	_test_eof397: cs = 397; goto _test_eof; 
	_test_eof398: cs = 398; goto _test_eof; 
	_test_eof399: cs = 399; goto _test_eof; 
	_test_eof400: cs = 400; goto _test_eof; 
	_test_eof401: cs = 401; goto _test_eof; 
	_test_eof402: cs = 402; goto _test_eof; 
	_test_eof403: cs = 403; goto _test_eof; 
	_test_eof404: cs = 404; goto _test_eof; 
	_test_eof405: cs = 405; goto _test_eof; 
	_test_eof406: cs = 406; goto _test_eof; 
	_test_eof407: cs = 407; goto _test_eof; 
	_test_eof408: cs = 408; goto _test_eof; 
	_test_eof409: cs = 409; goto _test_eof; 
	_test_eof410: cs = 410; goto _test_eof; 
	_test_eof411: cs = 411; goto _test_eof; 
	_test_eof412: cs = 412; goto _test_eof; 
	_test_eof1739: cs = 1739; goto _test_eof; 
	_test_eof413: cs = 413; goto _test_eof; 
	_test_eof1740: cs = 1740; goto _test_eof; 
	_test_eof414: cs = 414; goto _test_eof; 
	_test_eof415: cs = 415; goto _test_eof; 
	_test_eof416: cs = 416; goto _test_eof; 
	_test_eof417: cs = 417; goto _test_eof; 
	_test_eof418: cs = 418; goto _test_eof; 
	_test_eof419: cs = 419; goto _test_eof; 
	_test_eof420: cs = 420; goto _test_eof; 
	_test_eof421: cs = 421; goto _test_eof; 
	_test_eof422: cs = 422; goto _test_eof; 
	_test_eof423: cs = 423; goto _test_eof; 
	_test_eof424: cs = 424; goto _test_eof; 
	_test_eof425: cs = 425; goto _test_eof; 
	_test_eof426: cs = 426; goto _test_eof; 
	_test_eof427: cs = 427; goto _test_eof; 
	_test_eof428: cs = 428; goto _test_eof; 
	_test_eof429: cs = 429; goto _test_eof; 
	_test_eof430: cs = 430; goto _test_eof; 
	_test_eof431: cs = 431; goto _test_eof; 
	_test_eof432: cs = 432; goto _test_eof; 
	_test_eof433: cs = 433; goto _test_eof; 
	_test_eof434: cs = 434; goto _test_eof; 
	_test_eof435: cs = 435; goto _test_eof; 
	_test_eof436: cs = 436; goto _test_eof; 
	_test_eof437: cs = 437; goto _test_eof; 
	_test_eof438: cs = 438; goto _test_eof; 
	_test_eof439: cs = 439; goto _test_eof; 
	_test_eof440: cs = 440; goto _test_eof; 
	_test_eof441: cs = 441; goto _test_eof; 
	_test_eof442: cs = 442; goto _test_eof; 
	_test_eof443: cs = 443; goto _test_eof; 
	_test_eof444: cs = 444; goto _test_eof; 
	_test_eof445: cs = 445; goto _test_eof; 
	_test_eof446: cs = 446; goto _test_eof; 
	_test_eof447: cs = 447; goto _test_eof; 
	_test_eof1741: cs = 1741; goto _test_eof; 
	_test_eof448: cs = 448; goto _test_eof; 
	_test_eof1742: cs = 1742; goto _test_eof; 
	_test_eof449: cs = 449; goto _test_eof; 
	_test_eof450: cs = 450; goto _test_eof; 
	_test_eof451: cs = 451; goto _test_eof; 
	_test_eof452: cs = 452; goto _test_eof; 
	_test_eof453: cs = 453; goto _test_eof; 
	_test_eof454: cs = 454; goto _test_eof; 
	_test_eof455: cs = 455; goto _test_eof; 
	_test_eof456: cs = 456; goto _test_eof; 
	_test_eof457: cs = 457; goto _test_eof; 
	_test_eof458: cs = 458; goto _test_eof; 
	_test_eof459: cs = 459; goto _test_eof; 
	_test_eof460: cs = 460; goto _test_eof; 
	_test_eof461: cs = 461; goto _test_eof; 
	_test_eof462: cs = 462; goto _test_eof; 
	_test_eof463: cs = 463; goto _test_eof; 
	_test_eof464: cs = 464; goto _test_eof; 
	_test_eof465: cs = 465; goto _test_eof; 
	_test_eof466: cs = 466; goto _test_eof; 
	_test_eof467: cs = 467; goto _test_eof; 
	_test_eof468: cs = 468; goto _test_eof; 
	_test_eof469: cs = 469; goto _test_eof; 
	_test_eof470: cs = 470; goto _test_eof; 
	_test_eof471: cs = 471; goto _test_eof; 
	_test_eof472: cs = 472; goto _test_eof; 
	_test_eof473: cs = 473; goto _test_eof; 
	_test_eof474: cs = 474; goto _test_eof; 
	_test_eof475: cs = 475; goto _test_eof; 
	_test_eof476: cs = 476; goto _test_eof; 
	_test_eof477: cs = 477; goto _test_eof; 
	_test_eof478: cs = 478; goto _test_eof; 
	_test_eof479: cs = 479; goto _test_eof; 
	_test_eof480: cs = 480; goto _test_eof; 
	_test_eof481: cs = 481; goto _test_eof; 
	_test_eof482: cs = 482; goto _test_eof; 
	_test_eof483: cs = 483; goto _test_eof; 
	_test_eof484: cs = 484; goto _test_eof; 
	_test_eof485: cs = 485; goto _test_eof; 
	_test_eof486: cs = 486; goto _test_eof; 
	_test_eof487: cs = 487; goto _test_eof; 
	_test_eof1743: cs = 1743; goto _test_eof; 
	_test_eof488: cs = 488; goto _test_eof; 
	_test_eof1744: cs = 1744; goto _test_eof; 
	_test_eof489: cs = 489; goto _test_eof; 
	_test_eof490: cs = 490; goto _test_eof; 
	_test_eof491: cs = 491; goto _test_eof; 
	_test_eof492: cs = 492; goto _test_eof; 
	_test_eof493: cs = 493; goto _test_eof; 
	_test_eof494: cs = 494; goto _test_eof; 
	_test_eof495: cs = 495; goto _test_eof; 
	_test_eof496: cs = 496; goto _test_eof; 
	_test_eof497: cs = 497; goto _test_eof; 
	_test_eof498: cs = 498; goto _test_eof; 
	_test_eof499: cs = 499; goto _test_eof; 
	_test_eof500: cs = 500; goto _test_eof; 
	_test_eof501: cs = 501; goto _test_eof; 
	_test_eof502: cs = 502; goto _test_eof; 
	_test_eof503: cs = 503; goto _test_eof; 
	_test_eof504: cs = 504; goto _test_eof; 
	_test_eof505: cs = 505; goto _test_eof; 
	_test_eof506: cs = 506; goto _test_eof; 
	_test_eof507: cs = 507; goto _test_eof; 
	_test_eof508: cs = 508; goto _test_eof; 
	_test_eof509: cs = 509; goto _test_eof; 
	_test_eof510: cs = 510; goto _test_eof; 
	_test_eof511: cs = 511; goto _test_eof; 
	_test_eof512: cs = 512; goto _test_eof; 
	_test_eof513: cs = 513; goto _test_eof; 
	_test_eof514: cs = 514; goto _test_eof; 
	_test_eof515: cs = 515; goto _test_eof; 
	_test_eof516: cs = 516; goto _test_eof; 
	_test_eof517: cs = 517; goto _test_eof; 
	_test_eof1745: cs = 1745; goto _test_eof; 
	_test_eof518: cs = 518; goto _test_eof; 
	_test_eof1746: cs = 1746; goto _test_eof; 
	_test_eof519: cs = 519; goto _test_eof; 
	_test_eof520: cs = 520; goto _test_eof; 
	_test_eof521: cs = 521; goto _test_eof; 
	_test_eof522: cs = 522; goto _test_eof; 
	_test_eof523: cs = 523; goto _test_eof; 
	_test_eof524: cs = 524; goto _test_eof; 
	_test_eof525: cs = 525; goto _test_eof; 
	_test_eof526: cs = 526; goto _test_eof; 
	_test_eof527: cs = 527; goto _test_eof; 
	_test_eof528: cs = 528; goto _test_eof; 
	_test_eof529: cs = 529; goto _test_eof; 
	_test_eof530: cs = 530; goto _test_eof; 
	_test_eof531: cs = 531; goto _test_eof; 
	_test_eof532: cs = 532; goto _test_eof; 
	_test_eof533: cs = 533; goto _test_eof; 
	_test_eof534: cs = 534; goto _test_eof; 
	_test_eof535: cs = 535; goto _test_eof; 
	_test_eof536: cs = 536; goto _test_eof; 
	_test_eof537: cs = 537; goto _test_eof; 
	_test_eof538: cs = 538; goto _test_eof; 
	_test_eof539: cs = 539; goto _test_eof; 
	_test_eof540: cs = 540; goto _test_eof; 
	_test_eof541: cs = 541; goto _test_eof; 
	_test_eof542: cs = 542; goto _test_eof; 
	_test_eof543: cs = 543; goto _test_eof; 
	_test_eof544: cs = 544; goto _test_eof; 
	_test_eof545: cs = 545; goto _test_eof; 
	_test_eof546: cs = 546; goto _test_eof; 
	_test_eof547: cs = 547; goto _test_eof; 
	_test_eof548: cs = 548; goto _test_eof; 
	_test_eof549: cs = 549; goto _test_eof; 
	_test_eof550: cs = 550; goto _test_eof; 
	_test_eof551: cs = 551; goto _test_eof; 
	_test_eof552: cs = 552; goto _test_eof; 
	_test_eof553: cs = 553; goto _test_eof; 
	_test_eof554: cs = 554; goto _test_eof; 
	_test_eof1747: cs = 1747; goto _test_eof; 
	_test_eof555: cs = 555; goto _test_eof; 
	_test_eof556: cs = 556; goto _test_eof; 
	_test_eof557: cs = 557; goto _test_eof; 
	_test_eof558: cs = 558; goto _test_eof; 
	_test_eof559: cs = 559; goto _test_eof; 
	_test_eof560: cs = 560; goto _test_eof; 
	_test_eof561: cs = 561; goto _test_eof; 
	_test_eof562: cs = 562; goto _test_eof; 
	_test_eof563: cs = 563; goto _test_eof; 
	_test_eof564: cs = 564; goto _test_eof; 
	_test_eof565: cs = 565; goto _test_eof; 
	_test_eof1748: cs = 1748; goto _test_eof; 
	_test_eof566: cs = 566; goto _test_eof; 
	_test_eof567: cs = 567; goto _test_eof; 
	_test_eof568: cs = 568; goto _test_eof; 
	_test_eof569: cs = 569; goto _test_eof; 
	_test_eof570: cs = 570; goto _test_eof; 
	_test_eof571: cs = 571; goto _test_eof; 
	_test_eof572: cs = 572; goto _test_eof; 
	_test_eof573: cs = 573; goto _test_eof; 
	_test_eof574: cs = 574; goto _test_eof; 
	_test_eof575: cs = 575; goto _test_eof; 
	_test_eof576: cs = 576; goto _test_eof; 
	_test_eof577: cs = 577; goto _test_eof; 
	_test_eof578: cs = 578; goto _test_eof; 
	_test_eof579: cs = 579; goto _test_eof; 
	_test_eof580: cs = 580; goto _test_eof; 
	_test_eof581: cs = 581; goto _test_eof; 
	_test_eof582: cs = 582; goto _test_eof; 
	_test_eof583: cs = 583; goto _test_eof; 
	_test_eof584: cs = 584; goto _test_eof; 
	_test_eof585: cs = 585; goto _test_eof; 
	_test_eof586: cs = 586; goto _test_eof; 
	_test_eof587: cs = 587; goto _test_eof; 
	_test_eof588: cs = 588; goto _test_eof; 
	_test_eof589: cs = 589; goto _test_eof; 
	_test_eof590: cs = 590; goto _test_eof; 
	_test_eof591: cs = 591; goto _test_eof; 
	_test_eof592: cs = 592; goto _test_eof; 
	_test_eof593: cs = 593; goto _test_eof; 
	_test_eof594: cs = 594; goto _test_eof; 
	_test_eof595: cs = 595; goto _test_eof; 
	_test_eof596: cs = 596; goto _test_eof; 
	_test_eof597: cs = 597; goto _test_eof; 
	_test_eof598: cs = 598; goto _test_eof; 
	_test_eof599: cs = 599; goto _test_eof; 
	_test_eof1749: cs = 1749; goto _test_eof; 
	_test_eof600: cs = 600; goto _test_eof; 
	_test_eof1750: cs = 1750; goto _test_eof; 
	_test_eof601: cs = 601; goto _test_eof; 
	_test_eof602: cs = 602; goto _test_eof; 
	_test_eof603: cs = 603; goto _test_eof; 
	_test_eof604: cs = 604; goto _test_eof; 
	_test_eof605: cs = 605; goto _test_eof; 
	_test_eof606: cs = 606; goto _test_eof; 
	_test_eof607: cs = 607; goto _test_eof; 
	_test_eof608: cs = 608; goto _test_eof; 
	_test_eof609: cs = 609; goto _test_eof; 
	_test_eof610: cs = 610; goto _test_eof; 
	_test_eof611: cs = 611; goto _test_eof; 
	_test_eof612: cs = 612; goto _test_eof; 
	_test_eof613: cs = 613; goto _test_eof; 
	_test_eof614: cs = 614; goto _test_eof; 
	_test_eof615: cs = 615; goto _test_eof; 
	_test_eof616: cs = 616; goto _test_eof; 
	_test_eof617: cs = 617; goto _test_eof; 
	_test_eof1751: cs = 1751; goto _test_eof; 
	_test_eof618: cs = 618; goto _test_eof; 
	_test_eof1752: cs = 1752; goto _test_eof; 
	_test_eof619: cs = 619; goto _test_eof; 
	_test_eof620: cs = 620; goto _test_eof; 
	_test_eof621: cs = 621; goto _test_eof; 
	_test_eof622: cs = 622; goto _test_eof; 
	_test_eof623: cs = 623; goto _test_eof; 
	_test_eof624: cs = 624; goto _test_eof; 
	_test_eof625: cs = 625; goto _test_eof; 
	_test_eof626: cs = 626; goto _test_eof; 
	_test_eof627: cs = 627; goto _test_eof; 
	_test_eof628: cs = 628; goto _test_eof; 
	_test_eof629: cs = 629; goto _test_eof; 
	_test_eof1753: cs = 1753; goto _test_eof; 
	_test_eof630: cs = 630; goto _test_eof; 
	_test_eof631: cs = 631; goto _test_eof; 
	_test_eof632: cs = 632; goto _test_eof; 
	_test_eof633: cs = 633; goto _test_eof; 
	_test_eof1754: cs = 1754; goto _test_eof; 
	_test_eof634: cs = 634; goto _test_eof; 
	_test_eof1755: cs = 1755; goto _test_eof; 
	_test_eof635: cs = 635; goto _test_eof; 
	_test_eof636: cs = 636; goto _test_eof; 
	_test_eof637: cs = 637; goto _test_eof; 
	_test_eof638: cs = 638; goto _test_eof; 
	_test_eof639: cs = 639; goto _test_eof; 
	_test_eof640: cs = 640; goto _test_eof; 
	_test_eof641: cs = 641; goto _test_eof; 
	_test_eof642: cs = 642; goto _test_eof; 
	_test_eof643: cs = 643; goto _test_eof; 
	_test_eof644: cs = 644; goto _test_eof; 
	_test_eof645: cs = 645; goto _test_eof; 
	_test_eof646: cs = 646; goto _test_eof; 
	_test_eof647: cs = 647; goto _test_eof; 
	_test_eof648: cs = 648; goto _test_eof; 
	_test_eof649: cs = 649; goto _test_eof; 
	_test_eof650: cs = 650; goto _test_eof; 
	_test_eof651: cs = 651; goto _test_eof; 
	_test_eof652: cs = 652; goto _test_eof; 
	_test_eof653: cs = 653; goto _test_eof; 
	_test_eof654: cs = 654; goto _test_eof; 
	_test_eof655: cs = 655; goto _test_eof; 
	_test_eof656: cs = 656; goto _test_eof; 
	_test_eof657: cs = 657; goto _test_eof; 
	_test_eof658: cs = 658; goto _test_eof; 
	_test_eof659: cs = 659; goto _test_eof; 
	_test_eof660: cs = 660; goto _test_eof; 
	_test_eof661: cs = 661; goto _test_eof; 
	_test_eof662: cs = 662; goto _test_eof; 
	_test_eof663: cs = 663; goto _test_eof; 
	_test_eof664: cs = 664; goto _test_eof; 
	_test_eof665: cs = 665; goto _test_eof; 
	_test_eof666: cs = 666; goto _test_eof; 
	_test_eof667: cs = 667; goto _test_eof; 
	_test_eof1756: cs = 1756; goto _test_eof; 
	_test_eof668: cs = 668; goto _test_eof; 
	_test_eof669: cs = 669; goto _test_eof; 
	_test_eof670: cs = 670; goto _test_eof; 
	_test_eof671: cs = 671; goto _test_eof; 
	_test_eof672: cs = 672; goto _test_eof; 
	_test_eof673: cs = 673; goto _test_eof; 
	_test_eof674: cs = 674; goto _test_eof; 
	_test_eof675: cs = 675; goto _test_eof; 
	_test_eof676: cs = 676; goto _test_eof; 
	_test_eof677: cs = 677; goto _test_eof; 
	_test_eof678: cs = 678; goto _test_eof; 
	_test_eof679: cs = 679; goto _test_eof; 
	_test_eof680: cs = 680; goto _test_eof; 
	_test_eof681: cs = 681; goto _test_eof; 
	_test_eof682: cs = 682; goto _test_eof; 
	_test_eof683: cs = 683; goto _test_eof; 
	_test_eof684: cs = 684; goto _test_eof; 
	_test_eof685: cs = 685; goto _test_eof; 
	_test_eof686: cs = 686; goto _test_eof; 
	_test_eof687: cs = 687; goto _test_eof; 
	_test_eof688: cs = 688; goto _test_eof; 
	_test_eof689: cs = 689; goto _test_eof; 
	_test_eof690: cs = 690; goto _test_eof; 
	_test_eof691: cs = 691; goto _test_eof; 
	_test_eof692: cs = 692; goto _test_eof; 
	_test_eof693: cs = 693; goto _test_eof; 
	_test_eof694: cs = 694; goto _test_eof; 
	_test_eof695: cs = 695; goto _test_eof; 
	_test_eof696: cs = 696; goto _test_eof; 
	_test_eof697: cs = 697; goto _test_eof; 
	_test_eof698: cs = 698; goto _test_eof; 
	_test_eof699: cs = 699; goto _test_eof; 
	_test_eof700: cs = 700; goto _test_eof; 
	_test_eof701: cs = 701; goto _test_eof; 
	_test_eof1757: cs = 1757; goto _test_eof; 
	_test_eof702: cs = 702; goto _test_eof; 
	_test_eof703: cs = 703; goto _test_eof; 
	_test_eof704: cs = 704; goto _test_eof; 
	_test_eof705: cs = 705; goto _test_eof; 
	_test_eof706: cs = 706; goto _test_eof; 
	_test_eof707: cs = 707; goto _test_eof; 
	_test_eof1758: cs = 1758; goto _test_eof; 
	_test_eof708: cs = 708; goto _test_eof; 
	_test_eof709: cs = 709; goto _test_eof; 
	_test_eof710: cs = 710; goto _test_eof; 
	_test_eof711: cs = 711; goto _test_eof; 
	_test_eof712: cs = 712; goto _test_eof; 
	_test_eof713: cs = 713; goto _test_eof; 
	_test_eof714: cs = 714; goto _test_eof; 
	_test_eof1759: cs = 1759; goto _test_eof; 
	_test_eof715: cs = 715; goto _test_eof; 
	_test_eof1760: cs = 1760; goto _test_eof; 
	_test_eof716: cs = 716; goto _test_eof; 
	_test_eof717: cs = 717; goto _test_eof; 
	_test_eof718: cs = 718; goto _test_eof; 
	_test_eof719: cs = 719; goto _test_eof; 
	_test_eof720: cs = 720; goto _test_eof; 
	_test_eof721: cs = 721; goto _test_eof; 
	_test_eof722: cs = 722; goto _test_eof; 
	_test_eof723: cs = 723; goto _test_eof; 
	_test_eof724: cs = 724; goto _test_eof; 
	_test_eof725: cs = 725; goto _test_eof; 
	_test_eof726: cs = 726; goto _test_eof; 
	_test_eof727: cs = 727; goto _test_eof; 
	_test_eof728: cs = 728; goto _test_eof; 
	_test_eof729: cs = 729; goto _test_eof; 
	_test_eof730: cs = 730; goto _test_eof; 
	_test_eof731: cs = 731; goto _test_eof; 
	_test_eof732: cs = 732; goto _test_eof; 
	_test_eof733: cs = 733; goto _test_eof; 
	_test_eof734: cs = 734; goto _test_eof; 
	_test_eof735: cs = 735; goto _test_eof; 
	_test_eof736: cs = 736; goto _test_eof; 
	_test_eof737: cs = 737; goto _test_eof; 
	_test_eof738: cs = 738; goto _test_eof; 
	_test_eof739: cs = 739; goto _test_eof; 
	_test_eof740: cs = 740; goto _test_eof; 
	_test_eof741: cs = 741; goto _test_eof; 
	_test_eof742: cs = 742; goto _test_eof; 
	_test_eof743: cs = 743; goto _test_eof; 
	_test_eof744: cs = 744; goto _test_eof; 
	_test_eof745: cs = 745; goto _test_eof; 
	_test_eof746: cs = 746; goto _test_eof; 
	_test_eof747: cs = 747; goto _test_eof; 
	_test_eof748: cs = 748; goto _test_eof; 
	_test_eof749: cs = 749; goto _test_eof; 
	_test_eof750: cs = 750; goto _test_eof; 
	_test_eof751: cs = 751; goto _test_eof; 
	_test_eof752: cs = 752; goto _test_eof; 
	_test_eof753: cs = 753; goto _test_eof; 
	_test_eof754: cs = 754; goto _test_eof; 
	_test_eof755: cs = 755; goto _test_eof; 
	_test_eof756: cs = 756; goto _test_eof; 
	_test_eof757: cs = 757; goto _test_eof; 
	_test_eof758: cs = 758; goto _test_eof; 
	_test_eof759: cs = 759; goto _test_eof; 
	_test_eof760: cs = 760; goto _test_eof; 
	_test_eof761: cs = 761; goto _test_eof; 
	_test_eof762: cs = 762; goto _test_eof; 
	_test_eof763: cs = 763; goto _test_eof; 
	_test_eof764: cs = 764; goto _test_eof; 
	_test_eof765: cs = 765; goto _test_eof; 
	_test_eof766: cs = 766; goto _test_eof; 
	_test_eof767: cs = 767; goto _test_eof; 
	_test_eof768: cs = 768; goto _test_eof; 
	_test_eof769: cs = 769; goto _test_eof; 
	_test_eof770: cs = 770; goto _test_eof; 
	_test_eof771: cs = 771; goto _test_eof; 
	_test_eof772: cs = 772; goto _test_eof; 
	_test_eof773: cs = 773; goto _test_eof; 
	_test_eof774: cs = 774; goto _test_eof; 
	_test_eof1761: cs = 1761; goto _test_eof; 
	_test_eof775: cs = 775; goto _test_eof; 
	_test_eof776: cs = 776; goto _test_eof; 
	_test_eof777: cs = 777; goto _test_eof; 
	_test_eof778: cs = 778; goto _test_eof; 
	_test_eof779: cs = 779; goto _test_eof; 
	_test_eof780: cs = 780; goto _test_eof; 
	_test_eof781: cs = 781; goto _test_eof; 
	_test_eof1762: cs = 1762; goto _test_eof; 
	_test_eof782: cs = 782; goto _test_eof; 
	_test_eof1763: cs = 1763; goto _test_eof; 
	_test_eof783: cs = 783; goto _test_eof; 
	_test_eof784: cs = 784; goto _test_eof; 
	_test_eof785: cs = 785; goto _test_eof; 
	_test_eof786: cs = 786; goto _test_eof; 
	_test_eof787: cs = 787; goto _test_eof; 
	_test_eof788: cs = 788; goto _test_eof; 
	_test_eof789: cs = 789; goto _test_eof; 
	_test_eof790: cs = 790; goto _test_eof; 
	_test_eof791: cs = 791; goto _test_eof; 
	_test_eof792: cs = 792; goto _test_eof; 
	_test_eof793: cs = 793; goto _test_eof; 
	_test_eof794: cs = 794; goto _test_eof; 
	_test_eof795: cs = 795; goto _test_eof; 
	_test_eof796: cs = 796; goto _test_eof; 
	_test_eof797: cs = 797; goto _test_eof; 
	_test_eof798: cs = 798; goto _test_eof; 
	_test_eof799: cs = 799; goto _test_eof; 
	_test_eof800: cs = 800; goto _test_eof; 
	_test_eof801: cs = 801; goto _test_eof; 
	_test_eof802: cs = 802; goto _test_eof; 
	_test_eof803: cs = 803; goto _test_eof; 
	_test_eof804: cs = 804; goto _test_eof; 
	_test_eof805: cs = 805; goto _test_eof; 
	_test_eof806: cs = 806; goto _test_eof; 
	_test_eof807: cs = 807; goto _test_eof; 
	_test_eof808: cs = 808; goto _test_eof; 
	_test_eof809: cs = 809; goto _test_eof; 
	_test_eof810: cs = 810; goto _test_eof; 
	_test_eof811: cs = 811; goto _test_eof; 
	_test_eof812: cs = 812; goto _test_eof; 
	_test_eof813: cs = 813; goto _test_eof; 
	_test_eof814: cs = 814; goto _test_eof; 
	_test_eof815: cs = 815; goto _test_eof; 
	_test_eof816: cs = 816; goto _test_eof; 
	_test_eof817: cs = 817; goto _test_eof; 
	_test_eof818: cs = 818; goto _test_eof; 
	_test_eof819: cs = 819; goto _test_eof; 
	_test_eof820: cs = 820; goto _test_eof; 
	_test_eof821: cs = 821; goto _test_eof; 
	_test_eof822: cs = 822; goto _test_eof; 
	_test_eof823: cs = 823; goto _test_eof; 
	_test_eof824: cs = 824; goto _test_eof; 
	_test_eof825: cs = 825; goto _test_eof; 
	_test_eof826: cs = 826; goto _test_eof; 
	_test_eof827: cs = 827; goto _test_eof; 
	_test_eof828: cs = 828; goto _test_eof; 
	_test_eof829: cs = 829; goto _test_eof; 
	_test_eof830: cs = 830; goto _test_eof; 
	_test_eof831: cs = 831; goto _test_eof; 
	_test_eof832: cs = 832; goto _test_eof; 
	_test_eof833: cs = 833; goto _test_eof; 
	_test_eof834: cs = 834; goto _test_eof; 
	_test_eof835: cs = 835; goto _test_eof; 
	_test_eof836: cs = 836; goto _test_eof; 
	_test_eof837: cs = 837; goto _test_eof; 
	_test_eof838: cs = 838; goto _test_eof; 
	_test_eof839: cs = 839; goto _test_eof; 
	_test_eof1764: cs = 1764; goto _test_eof; 
	_test_eof840: cs = 840; goto _test_eof; 
	_test_eof1765: cs = 1765; goto _test_eof; 
	_test_eof841: cs = 841; goto _test_eof; 
	_test_eof842: cs = 842; goto _test_eof; 
	_test_eof843: cs = 843; goto _test_eof; 
	_test_eof844: cs = 844; goto _test_eof; 
	_test_eof845: cs = 845; goto _test_eof; 
	_test_eof846: cs = 846; goto _test_eof; 
	_test_eof847: cs = 847; goto _test_eof; 
	_test_eof848: cs = 848; goto _test_eof; 
	_test_eof849: cs = 849; goto _test_eof; 
	_test_eof850: cs = 850; goto _test_eof; 
	_test_eof851: cs = 851; goto _test_eof; 
	_test_eof852: cs = 852; goto _test_eof; 
	_test_eof853: cs = 853; goto _test_eof; 
	_test_eof854: cs = 854; goto _test_eof; 
	_test_eof1766: cs = 1766; goto _test_eof; 
	_test_eof855: cs = 855; goto _test_eof; 
	_test_eof1767: cs = 1767; goto _test_eof; 
	_test_eof856: cs = 856; goto _test_eof; 
	_test_eof857: cs = 857; goto _test_eof; 
	_test_eof858: cs = 858; goto _test_eof; 
	_test_eof859: cs = 859; goto _test_eof; 
	_test_eof860: cs = 860; goto _test_eof; 
	_test_eof861: cs = 861; goto _test_eof; 
	_test_eof862: cs = 862; goto _test_eof; 
	_test_eof863: cs = 863; goto _test_eof; 
	_test_eof864: cs = 864; goto _test_eof; 
	_test_eof865: cs = 865; goto _test_eof; 
	_test_eof866: cs = 866; goto _test_eof; 
	_test_eof867: cs = 867; goto _test_eof; 
	_test_eof868: cs = 868; goto _test_eof; 
	_test_eof869: cs = 869; goto _test_eof; 
	_test_eof870: cs = 870; goto _test_eof; 
	_test_eof871: cs = 871; goto _test_eof; 
	_test_eof872: cs = 872; goto _test_eof; 
	_test_eof1768: cs = 1768; goto _test_eof; 
	_test_eof873: cs = 873; goto _test_eof; 
	_test_eof1769: cs = 1769; goto _test_eof; 
	_test_eof874: cs = 874; goto _test_eof; 
	_test_eof875: cs = 875; goto _test_eof; 
	_test_eof876: cs = 876; goto _test_eof; 
	_test_eof877: cs = 877; goto _test_eof; 
	_test_eof1770: cs = 1770; goto _test_eof; 
	_test_eof878: cs = 878; goto _test_eof; 
	_test_eof879: cs = 879; goto _test_eof; 
	_test_eof880: cs = 880; goto _test_eof; 
	_test_eof881: cs = 881; goto _test_eof; 
	_test_eof882: cs = 882; goto _test_eof; 
	_test_eof883: cs = 883; goto _test_eof; 
	_test_eof884: cs = 884; goto _test_eof; 
	_test_eof885: cs = 885; goto _test_eof; 
	_test_eof886: cs = 886; goto _test_eof; 
	_test_eof887: cs = 887; goto _test_eof; 
	_test_eof888: cs = 888; goto _test_eof; 
	_test_eof889: cs = 889; goto _test_eof; 
	_test_eof890: cs = 890; goto _test_eof; 
	_test_eof891: cs = 891; goto _test_eof; 
	_test_eof892: cs = 892; goto _test_eof; 
	_test_eof893: cs = 893; goto _test_eof; 
	_test_eof894: cs = 894; goto _test_eof; 
	_test_eof895: cs = 895; goto _test_eof; 
	_test_eof896: cs = 896; goto _test_eof; 
	_test_eof897: cs = 897; goto _test_eof; 
	_test_eof898: cs = 898; goto _test_eof; 
	_test_eof899: cs = 899; goto _test_eof; 
	_test_eof900: cs = 900; goto _test_eof; 
	_test_eof901: cs = 901; goto _test_eof; 
	_test_eof902: cs = 902; goto _test_eof; 
	_test_eof903: cs = 903; goto _test_eof; 
	_test_eof904: cs = 904; goto _test_eof; 
	_test_eof1771: cs = 1771; goto _test_eof; 
	_test_eof905: cs = 905; goto _test_eof; 
	_test_eof1772: cs = 1772; goto _test_eof; 
	_test_eof906: cs = 906; goto _test_eof; 
	_test_eof907: cs = 907; goto _test_eof; 
	_test_eof908: cs = 908; goto _test_eof; 
	_test_eof909: cs = 909; goto _test_eof; 
	_test_eof910: cs = 910; goto _test_eof; 
	_test_eof911: cs = 911; goto _test_eof; 
	_test_eof912: cs = 912; goto _test_eof; 
	_test_eof913: cs = 913; goto _test_eof; 
	_test_eof914: cs = 914; goto _test_eof; 
	_test_eof915: cs = 915; goto _test_eof; 
	_test_eof916: cs = 916; goto _test_eof; 
	_test_eof917: cs = 917; goto _test_eof; 
	_test_eof918: cs = 918; goto _test_eof; 
	_test_eof919: cs = 919; goto _test_eof; 
	_test_eof920: cs = 920; goto _test_eof; 
	_test_eof921: cs = 921; goto _test_eof; 
	_test_eof922: cs = 922; goto _test_eof; 
	_test_eof923: cs = 923; goto _test_eof; 
	_test_eof924: cs = 924; goto _test_eof; 
	_test_eof925: cs = 925; goto _test_eof; 
	_test_eof926: cs = 926; goto _test_eof; 
	_test_eof927: cs = 927; goto _test_eof; 
	_test_eof928: cs = 928; goto _test_eof; 
	_test_eof929: cs = 929; goto _test_eof; 
	_test_eof930: cs = 930; goto _test_eof; 
	_test_eof931: cs = 931; goto _test_eof; 
	_test_eof932: cs = 932; goto _test_eof; 
	_test_eof1773: cs = 1773; goto _test_eof; 
	_test_eof933: cs = 933; goto _test_eof; 
	_test_eof1774: cs = 1774; goto _test_eof; 
	_test_eof934: cs = 934; goto _test_eof; 
	_test_eof935: cs = 935; goto _test_eof; 
	_test_eof936: cs = 936; goto _test_eof; 
	_test_eof937: cs = 937; goto _test_eof; 
	_test_eof938: cs = 938; goto _test_eof; 
	_test_eof939: cs = 939; goto _test_eof; 
	_test_eof940: cs = 940; goto _test_eof; 
	_test_eof941: cs = 941; goto _test_eof; 
	_test_eof942: cs = 942; goto _test_eof; 
	_test_eof943: cs = 943; goto _test_eof; 
	_test_eof944: cs = 944; goto _test_eof; 
	_test_eof945: cs = 945; goto _test_eof; 
	_test_eof946: cs = 946; goto _test_eof; 
	_test_eof947: cs = 947; goto _test_eof; 
	_test_eof948: cs = 948; goto _test_eof; 
	_test_eof949: cs = 949; goto _test_eof; 
	_test_eof1775: cs = 1775; goto _test_eof; 
	_test_eof950: cs = 950; goto _test_eof; 
	_test_eof1776: cs = 1776; goto _test_eof; 
	_test_eof951: cs = 951; goto _test_eof; 
	_test_eof952: cs = 952; goto _test_eof; 
	_test_eof953: cs = 953; goto _test_eof; 
	_test_eof954: cs = 954; goto _test_eof; 
	_test_eof955: cs = 955; goto _test_eof; 
	_test_eof956: cs = 956; goto _test_eof; 
	_test_eof957: cs = 957; goto _test_eof; 
	_test_eof958: cs = 958; goto _test_eof; 
	_test_eof959: cs = 959; goto _test_eof; 
	_test_eof960: cs = 960; goto _test_eof; 
	_test_eof961: cs = 961; goto _test_eof; 
	_test_eof962: cs = 962; goto _test_eof; 
	_test_eof963: cs = 963; goto _test_eof; 
	_test_eof964: cs = 964; goto _test_eof; 
	_test_eof965: cs = 965; goto _test_eof; 
	_test_eof966: cs = 966; goto _test_eof; 
	_test_eof967: cs = 967; goto _test_eof; 
	_test_eof968: cs = 968; goto _test_eof; 
	_test_eof969: cs = 969; goto _test_eof; 
	_test_eof970: cs = 970; goto _test_eof; 
	_test_eof971: cs = 971; goto _test_eof; 
	_test_eof972: cs = 972; goto _test_eof; 
	_test_eof973: cs = 973; goto _test_eof; 
	_test_eof974: cs = 974; goto _test_eof; 
	_test_eof975: cs = 975; goto _test_eof; 
	_test_eof976: cs = 976; goto _test_eof; 
	_test_eof977: cs = 977; goto _test_eof; 
	_test_eof978: cs = 978; goto _test_eof; 
	_test_eof979: cs = 979; goto _test_eof; 
	_test_eof980: cs = 980; goto _test_eof; 
	_test_eof981: cs = 981; goto _test_eof; 
	_test_eof982: cs = 982; goto _test_eof; 
	_test_eof983: cs = 983; goto _test_eof; 
	_test_eof984: cs = 984; goto _test_eof; 
	_test_eof985: cs = 985; goto _test_eof; 
	_test_eof986: cs = 986; goto _test_eof; 
	_test_eof987: cs = 987; goto _test_eof; 
	_test_eof988: cs = 988; goto _test_eof; 
	_test_eof989: cs = 989; goto _test_eof; 
	_test_eof990: cs = 990; goto _test_eof; 
	_test_eof991: cs = 991; goto _test_eof; 
	_test_eof992: cs = 992; goto _test_eof; 
	_test_eof993: cs = 993; goto _test_eof; 
	_test_eof994: cs = 994; goto _test_eof; 
	_test_eof995: cs = 995; goto _test_eof; 
	_test_eof996: cs = 996; goto _test_eof; 
	_test_eof997: cs = 997; goto _test_eof; 
	_test_eof998: cs = 998; goto _test_eof; 
	_test_eof999: cs = 999; goto _test_eof; 
	_test_eof1000: cs = 1000; goto _test_eof; 
	_test_eof1001: cs = 1001; goto _test_eof; 
	_test_eof1002: cs = 1002; goto _test_eof; 
	_test_eof1003: cs = 1003; goto _test_eof; 
	_test_eof1004: cs = 1004; goto _test_eof; 
	_test_eof1005: cs = 1005; goto _test_eof; 
	_test_eof1006: cs = 1006; goto _test_eof; 
	_test_eof1007: cs = 1007; goto _test_eof; 
	_test_eof1008: cs = 1008; goto _test_eof; 
	_test_eof1009: cs = 1009; goto _test_eof; 
	_test_eof1010: cs = 1010; goto _test_eof; 
	_test_eof1011: cs = 1011; goto _test_eof; 
	_test_eof1012: cs = 1012; goto _test_eof; 
	_test_eof1013: cs = 1013; goto _test_eof; 
	_test_eof1014: cs = 1014; goto _test_eof; 
	_test_eof1015: cs = 1015; goto _test_eof; 
	_test_eof1016: cs = 1016; goto _test_eof; 
	_test_eof1017: cs = 1017; goto _test_eof; 
	_test_eof1018: cs = 1018; goto _test_eof; 
	_test_eof1019: cs = 1019; goto _test_eof; 
	_test_eof1020: cs = 1020; goto _test_eof; 
	_test_eof1021: cs = 1021; goto _test_eof; 
	_test_eof1022: cs = 1022; goto _test_eof; 
	_test_eof1023: cs = 1023; goto _test_eof; 
	_test_eof1024: cs = 1024; goto _test_eof; 
	_test_eof1025: cs = 1025; goto _test_eof; 
	_test_eof1026: cs = 1026; goto _test_eof; 
	_test_eof1027: cs = 1027; goto _test_eof; 
	_test_eof1028: cs = 1028; goto _test_eof; 
	_test_eof1029: cs = 1029; goto _test_eof; 
	_test_eof1030: cs = 1030; goto _test_eof; 
	_test_eof1031: cs = 1031; goto _test_eof; 
	_test_eof1032: cs = 1032; goto _test_eof; 
	_test_eof1033: cs = 1033; goto _test_eof; 
	_test_eof1034: cs = 1034; goto _test_eof; 
	_test_eof1035: cs = 1035; goto _test_eof; 
	_test_eof1036: cs = 1036; goto _test_eof; 
	_test_eof1037: cs = 1037; goto _test_eof; 
	_test_eof1038: cs = 1038; goto _test_eof; 
	_test_eof1039: cs = 1039; goto _test_eof; 
	_test_eof1040: cs = 1040; goto _test_eof; 
	_test_eof1041: cs = 1041; goto _test_eof; 
	_test_eof1042: cs = 1042; goto _test_eof; 
	_test_eof1043: cs = 1043; goto _test_eof; 
	_test_eof1044: cs = 1044; goto _test_eof; 
	_test_eof1045: cs = 1045; goto _test_eof; 
	_test_eof1046: cs = 1046; goto _test_eof; 
	_test_eof1047: cs = 1047; goto _test_eof; 
	_test_eof1048: cs = 1048; goto _test_eof; 
	_test_eof1049: cs = 1049; goto _test_eof; 
	_test_eof1050: cs = 1050; goto _test_eof; 
	_test_eof1051: cs = 1051; goto _test_eof; 
	_test_eof1052: cs = 1052; goto _test_eof; 
	_test_eof1053: cs = 1053; goto _test_eof; 
	_test_eof1054: cs = 1054; goto _test_eof; 
	_test_eof1055: cs = 1055; goto _test_eof; 
	_test_eof1056: cs = 1056; goto _test_eof; 
	_test_eof1057: cs = 1057; goto _test_eof; 
	_test_eof1058: cs = 1058; goto _test_eof; 
	_test_eof1059: cs = 1059; goto _test_eof; 
	_test_eof1060: cs = 1060; goto _test_eof; 
	_test_eof1061: cs = 1061; goto _test_eof; 
	_test_eof1062: cs = 1062; goto _test_eof; 
	_test_eof1063: cs = 1063; goto _test_eof; 
	_test_eof1064: cs = 1064; goto _test_eof; 
	_test_eof1065: cs = 1065; goto _test_eof; 
	_test_eof1066: cs = 1066; goto _test_eof; 
	_test_eof1067: cs = 1067; goto _test_eof; 
	_test_eof1068: cs = 1068; goto _test_eof; 
	_test_eof1069: cs = 1069; goto _test_eof; 
	_test_eof1070: cs = 1070; goto _test_eof; 
	_test_eof1071: cs = 1071; goto _test_eof; 
	_test_eof1072: cs = 1072; goto _test_eof; 
	_test_eof1073: cs = 1073; goto _test_eof; 
	_test_eof1074: cs = 1074; goto _test_eof; 
	_test_eof1075: cs = 1075; goto _test_eof; 
	_test_eof1076: cs = 1076; goto _test_eof; 
	_test_eof1077: cs = 1077; goto _test_eof; 
	_test_eof1078: cs = 1078; goto _test_eof; 
	_test_eof1079: cs = 1079; goto _test_eof; 
	_test_eof1080: cs = 1080; goto _test_eof; 
	_test_eof1081: cs = 1081; goto _test_eof; 
	_test_eof1082: cs = 1082; goto _test_eof; 
	_test_eof1083: cs = 1083; goto _test_eof; 
	_test_eof1084: cs = 1084; goto _test_eof; 
	_test_eof1085: cs = 1085; goto _test_eof; 
	_test_eof1086: cs = 1086; goto _test_eof; 
	_test_eof1087: cs = 1087; goto _test_eof; 
	_test_eof1088: cs = 1088; goto _test_eof; 
	_test_eof1089: cs = 1089; goto _test_eof; 
	_test_eof1090: cs = 1090; goto _test_eof; 
	_test_eof1091: cs = 1091; goto _test_eof; 
	_test_eof1092: cs = 1092; goto _test_eof; 
	_test_eof1093: cs = 1093; goto _test_eof; 
	_test_eof1094: cs = 1094; goto _test_eof; 
	_test_eof1095: cs = 1095; goto _test_eof; 
	_test_eof1096: cs = 1096; goto _test_eof; 
	_test_eof1097: cs = 1097; goto _test_eof; 
	_test_eof1098: cs = 1098; goto _test_eof; 
	_test_eof1099: cs = 1099; goto _test_eof; 
	_test_eof1100: cs = 1100; goto _test_eof; 
	_test_eof1101: cs = 1101; goto _test_eof; 
	_test_eof1102: cs = 1102; goto _test_eof; 
	_test_eof1103: cs = 1103; goto _test_eof; 
	_test_eof1777: cs = 1777; goto _test_eof; 
	_test_eof1104: cs = 1104; goto _test_eof; 
	_test_eof1778: cs = 1778; goto _test_eof; 
	_test_eof1105: cs = 1105; goto _test_eof; 
	_test_eof1106: cs = 1106; goto _test_eof; 
	_test_eof1107: cs = 1107; goto _test_eof; 
	_test_eof1108: cs = 1108; goto _test_eof; 
	_test_eof1109: cs = 1109; goto _test_eof; 
	_test_eof1110: cs = 1110; goto _test_eof; 
	_test_eof1111: cs = 1111; goto _test_eof; 
	_test_eof1112: cs = 1112; goto _test_eof; 
	_test_eof1113: cs = 1113; goto _test_eof; 
	_test_eof1114: cs = 1114; goto _test_eof; 
	_test_eof1115: cs = 1115; goto _test_eof; 
	_test_eof1116: cs = 1116; goto _test_eof; 
	_test_eof1117: cs = 1117; goto _test_eof; 
	_test_eof1118: cs = 1118; goto _test_eof; 
	_test_eof1119: cs = 1119; goto _test_eof; 
	_test_eof1120: cs = 1120; goto _test_eof; 
	_test_eof1121: cs = 1121; goto _test_eof; 
	_test_eof1122: cs = 1122; goto _test_eof; 
	_test_eof1123: cs = 1123; goto _test_eof; 
	_test_eof1124: cs = 1124; goto _test_eof; 
	_test_eof1125: cs = 1125; goto _test_eof; 
	_test_eof1126: cs = 1126; goto _test_eof; 
	_test_eof1127: cs = 1127; goto _test_eof; 
	_test_eof1128: cs = 1128; goto _test_eof; 
	_test_eof1129: cs = 1129; goto _test_eof; 
	_test_eof1130: cs = 1130; goto _test_eof; 
	_test_eof1131: cs = 1131; goto _test_eof; 
	_test_eof1132: cs = 1132; goto _test_eof; 
	_test_eof1133: cs = 1133; goto _test_eof; 
	_test_eof1134: cs = 1134; goto _test_eof; 
	_test_eof1135: cs = 1135; goto _test_eof; 
	_test_eof1136: cs = 1136; goto _test_eof; 
	_test_eof1137: cs = 1137; goto _test_eof; 
	_test_eof1138: cs = 1138; goto _test_eof; 
	_test_eof1139: cs = 1139; goto _test_eof; 
	_test_eof1140: cs = 1140; goto _test_eof; 
	_test_eof1141: cs = 1141; goto _test_eof; 
	_test_eof1142: cs = 1142; goto _test_eof; 
	_test_eof1143: cs = 1143; goto _test_eof; 
	_test_eof1144: cs = 1144; goto _test_eof; 
	_test_eof1145: cs = 1145; goto _test_eof; 
	_test_eof1146: cs = 1146; goto _test_eof; 
	_test_eof1147: cs = 1147; goto _test_eof; 
	_test_eof1148: cs = 1148; goto _test_eof; 
	_test_eof1149: cs = 1149; goto _test_eof; 
	_test_eof1150: cs = 1150; goto _test_eof; 
	_test_eof1151: cs = 1151; goto _test_eof; 
	_test_eof1152: cs = 1152; goto _test_eof; 
	_test_eof1153: cs = 1153; goto _test_eof; 
	_test_eof1779: cs = 1779; goto _test_eof; 
	_test_eof1154: cs = 1154; goto _test_eof; 
	_test_eof1780: cs = 1780; goto _test_eof; 
	_test_eof1155: cs = 1155; goto _test_eof; 
	_test_eof1156: cs = 1156; goto _test_eof; 
	_test_eof1157: cs = 1157; goto _test_eof; 
	_test_eof1158: cs = 1158; goto _test_eof; 
	_test_eof1159: cs = 1159; goto _test_eof; 
	_test_eof1160: cs = 1160; goto _test_eof; 
	_test_eof1161: cs = 1161; goto _test_eof; 
	_test_eof1162: cs = 1162; goto _test_eof; 
	_test_eof1163: cs = 1163; goto _test_eof; 
	_test_eof1164: cs = 1164; goto _test_eof; 
	_test_eof1165: cs = 1165; goto _test_eof; 
	_test_eof1166: cs = 1166; goto _test_eof; 
	_test_eof1167: cs = 1167; goto _test_eof; 
	_test_eof1168: cs = 1168; goto _test_eof; 
	_test_eof1169: cs = 1169; goto _test_eof; 
	_test_eof1170: cs = 1170; goto _test_eof; 
	_test_eof1171: cs = 1171; goto _test_eof; 
	_test_eof1172: cs = 1172; goto _test_eof; 
	_test_eof1173: cs = 1173; goto _test_eof; 
	_test_eof1174: cs = 1174; goto _test_eof; 
	_test_eof1175: cs = 1175; goto _test_eof; 
	_test_eof1176: cs = 1176; goto _test_eof; 
	_test_eof1177: cs = 1177; goto _test_eof; 
	_test_eof1178: cs = 1178; goto _test_eof; 
	_test_eof1179: cs = 1179; goto _test_eof; 
	_test_eof1180: cs = 1180; goto _test_eof; 
	_test_eof1181: cs = 1181; goto _test_eof; 
	_test_eof1182: cs = 1182; goto _test_eof; 
	_test_eof1183: cs = 1183; goto _test_eof; 
	_test_eof1184: cs = 1184; goto _test_eof; 
	_test_eof1185: cs = 1185; goto _test_eof; 
	_test_eof1186: cs = 1186; goto _test_eof; 
	_test_eof1187: cs = 1187; goto _test_eof; 
	_test_eof1188: cs = 1188; goto _test_eof; 
	_test_eof1189: cs = 1189; goto _test_eof; 
	_test_eof1190: cs = 1190; goto _test_eof; 
	_test_eof1191: cs = 1191; goto _test_eof; 
	_test_eof1192: cs = 1192; goto _test_eof; 
	_test_eof1193: cs = 1193; goto _test_eof; 
	_test_eof1194: cs = 1194; goto _test_eof; 
	_test_eof1195: cs = 1195; goto _test_eof; 
	_test_eof1196: cs = 1196; goto _test_eof; 
	_test_eof1197: cs = 1197; goto _test_eof; 
	_test_eof1198: cs = 1198; goto _test_eof; 
	_test_eof1199: cs = 1199; goto _test_eof; 
	_test_eof1200: cs = 1200; goto _test_eof; 
	_test_eof1201: cs = 1201; goto _test_eof; 
	_test_eof1202: cs = 1202; goto _test_eof; 
	_test_eof1781: cs = 1781; goto _test_eof; 
	_test_eof1203: cs = 1203; goto _test_eof; 
	_test_eof1782: cs = 1782; goto _test_eof; 
	_test_eof1204: cs = 1204; goto _test_eof; 
	_test_eof1205: cs = 1205; goto _test_eof; 
	_test_eof1206: cs = 1206; goto _test_eof; 
	_test_eof1207: cs = 1207; goto _test_eof; 
	_test_eof1208: cs = 1208; goto _test_eof; 
	_test_eof1209: cs = 1209; goto _test_eof; 
	_test_eof1210: cs = 1210; goto _test_eof; 
	_test_eof1211: cs = 1211; goto _test_eof; 
	_test_eof1212: cs = 1212; goto _test_eof; 
	_test_eof1213: cs = 1213; goto _test_eof; 
	_test_eof1214: cs = 1214; goto _test_eof; 
	_test_eof1215: cs = 1215; goto _test_eof; 
	_test_eof1216: cs = 1216; goto _test_eof; 
	_test_eof1217: cs = 1217; goto _test_eof; 
	_test_eof1218: cs = 1218; goto _test_eof; 
	_test_eof1219: cs = 1219; goto _test_eof; 
	_test_eof1220: cs = 1220; goto _test_eof; 
	_test_eof1221: cs = 1221; goto _test_eof; 
	_test_eof1222: cs = 1222; goto _test_eof; 
	_test_eof1223: cs = 1223; goto _test_eof; 
	_test_eof1224: cs = 1224; goto _test_eof; 
	_test_eof1225: cs = 1225; goto _test_eof; 
	_test_eof1226: cs = 1226; goto _test_eof; 
	_test_eof1227: cs = 1227; goto _test_eof; 
	_test_eof1228: cs = 1228; goto _test_eof; 
	_test_eof1229: cs = 1229; goto _test_eof; 
	_test_eof1230: cs = 1230; goto _test_eof; 
	_test_eof1231: cs = 1231; goto _test_eof; 
	_test_eof1232: cs = 1232; goto _test_eof; 
	_test_eof1233: cs = 1233; goto _test_eof; 
	_test_eof1234: cs = 1234; goto _test_eof; 
	_test_eof1235: cs = 1235; goto _test_eof; 
	_test_eof1236: cs = 1236; goto _test_eof; 
	_test_eof1237: cs = 1237; goto _test_eof; 
	_test_eof1238: cs = 1238; goto _test_eof; 
	_test_eof1239: cs = 1239; goto _test_eof; 
	_test_eof1240: cs = 1240; goto _test_eof; 
	_test_eof1241: cs = 1241; goto _test_eof; 
	_test_eof1242: cs = 1242; goto _test_eof; 
	_test_eof1243: cs = 1243; goto _test_eof; 
	_test_eof1244: cs = 1244; goto _test_eof; 
	_test_eof1245: cs = 1245; goto _test_eof; 
	_test_eof1246: cs = 1246; goto _test_eof; 
	_test_eof1247: cs = 1247; goto _test_eof; 
	_test_eof1248: cs = 1248; goto _test_eof; 
	_test_eof1249: cs = 1249; goto _test_eof; 
	_test_eof1250: cs = 1250; goto _test_eof; 
	_test_eof1251: cs = 1251; goto _test_eof; 
	_test_eof1252: cs = 1252; goto _test_eof; 
	_test_eof1253: cs = 1253; goto _test_eof; 
	_test_eof1254: cs = 1254; goto _test_eof; 
	_test_eof1783: cs = 1783; goto _test_eof; 
	_test_eof1255: cs = 1255; goto _test_eof; 
	_test_eof1784: cs = 1784; goto _test_eof; 
	_test_eof1256: cs = 1256; goto _test_eof; 
	_test_eof1257: cs = 1257; goto _test_eof; 
	_test_eof1258: cs = 1258; goto _test_eof; 
	_test_eof1259: cs = 1259; goto _test_eof; 
	_test_eof1260: cs = 1260; goto _test_eof; 
	_test_eof1261: cs = 1261; goto _test_eof; 
	_test_eof1262: cs = 1262; goto _test_eof; 
	_test_eof1263: cs = 1263; goto _test_eof; 
	_test_eof1264: cs = 1264; goto _test_eof; 
	_test_eof1265: cs = 1265; goto _test_eof; 
	_test_eof1266: cs = 1266; goto _test_eof; 
	_test_eof1267: cs = 1267; goto _test_eof; 
	_test_eof1268: cs = 1268; goto _test_eof; 
	_test_eof1269: cs = 1269; goto _test_eof; 
	_test_eof1270: cs = 1270; goto _test_eof; 
	_test_eof1271: cs = 1271; goto _test_eof; 
	_test_eof1272: cs = 1272; goto _test_eof; 
	_test_eof1273: cs = 1273; goto _test_eof; 
	_test_eof1274: cs = 1274; goto _test_eof; 
	_test_eof1275: cs = 1275; goto _test_eof; 
	_test_eof1276: cs = 1276; goto _test_eof; 
	_test_eof1277: cs = 1277; goto _test_eof; 
	_test_eof1278: cs = 1278; goto _test_eof; 
	_test_eof1279: cs = 1279; goto _test_eof; 
	_test_eof1280: cs = 1280; goto _test_eof; 
	_test_eof1281: cs = 1281; goto _test_eof; 
	_test_eof1282: cs = 1282; goto _test_eof; 
	_test_eof1283: cs = 1283; goto _test_eof; 
	_test_eof1284: cs = 1284; goto _test_eof; 
	_test_eof1285: cs = 1285; goto _test_eof; 
	_test_eof1286: cs = 1286; goto _test_eof; 
	_test_eof1287: cs = 1287; goto _test_eof; 
	_test_eof1288: cs = 1288; goto _test_eof; 
	_test_eof1289: cs = 1289; goto _test_eof; 
	_test_eof1290: cs = 1290; goto _test_eof; 
	_test_eof1291: cs = 1291; goto _test_eof; 
	_test_eof1292: cs = 1292; goto _test_eof; 
	_test_eof1293: cs = 1293; goto _test_eof; 
	_test_eof1294: cs = 1294; goto _test_eof; 
	_test_eof1295: cs = 1295; goto _test_eof; 
	_test_eof1296: cs = 1296; goto _test_eof; 
	_test_eof1297: cs = 1297; goto _test_eof; 
	_test_eof1298: cs = 1298; goto _test_eof; 
	_test_eof1299: cs = 1299; goto _test_eof; 
	_test_eof1300: cs = 1300; goto _test_eof; 
	_test_eof1301: cs = 1301; goto _test_eof; 
	_test_eof1302: cs = 1302; goto _test_eof; 
	_test_eof1303: cs = 1303; goto _test_eof; 
	_test_eof1304: cs = 1304; goto _test_eof; 
	_test_eof1305: cs = 1305; goto _test_eof; 
	_test_eof1306: cs = 1306; goto _test_eof; 
	_test_eof1307: cs = 1307; goto _test_eof; 
	_test_eof1308: cs = 1308; goto _test_eof; 
	_test_eof1309: cs = 1309; goto _test_eof; 
	_test_eof1785: cs = 1785; goto _test_eof; 
	_test_eof1310: cs = 1310; goto _test_eof; 
	_test_eof1786: cs = 1786; goto _test_eof; 
	_test_eof1311: cs = 1311; goto _test_eof; 
	_test_eof1312: cs = 1312; goto _test_eof; 
	_test_eof1313: cs = 1313; goto _test_eof; 
	_test_eof1314: cs = 1314; goto _test_eof; 
	_test_eof1315: cs = 1315; goto _test_eof; 
	_test_eof1316: cs = 1316; goto _test_eof; 
	_test_eof1317: cs = 1317; goto _test_eof; 
	_test_eof1318: cs = 1318; goto _test_eof; 
	_test_eof1319: cs = 1319; goto _test_eof; 
	_test_eof1320: cs = 1320; goto _test_eof; 
	_test_eof1321: cs = 1321; goto _test_eof; 
	_test_eof1322: cs = 1322; goto _test_eof; 
	_test_eof1323: cs = 1323; goto _test_eof; 
	_test_eof1324: cs = 1324; goto _test_eof; 
	_test_eof1325: cs = 1325; goto _test_eof; 
	_test_eof1326: cs = 1326; goto _test_eof; 
	_test_eof1787: cs = 1787; goto _test_eof; 
	_test_eof1327: cs = 1327; goto _test_eof; 
	_test_eof1788: cs = 1788; goto _test_eof; 
	_test_eof1328: cs = 1328; goto _test_eof; 
	_test_eof1329: cs = 1329; goto _test_eof; 
	_test_eof1330: cs = 1330; goto _test_eof; 
	_test_eof1331: cs = 1331; goto _test_eof; 
	_test_eof1332: cs = 1332; goto _test_eof; 
	_test_eof1333: cs = 1333; goto _test_eof; 
	_test_eof1334: cs = 1334; goto _test_eof; 
	_test_eof1335: cs = 1335; goto _test_eof; 
	_test_eof1336: cs = 1336; goto _test_eof; 
	_test_eof1337: cs = 1337; goto _test_eof; 
	_test_eof1338: cs = 1338; goto _test_eof; 
	_test_eof1339: cs = 1339; goto _test_eof; 
	_test_eof1340: cs = 1340; goto _test_eof; 
	_test_eof1341: cs = 1341; goto _test_eof; 
	_test_eof1342: cs = 1342; goto _test_eof; 
	_test_eof1343: cs = 1343; goto _test_eof; 
	_test_eof1344: cs = 1344; goto _test_eof; 
	_test_eof1345: cs = 1345; goto _test_eof; 
	_test_eof1346: cs = 1346; goto _test_eof; 
	_test_eof1347: cs = 1347; goto _test_eof; 
	_test_eof1348: cs = 1348; goto _test_eof; 
	_test_eof1349: cs = 1349; goto _test_eof; 
	_test_eof1350: cs = 1350; goto _test_eof; 
	_test_eof1351: cs = 1351; goto _test_eof; 
	_test_eof1352: cs = 1352; goto _test_eof; 
	_test_eof1353: cs = 1353; goto _test_eof; 
	_test_eof1354: cs = 1354; goto _test_eof; 
	_test_eof1355: cs = 1355; goto _test_eof; 
	_test_eof1356: cs = 1356; goto _test_eof; 
	_test_eof1357: cs = 1357; goto _test_eof; 
	_test_eof1358: cs = 1358; goto _test_eof; 
	_test_eof1359: cs = 1359; goto _test_eof; 
	_test_eof1360: cs = 1360; goto _test_eof; 
	_test_eof1361: cs = 1361; goto _test_eof; 
	_test_eof1362: cs = 1362; goto _test_eof; 
	_test_eof1363: cs = 1363; goto _test_eof; 
	_test_eof1364: cs = 1364; goto _test_eof; 
	_test_eof1365: cs = 1365; goto _test_eof; 
	_test_eof1366: cs = 1366; goto _test_eof; 
	_test_eof1367: cs = 1367; goto _test_eof; 
	_test_eof1368: cs = 1368; goto _test_eof; 
	_test_eof1369: cs = 1369; goto _test_eof; 
	_test_eof1370: cs = 1370; goto _test_eof; 
	_test_eof1371: cs = 1371; goto _test_eof; 
	_test_eof1372: cs = 1372; goto _test_eof; 
	_test_eof1373: cs = 1373; goto _test_eof; 
	_test_eof1374: cs = 1374; goto _test_eof; 
	_test_eof1375: cs = 1375; goto _test_eof; 
	_test_eof1376: cs = 1376; goto _test_eof; 
	_test_eof1377: cs = 1377; goto _test_eof; 
	_test_eof1378: cs = 1378; goto _test_eof; 
	_test_eof1379: cs = 1379; goto _test_eof; 
	_test_eof1380: cs = 1380; goto _test_eof; 
	_test_eof1381: cs = 1381; goto _test_eof; 
	_test_eof1382: cs = 1382; goto _test_eof; 
	_test_eof1383: cs = 1383; goto _test_eof; 
	_test_eof1384: cs = 1384; goto _test_eof; 
	_test_eof1385: cs = 1385; goto _test_eof; 
	_test_eof1386: cs = 1386; goto _test_eof; 
	_test_eof1387: cs = 1387; goto _test_eof; 
	_test_eof1388: cs = 1388; goto _test_eof; 
	_test_eof1389: cs = 1389; goto _test_eof; 
	_test_eof1390: cs = 1390; goto _test_eof; 
	_test_eof1391: cs = 1391; goto _test_eof; 
	_test_eof1392: cs = 1392; goto _test_eof; 
	_test_eof1393: cs = 1393; goto _test_eof; 
	_test_eof1394: cs = 1394; goto _test_eof; 
	_test_eof1395: cs = 1395; goto _test_eof; 
	_test_eof1396: cs = 1396; goto _test_eof; 
	_test_eof1397: cs = 1397; goto _test_eof; 
	_test_eof1398: cs = 1398; goto _test_eof; 
	_test_eof1399: cs = 1399; goto _test_eof; 
	_test_eof1400: cs = 1400; goto _test_eof; 
	_test_eof1401: cs = 1401; goto _test_eof; 
	_test_eof1402: cs = 1402; goto _test_eof; 
	_test_eof1403: cs = 1403; goto _test_eof; 
	_test_eof1404: cs = 1404; goto _test_eof; 
	_test_eof1405: cs = 1405; goto _test_eof; 
	_test_eof1406: cs = 1406; goto _test_eof; 
	_test_eof1407: cs = 1407; goto _test_eof; 
	_test_eof1408: cs = 1408; goto _test_eof; 
	_test_eof1409: cs = 1409; goto _test_eof; 
	_test_eof1410: cs = 1410; goto _test_eof; 
	_test_eof1411: cs = 1411; goto _test_eof; 
	_test_eof1412: cs = 1412; goto _test_eof; 
	_test_eof1413: cs = 1413; goto _test_eof; 
	_test_eof1414: cs = 1414; goto _test_eof; 
	_test_eof1415: cs = 1415; goto _test_eof; 
	_test_eof1416: cs = 1416; goto _test_eof; 
	_test_eof1417: cs = 1417; goto _test_eof; 
	_test_eof1418: cs = 1418; goto _test_eof; 
	_test_eof1419: cs = 1419; goto _test_eof; 
	_test_eof1420: cs = 1420; goto _test_eof; 
	_test_eof1421: cs = 1421; goto _test_eof; 
	_test_eof1422: cs = 1422; goto _test_eof; 
	_test_eof1423: cs = 1423; goto _test_eof; 
	_test_eof1424: cs = 1424; goto _test_eof; 
	_test_eof1425: cs = 1425; goto _test_eof; 
	_test_eof1426: cs = 1426; goto _test_eof; 
	_test_eof1427: cs = 1427; goto _test_eof; 
	_test_eof1428: cs = 1428; goto _test_eof; 
	_test_eof1429: cs = 1429; goto _test_eof; 
	_test_eof1430: cs = 1430; goto _test_eof; 
	_test_eof1431: cs = 1431; goto _test_eof; 
	_test_eof1432: cs = 1432; goto _test_eof; 
	_test_eof1433: cs = 1433; goto _test_eof; 
	_test_eof1434: cs = 1434; goto _test_eof; 
	_test_eof1435: cs = 1435; goto _test_eof; 
	_test_eof1436: cs = 1436; goto _test_eof; 
	_test_eof1437: cs = 1437; goto _test_eof; 
	_test_eof1438: cs = 1438; goto _test_eof; 
	_test_eof1439: cs = 1439; goto _test_eof; 
	_test_eof1440: cs = 1440; goto _test_eof; 
	_test_eof1441: cs = 1441; goto _test_eof; 
	_test_eof1442: cs = 1442; goto _test_eof; 
	_test_eof1443: cs = 1443; goto _test_eof; 
	_test_eof1444: cs = 1444; goto _test_eof; 
	_test_eof1445: cs = 1445; goto _test_eof; 
	_test_eof1446: cs = 1446; goto _test_eof; 
	_test_eof1447: cs = 1447; goto _test_eof; 
	_test_eof1448: cs = 1448; goto _test_eof; 
	_test_eof1449: cs = 1449; goto _test_eof; 
	_test_eof1450: cs = 1450; goto _test_eof; 
	_test_eof1451: cs = 1451; goto _test_eof; 
	_test_eof1452: cs = 1452; goto _test_eof; 
	_test_eof1453: cs = 1453; goto _test_eof; 
	_test_eof1454: cs = 1454; goto _test_eof; 
	_test_eof1455: cs = 1455; goto _test_eof; 
	_test_eof1456: cs = 1456; goto _test_eof; 
	_test_eof1457: cs = 1457; goto _test_eof; 
	_test_eof1458: cs = 1458; goto _test_eof; 
	_test_eof1459: cs = 1459; goto _test_eof; 
	_test_eof1460: cs = 1460; goto _test_eof; 
	_test_eof1461: cs = 1461; goto _test_eof; 
	_test_eof1462: cs = 1462; goto _test_eof; 
	_test_eof1463: cs = 1463; goto _test_eof; 
	_test_eof1464: cs = 1464; goto _test_eof; 
	_test_eof1465: cs = 1465; goto _test_eof; 
	_test_eof1466: cs = 1466; goto _test_eof; 
	_test_eof1467: cs = 1467; goto _test_eof; 
	_test_eof1468: cs = 1468; goto _test_eof; 
	_test_eof1469: cs = 1469; goto _test_eof; 
	_test_eof1470: cs = 1470; goto _test_eof; 
	_test_eof1471: cs = 1471; goto _test_eof; 
	_test_eof1472: cs = 1472; goto _test_eof; 
	_test_eof1473: cs = 1473; goto _test_eof; 
	_test_eof1474: cs = 1474; goto _test_eof; 
	_test_eof1475: cs = 1475; goto _test_eof; 
	_test_eof1476: cs = 1476; goto _test_eof; 
	_test_eof1477: cs = 1477; goto _test_eof; 
	_test_eof1478: cs = 1478; goto _test_eof; 
	_test_eof1479: cs = 1479; goto _test_eof; 
	_test_eof1480: cs = 1480; goto _test_eof; 
	_test_eof1481: cs = 1481; goto _test_eof; 
	_test_eof1482: cs = 1482; goto _test_eof; 
	_test_eof1483: cs = 1483; goto _test_eof; 
	_test_eof1484: cs = 1484; goto _test_eof; 
	_test_eof1485: cs = 1485; goto _test_eof; 
	_test_eof1486: cs = 1486; goto _test_eof; 
	_test_eof1487: cs = 1487; goto _test_eof; 
	_test_eof1488: cs = 1488; goto _test_eof; 
	_test_eof1489: cs = 1489; goto _test_eof; 
	_test_eof1490: cs = 1490; goto _test_eof; 
	_test_eof1491: cs = 1491; goto _test_eof; 
	_test_eof1492: cs = 1492; goto _test_eof; 
	_test_eof1493: cs = 1493; goto _test_eof; 
	_test_eof1494: cs = 1494; goto _test_eof; 
	_test_eof1495: cs = 1495; goto _test_eof; 
	_test_eof1496: cs = 1496; goto _test_eof; 
	_test_eof1497: cs = 1497; goto _test_eof; 
	_test_eof1789: cs = 1789; goto _test_eof; 
	_test_eof1498: cs = 1498; goto _test_eof; 
	_test_eof1790: cs = 1790; goto _test_eof; 
	_test_eof1499: cs = 1499; goto _test_eof; 
	_test_eof1500: cs = 1500; goto _test_eof; 
	_test_eof1501: cs = 1501; goto _test_eof; 
	_test_eof1502: cs = 1502; goto _test_eof; 
	_test_eof1503: cs = 1503; goto _test_eof; 
	_test_eof1504: cs = 1504; goto _test_eof; 
	_test_eof1505: cs = 1505; goto _test_eof; 
	_test_eof1506: cs = 1506; goto _test_eof; 
	_test_eof1507: cs = 1507; goto _test_eof; 
	_test_eof1508: cs = 1508; goto _test_eof; 
	_test_eof1509: cs = 1509; goto _test_eof; 
	_test_eof1510: cs = 1510; goto _test_eof; 
	_test_eof1511: cs = 1511; goto _test_eof; 
	_test_eof1512: cs = 1512; goto _test_eof; 
	_test_eof1513: cs = 1513; goto _test_eof; 
	_test_eof1514: cs = 1514; goto _test_eof; 
	_test_eof1515: cs = 1515; goto _test_eof; 
	_test_eof1516: cs = 1516; goto _test_eof; 
	_test_eof1517: cs = 1517; goto _test_eof; 
	_test_eof1518: cs = 1518; goto _test_eof; 
	_test_eof1519: cs = 1519; goto _test_eof; 
	_test_eof1520: cs = 1520; goto _test_eof; 
	_test_eof1521: cs = 1521; goto _test_eof; 
	_test_eof1522: cs = 1522; goto _test_eof; 
	_test_eof1523: cs = 1523; goto _test_eof; 
	_test_eof1524: cs = 1524; goto _test_eof; 
	_test_eof1525: cs = 1525; goto _test_eof; 
	_test_eof1526: cs = 1526; goto _test_eof; 
	_test_eof1527: cs = 1527; goto _test_eof; 
	_test_eof1528: cs = 1528; goto _test_eof; 
	_test_eof1529: cs = 1529; goto _test_eof; 
	_test_eof1530: cs = 1530; goto _test_eof; 
	_test_eof1531: cs = 1531; goto _test_eof; 
	_test_eof1532: cs = 1532; goto _test_eof; 
	_test_eof1533: cs = 1533; goto _test_eof; 
	_test_eof1534: cs = 1534; goto _test_eof; 
	_test_eof1535: cs = 1535; goto _test_eof; 
	_test_eof1536: cs = 1536; goto _test_eof; 
	_test_eof1537: cs = 1537; goto _test_eof; 
	_test_eof1538: cs = 1538; goto _test_eof; 
	_test_eof1539: cs = 1539; goto _test_eof; 
	_test_eof1540: cs = 1540; goto _test_eof; 
	_test_eof1541: cs = 1541; goto _test_eof; 
	_test_eof1542: cs = 1542; goto _test_eof; 
	_test_eof1543: cs = 1543; goto _test_eof; 
	_test_eof1544: cs = 1544; goto _test_eof; 
	_test_eof1545: cs = 1545; goto _test_eof; 
	_test_eof1546: cs = 1546; goto _test_eof; 
	_test_eof1547: cs = 1547; goto _test_eof; 
	_test_eof1791: cs = 1791; goto _test_eof; 
	_test_eof1548: cs = 1548; goto _test_eof; 
	_test_eof1792: cs = 1792; goto _test_eof; 
	_test_eof1549: cs = 1549; goto _test_eof; 
	_test_eof1550: cs = 1550; goto _test_eof; 
	_test_eof1551: cs = 1551; goto _test_eof; 
	_test_eof1552: cs = 1552; goto _test_eof; 
	_test_eof1793: cs = 1793; goto _test_eof; 
	_test_eof1553: cs = 1553; goto _test_eof; 
	_test_eof1554: cs = 1554; goto _test_eof; 
	_test_eof1555: cs = 1555; goto _test_eof; 
	_test_eof1556: cs = 1556; goto _test_eof; 
	_test_eof1557: cs = 1557; goto _test_eof; 
	_test_eof1558: cs = 1558; goto _test_eof; 
	_test_eof1559: cs = 1559; goto _test_eof; 
	_test_eof1560: cs = 1560; goto _test_eof; 
	_test_eof1561: cs = 1561; goto _test_eof; 
	_test_eof1562: cs = 1562; goto _test_eof; 
	_test_eof1563: cs = 1563; goto _test_eof; 
	_test_eof1564: cs = 1564; goto _test_eof; 
	_test_eof1565: cs = 1565; goto _test_eof; 
	_test_eof1566: cs = 1566; goto _test_eof; 
	_test_eof1567: cs = 1567; goto _test_eof; 
	_test_eof1568: cs = 1568; goto _test_eof; 
	_test_eof1569: cs = 1569; goto _test_eof; 
	_test_eof1570: cs = 1570; goto _test_eof; 
	_test_eof1571: cs = 1571; goto _test_eof; 
	_test_eof1572: cs = 1572; goto _test_eof; 
	_test_eof1573: cs = 1573; goto _test_eof; 
	_test_eof1574: cs = 1574; goto _test_eof; 
	_test_eof1575: cs = 1575; goto _test_eof; 
	_test_eof1576: cs = 1576; goto _test_eof; 
	_test_eof1577: cs = 1577; goto _test_eof; 
	_test_eof1578: cs = 1578; goto _test_eof; 
	_test_eof1579: cs = 1579; goto _test_eof; 
	_test_eof1580: cs = 1580; goto _test_eof; 
	_test_eof1581: cs = 1581; goto _test_eof; 
	_test_eof1794: cs = 1794; goto _test_eof; 
	_test_eof1582: cs = 1582; goto _test_eof; 
	_test_eof1795: cs = 1795; goto _test_eof; 
	_test_eof1583: cs = 1583; goto _test_eof; 
	_test_eof1584: cs = 1584; goto _test_eof; 
	_test_eof1585: cs = 1585; goto _test_eof; 
	_test_eof1586: cs = 1586; goto _test_eof; 
	_test_eof1587: cs = 1587; goto _test_eof; 
	_test_eof1588: cs = 1588; goto _test_eof; 
	_test_eof1589: cs = 1589; goto _test_eof; 
	_test_eof1590: cs = 1590; goto _test_eof; 
	_test_eof1591: cs = 1591; goto _test_eof; 
	_test_eof1592: cs = 1592; goto _test_eof; 
	_test_eof1593: cs = 1593; goto _test_eof; 
	_test_eof1594: cs = 1594; goto _test_eof; 
	_test_eof1595: cs = 1595; goto _test_eof; 
	_test_eof1596: cs = 1596; goto _test_eof; 
	_test_eof1597: cs = 1597; goto _test_eof; 
	_test_eof1598: cs = 1598; goto _test_eof; 
	_test_eof1599: cs = 1599; goto _test_eof; 
	_test_eof1600: cs = 1600; goto _test_eof; 
	_test_eof1601: cs = 1601; goto _test_eof; 
	_test_eof1602: cs = 1602; goto _test_eof; 
	_test_eof1603: cs = 1603; goto _test_eof; 
	_test_eof1604: cs = 1604; goto _test_eof; 
	_test_eof1605: cs = 1605; goto _test_eof; 
	_test_eof1606: cs = 1606; goto _test_eof; 
	_test_eof1607: cs = 1607; goto _test_eof; 
	_test_eof1608: cs = 1608; goto _test_eof; 
	_test_eof1609: cs = 1609; goto _test_eof; 
	_test_eof1610: cs = 1610; goto _test_eof; 
	_test_eof1611: cs = 1611; goto _test_eof; 
	_test_eof1612: cs = 1612; goto _test_eof; 
	_test_eof1613: cs = 1613; goto _test_eof; 
	_test_eof1614: cs = 1614; goto _test_eof; 
	_test_eof1615: cs = 1615; goto _test_eof; 
	_test_eof1616: cs = 1616; goto _test_eof; 
	_test_eof1796: cs = 1796; goto _test_eof; 
	_test_eof1617: cs = 1617; goto _test_eof; 
	_test_eof1797: cs = 1797; goto _test_eof; 
	_test_eof1618: cs = 1618; goto _test_eof; 
	_test_eof1619: cs = 1619; goto _test_eof; 
	_test_eof1620: cs = 1620; goto _test_eof; 
	_test_eof1621: cs = 1621; goto _test_eof; 
	_test_eof1798: cs = 1798; goto _test_eof; 
	_test_eof1622: cs = 1622; goto _test_eof; 
	_test_eof1623: cs = 1623; goto _test_eof; 
	_test_eof1624: cs = 1624; goto _test_eof; 
	_test_eof1625: cs = 1625; goto _test_eof; 
	_test_eof1626: cs = 1626; goto _test_eof; 
	_test_eof1627: cs = 1627; goto _test_eof; 
	_test_eof1628: cs = 1628; goto _test_eof; 
	_test_eof1629: cs = 1629; goto _test_eof; 
	_test_eof1630: cs = 1630; goto _test_eof; 
	_test_eof1631: cs = 1631; goto _test_eof; 
	_test_eof1632: cs = 1632; goto _test_eof; 
	_test_eof1633: cs = 1633; goto _test_eof; 
	_test_eof1634: cs = 1634; goto _test_eof; 
	_test_eof1635: cs = 1635; goto _test_eof; 
	_test_eof1636: cs = 1636; goto _test_eof; 
	_test_eof1637: cs = 1637; goto _test_eof; 
	_test_eof1638: cs = 1638; goto _test_eof; 
	_test_eof1639: cs = 1639; goto _test_eof; 
	_test_eof1640: cs = 1640; goto _test_eof; 
	_test_eof1641: cs = 1641; goto _test_eof; 
	_test_eof1642: cs = 1642; goto _test_eof; 
	_test_eof1643: cs = 1643; goto _test_eof; 
	_test_eof1644: cs = 1644; goto _test_eof; 
	_test_eof1645: cs = 1645; goto _test_eof; 
	_test_eof1646: cs = 1646; goto _test_eof; 
	_test_eof1647: cs = 1647; goto _test_eof; 
	_test_eof1648: cs = 1648; goto _test_eof; 
	_test_eof1649: cs = 1649; goto _test_eof; 
	_test_eof1650: cs = 1650; goto _test_eof; 
	_test_eof1651: cs = 1651; goto _test_eof; 
	_test_eof1652: cs = 1652; goto _test_eof; 
	_test_eof1653: cs = 1653; goto _test_eof; 
	_test_eof1654: cs = 1654; goto _test_eof; 
	_test_eof1655: cs = 1655; goto _test_eof; 
	_test_eof1656: cs = 1656; goto _test_eof; 
	_test_eof1657: cs = 1657; goto _test_eof; 
	_test_eof1658: cs = 1658; goto _test_eof; 
	_test_eof1659: cs = 1659; goto _test_eof; 
	_test_eof1660: cs = 1660; goto _test_eof; 
	_test_eof1661: cs = 1661; goto _test_eof; 
	_test_eof1662: cs = 1662; goto _test_eof; 
	_test_eof1663: cs = 1663; goto _test_eof; 
	_test_eof1664: cs = 1664; goto _test_eof; 
	_test_eof1665: cs = 1665; goto _test_eof; 
	_test_eof1666: cs = 1666; goto _test_eof; 
	_test_eof1667: cs = 1667; goto _test_eof; 
	_test_eof1668: cs = 1668; goto _test_eof; 
	_test_eof1669: cs = 1669; goto _test_eof; 
	_test_eof1670: cs = 1670; goto _test_eof; 
	_test_eof1671: cs = 1671; goto _test_eof; 
	_test_eof1672: cs = 1672; goto _test_eof; 
	_test_eof1673: cs = 1673; goto _test_eof; 
	_test_eof1674: cs = 1674; goto _test_eof; 
	_test_eof1675: cs = 1675; goto _test_eof; 
	_test_eof1676: cs = 1676; goto _test_eof; 
	_test_eof1677: cs = 1677; goto _test_eof; 
	_test_eof1678: cs = 1678; goto _test_eof; 
	_test_eof1679: cs = 1679; goto _test_eof; 
	_test_eof1680: cs = 1680; goto _test_eof; 
	_test_eof1681: cs = 1681; goto _test_eof; 
	_test_eof1682: cs = 1682; goto _test_eof; 
	_test_eof1683: cs = 1683; goto _test_eof; 
	_test_eof1684: cs = 1684; goto _test_eof; 
	_test_eof1685: cs = 1685; goto _test_eof; 
	_test_eof1686: cs = 1686; goto _test_eof; 
	_test_eof1687: cs = 1687; goto _test_eof; 
	_test_eof1688: cs = 1688; goto _test_eof; 
	_test_eof1689: cs = 1689; goto _test_eof; 
	_test_eof1690: cs = 1690; goto _test_eof; 
	_test_eof1691: cs = 1691; goto _test_eof; 
	_test_eof1692: cs = 1692; goto _test_eof; 
	_test_eof1693: cs = 1693; goto _test_eof; 
	_test_eof1694: cs = 1694; goto _test_eof; 
	_test_eof1695: cs = 1695; goto _test_eof; 
	_test_eof1696: cs = 1696; goto _test_eof; 
	_test_eof1697: cs = 1697; goto _test_eof; 
	_test_eof1698: cs = 1698; goto _test_eof; 
	_test_eof1699: cs = 1699; goto _test_eof; 
	_test_eof1700: cs = 1700; goto _test_eof; 
	_test_eof1701: cs = 1701; goto _test_eof; 
	_test_eof1702: cs = 1702; goto _test_eof; 
	_test_eof1703: cs = 1703; goto _test_eof; 
	_test_eof1704: cs = 1704; goto _test_eof; 
	_test_eof1705: cs = 1705; goto _test_eof; 
	_test_eof1706: cs = 1706; goto _test_eof; 
	_test_eof1707: cs = 1707; goto _test_eof; 
	_test_eof1708: cs = 1708; goto _test_eof; 
	_test_eof1709: cs = 1709; goto _test_eof; 
	_test_eof1710: cs = 1710; goto _test_eof; 
	_test_eof1711: cs = 1711; goto _test_eof; 
	_test_eof1712: cs = 1712; goto _test_eof; 
	_test_eof1713: cs = 1713; goto _test_eof; 
	_test_eof1714: cs = 1714; goto _test_eof; 
	_test_eof1715: cs = 1715; goto _test_eof; 
	_test_eof1716: cs = 1716; goto _test_eof; 
	_test_eof1717: cs = 1717; goto _test_eof; 
	_test_eof1718: cs = 1718; goto _test_eof; 

	_test_eof: {}
	_out: {}
	}

// line 164 "zparse.rl"


/*
    This part needs work
        if cs < z_first_final {
                // No clue what I'm doing what so ever
                if p == pe {
                        println("unexpected eof")
                        return z, nil
                } else {
                        println("error at position ", p)
                        return z, nil
                }
        }
*/
        return z, nil
}
